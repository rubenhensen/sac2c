/*
 * $Log$
 * Revision 1.3  1995/03/31 13:26:08  sbs
 * includes take drop psi binop & const
 *
# Revision 1.2  1995/03/07  18:03:37  sbs
# PSI-macros done.
#
# Revision 1.1  1995/03/03  14:40:13  sbs
# Initial revision
#
 *
 */

This file contains information about the SAC Intermediate-Code_Macros.

SAC-ICM is used as an intermediate level of code generation. It explicitly
integrates informations about type and memory usage into the code.
It does NOT require a specific C-representation of SAC-arrays!

ND stands for Non-Distributed
KD stands for Known-Dimension
KS stands for Known-Shape

* indicates: not included in the minimum release!
+ indicates: included as macro in icm2c.h!

>>>> IMPORTANT NOTE !! >>>>
The C-representations of "normal", "KD", and "KS" arrays may be different!
Therefore, the sac2icm compiler NEVER should access an array with a macro
of the wrong extension, IF a macro with the correct extension is present!
If such a macro does not exsist, one of the next "smaller" category may be
used.
E.g. a "KD" array may be accessed by ND_A_DIM but not with ND_A_SHAPE!!!
<<<< IMPORTANT NOTE !! <<<<

Macros for declaring arrays:
============================

 ND_KS_DECL_ARRAY( basic_type, name, dim, s0,..., sn)	: declares an array
*ND_KD_DECL_ARRAY( basic_type, name, dim)		: declares an array
+ND_DECL_ARRAY( basic_type, name)			: declares an array

Macros for array access:
========================
+ND_A_FIELD( name)		: for accessing elements of the array
+ND_A_RC( name)			: accesses the refcnt
+ND_A_SIZE( name)		: accesses the size of the unrolling (in elements)
+ND_A_DIM( name)		: accesses the dimension of the array
+ND_KD_A_SHAPE( name, dim)	: accesses one shape component of an array
+ND_A_SHAPE( name, dim)		: accesses one shape component of an array
+ND_KS_ARG_ARRAY( type, name)   : macro for argument(s) in primitive functions
+ND_KS_RET_ARRAY( name)         : macro for return statement

Macros for initializing an array:
=================================

+ND_ALLOC_ARRAY( type, name)	: allocates memory needed

+ND_REUSE( old, new)		: reuses old for new
+ND_CHECK_REUSE( old, new)	: tries to reuse old for new

+ND_SET_RC( name, num)		: sets the refcnt
+ND_INC_RC( name, num)		: increments the refcnt
+ND_DEC_RC( name, num)		: decrements the refcnt
+ND_DEC_RC_FREE( name, num)	: decrements the refcnt
				  AND frees the array if refcnt becomes zero!
+ND_SET_SIZE( name, num)	: sets the size of the unrolling (in elements)

+ND_SET_DIM( name, num)	: sets the dimension of the array

 ND_KD_SET_SHAPE( name, dim, s0,..., sn)	: sets all shape components of an array
+ND_SET_SHAPE( name, dim, s)			: sets one shape component of an array
+ND_CREATE_CONST_ARRAY( basic_type, name, dim, s0,..., sn)   : generates a constant array


Macros for primitve arithmetic operations:
==========================================

+ND_BINOP_SxA_A( op, s, a2, res)	: realizes res=(s op a2)
+ND_BINOP_AxA_A( op, a1, a2, res)	: realizes res=(a1 op a2)

Macros for PSI-primitves:
=========================

 ND_KD_PSI_CxA_S( type, a, res, dim, v0,..., vn): selects a single element of the array
 ND_KD_PSI_VxA_S( type, a, res, dim, v )	: selects a single element of the array
 ND_KD_PSI_CxA_A( type, a, res, dim, v0,..., vn): selects a sub-array
 ND_KD_PSI_VxA_A( type, a, res, dim, v )	: selects a sub-array

 ND_KD_TAKE_CxA_A( type, a, res, dim, v0,..., vn):
 ND_KD_DROP_CxA_A( type, a, res, dim, v0,..., vn):
