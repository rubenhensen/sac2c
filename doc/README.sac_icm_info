/*
 * $Log$
 * Revision 1.10  1995/04/26 16:58:47  sbs
 * WITH-icms modified
 *
# Revision 1.9  1995/04/26  14:59:40  sbs
# dim_res inserted in END_WITH macros
#
# Revision 1.8  1995/04/26  14:02:13  hw
# Macros for with-loop inserted
#
# Revision 1.7  1995/04/19  13:39:22  sbs
# ND_KD_PSI_VxA_S & ND_KD_PSI_CxA_S updated
#
# Revision 1.6  1995/04/18  14:49:34  sbs
# ND_ALLOC_ARRAY modified; initial rc parameter;
# ND_CREATE_CONST_ARRAY modified; initial basic_type parameter eliminated;
#
# Revision 1.5  1995/04/18  11:24:51  sbs
# ND_KD_ROT_SxSxA_A eliminated
#
# Revision 1.4  1995/04/12  15:13:23  sbs
# cat & rot inserted.
#
# Revision 1.3  1995/03/31  13:26:08  sbs
# includes take drop psi binop & const
#
# Revision 1.2  1995/03/07  18:03:37  sbs
# PSI-macros done.
#
# Revision 1.1  1995/03/03  14:40:13  sbs
# Initial revision
#
 *
 */

This file contains information about the SAC Intermediate-Code_Macros.

SAC-ICM is used as an intermediate level of code generation. It explicitly
integrates informations about type and memory usage into the code.
It does NOT require a specific C-representation of SAC-arrays!

ND stands for Non-Distributed
KD stands for Known-Dimension
KS stands for Known-Shape

* indicates: not included in the minimum release!
+ indicates: included as macro in icm2c.h!

>>>> IMPORTANT NOTE !! >>>>
The C-representations of "normal", "KD", and "KS" arrays may be different!
Therefore, the sac2icm compiler NEVER should access an array with a macro
of the wrong extension, IF a macro with the correct extension is present!
If such a macro does not exsist, one of the next "smaller" category may be
used.
E.g. a "KD" array may be accessed by ND_A_DIM but not with ND_A_SHAPE!!!
<<<< IMPORTANT NOTE !! <<<<

Macros for declaring arrays:
============================

 ND_KS_DECL_ARRAY( basic_type, name, dim, s0,..., sn)	: declares an array
*ND_KD_DECL_ARRAY( basic_type, name, dim)		: declares an array
+ND_DECL_ARRAY( basic_type, name)			: declares an array

Macros for array access:
========================
+ND_A_FIELD( name)		: for accessing elements of the array
+ND_A_RC( name)			: accesses the refcnt
+ND_A_RCP( name)		: accesses the pointer to the refcnt
+ND_A_SIZE( name)		: accesses the size of the unrolling (in elements)
+ND_A_DIM( name)		: accesses the dimension of the array
+ND_KD_A_SHAPE( name, dim)	: accesses one shape component of an array
+ND_A_SHAPE( name, dim)		: accesses one shape component of an array

Macros for arrays as arguments:
===============================
+ND_KS_DEC_IN_ARRAY( type, name): macro for prototyping array as "in" parameters
+ND_KS_DEC_OUT_ARRAY( type, name):macro for prototyping array as "out" parameters
+ND_KS_AP_IN_ARRAY( name)	: macro for giving an array as argument
+ND_KS_AP_OUT_ARRAY( name)	: macro for getting an array as result
+ND_KS_RET_OUT_ARRAY( name)	: macro for returning an array

 ND_FUN_DEC( name, n, [ {in, in_a, out, out_a, inout, inout_a}, type, arg ] )	:
				  macro for generating a function declaration
 ND_FUN_AP( name, n, [ {in, in_a, out, out_a, inout, inout_a}, arg ] )		:
				  macro for generating a function application
 ND_FUN_RET( n, [ { out, out_a, inout, inout_a}, arg ] )			:
				  macro for returning resuluts of a function

Macros for initializing an array:
=================================

+ND_ALLOC_ARRAY( type, name, rc): allocates memory needed

+ND_REUSE( old, new)		: reuses old for new
+ND_CHECK_REUSE( old, new)	: tries to reuse old for new

+ND_SET_RC( name, num)		: sets the refcnt
+ND_INC_RC( name, num)		: increments the refcnt
+ND_DEC_RC( name, num)		: decrements the refcnt
+ND_DEC_RC_FREE( name, num)	: decrements the refcnt
				  AND frees the array if refcnt becomes zero!
+ND_SET_SIZE( name, num)	: sets the size of the unrolling (in elements)

+ND_SET_DIM( name, num)	: sets the dimension of the array

 ND_KD_SET_SHAPE( name, dim, s0,..., sn)	: sets all shape components of an array
+ND_SET_SHAPE( name, dim, s)			: sets one shape component of an array
 ND_CREATE_CONST_ARRAY( name, dim, s0,..., sn)  : generates a constant array
+ND_KS_ASSIGN_ARRAY( name, res)			: copy pointer(s) for "res=name;"


Macros for primitve arithmetic operations:
==========================================

+ND_BINOP_SxA_A( op, s, a2, res)	: realizes res=(s op a2)
+ND_BINOP_AxS_A( op, s, a2, res)	: realizes res=(a2 op s)
+ND_BINOP_AxA_A( op, a1, a2, res)	: realizes res=(a1 op a2)

Macros for PSI-primitves:
=========================

 ND_KD_PSI_CxA_S( a, res, dimv, v0,..., vn): selects a single element of the array
 ND_KD_PSI_VxA_S( a, res, dimv, v )	: selects a single element of the array
 ND_KD_PSI_CxA_A( dima, a, res, dimv, v0,..., vn): selects a sub-array
 ND_KD_PSI_VxA_A( dima, a, res, dimv, v )	: selects a sub-array

 ND_KD_TAKE_CxA_A( dima, a, res, dimv, v0,..., vn):
 ND_KD_DROP_CxA_A( dima, a, res, dimv, v0,..., vn):

 ND_KD_CAT_SxAxA_A( dima, a, b, res, catdim)	: 
 ND_KD_ROT_CxSxA_A( rotdim, numstr, dima, a, res):
 < ND_KD_ROT_SxSxA_A( rotdimstr, numstr, dima, a, res): >

Macros for WITH-loop:
=====================

 ND_BEGIN_MODARRAY( res, dim_res, arg, from, to, index, indexlen)
 ND_BEGIN_GENARRAY( res, dim_res, form, to, index, indexlen)
 
 ND_END_MODARRAY_S( res, dim_res, value)
 ND_END_MODARRAY_A( res, dim_res, array)
 ND_END_GENARRAY_S( res, dim_res, value)
 ND_END_GENARRAY_A( res, dim_res, array)
