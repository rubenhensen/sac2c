/*
 * $Log$
 * Revision 1.11  1995/01/16 11:11:21  hw
 * added information about N_ap
 * changed information about struct types
 *
# Revision 1.10  1994/12/31  15:14:17  sbs
# N_explist updated
#
# Revision 1.9  1994/12/21  13:22:34  hw
# removed N_addon etc
# changed information about N_typedef
#
# Revision 1.8  1994/12/20  14:46:25  hw
# added information about references to the variable declaration
#
# Revision 1.7  1994/12/20  13:12:29  sbs
# some typos corrected
#
# Revision 1.6  1994/12/16  14:50:49  sbs
# N_moduldec, N_classdec & N_explist inserted
#
# Revision 1.5  1994/12/16  09:35:53  sbs
# N_modul, N_implist, N_typedef & N_cast inserted
#
# Revision 1.4  1994/12/08  14:13:13  hw
# changed information about N_fundef
#
# Revision 1.3  1994/12/06  11:17:01  hw
# changed information about N_fundef and N_block
#
# Revision 1.2  1994/11/21  13:43:28  hw
# Log-header modified
#
 *
 */

This file contains information about the sac2c-syntaxtree-nodes.


The nodes have the following structure:

typedef struct NODE
{
   nodetype  nodetype;
   union
   {
      ids  *ids;       /* liste of identificators  */
      id   *id;        /* identifikator              */
      types *types;    /* typinformation             */
      int   cint;      /* integer-value              */
      float cfloat;    /* float-value                */
      prf   prf;       /* tag for primitive functions */

   }            info;     /* used for special informationen */
   int          nnode;    /* number of used children nodes */
   int          lineno;   /* commands linenumber */
   struct NODE *node[4];  /* children nodes */
} node;                   

N_moduldec, N_classdec:
=======================
node[0]    : export-list (N_explist)
node[1]    : import_list (N_implist) if present...
info.id    : name of the modul/class

N_explist:
==========
node[0]    : implicit types (N_typedef) if present...
node[1]    : explicit types (N_typedef) if present...
node[2]    : function declarations (N_fundef with NULL-body) if present...

N_modul:
========
nnode = 0 !!!!
node[0]    : import-list (N_implist) if present...
node[1]    : typedefs (N_typedef) if present...
node[2]    : fundefs (N_fundef) if present...
info.id    : Modul name/ NULL if simple program.

N_implist:
==========
nnode=0/1 !!!
node[0]    : subsequent imports if present...
node[1]    : casted to (ids *) !!! list of implicit type names!
node[2]    : casted to (ids *) !!! list of explicit type names!
node[3]    : casted to (ids *) !!! list of function names!
info.id    : name of import-file.

N_typedef:
==========
node[0]    : subsequent typedefs if present...
info.types : containes type and new typename (info.type->id) in one types-structure.

N_fundef:
=========
node[0]	   : functionbody (N_block)
node[1]    : next function (N_fundef), if there is one
node[2]    : arguments of function (N_arg), if there are some
info.types : first types structure contains the functions name and 
             the first part of the functions type. If a function has 
	     more than one return value, the types of these return 
	     values are strored in following types structures.
	     types looks like:
             typedef struct TYPES{
                simpletype   simpletype;
                char         *name;     /* only used for T_user !! */
                char         *name_mod; /* name of modul belonging to 'name' */
                int          dim;       /* if (dim == 0) => simpletype */
                shpseg       *shpseg;
                struct TYPES *next;     /* only needed for fun-results */
                id           *id;    /* Bezeichner  */
                char         *id_mod;  /* name of modul belonging to 'id' */
                } types;
        
N_arg:
=====
node[0]    : next argument (N_arg), if any
info.types : contains name and type of the argument. For infomation
	     about the structure of `types` look at description of
	     N_fundef.

N_block:
========
node[0]    : first node of the block (N_assign or N_empty)
node[1]    : variable declaration, if there are any

N_vardec:
=========
node[0]    : next declaration (N_vardec), if any
info.types : contains name and type of the declaration. For infomation
	     about the structure of `types` look at description of
	     N_fundef.

N_assign:
=========
node[0]    : instruction (N_let, N_cond, N_while, N_do, N_return, ...)
node[1]    : next assign node(N_assign), if any

N_let:
======
node[0]    : expression 
info.ids   : names of variables to assign to.
	     The structure of ids is:
              typedef struct IDS{
                       id          *id;
                       node        *node; /* will be set while typechecking */
                       struct IDS  *next;
                       } ids;

N_cast:
=======
node[0]    : expression
info.type  : new type

N_return:
=========
node[0]    : returnvalues (N_exprs)
/* N_return is used in two differnt ways. First it is the returnvalue
   of function and secondly it defines how an array is modified in a
   with-expression. */

N_cond:
=======
node[0]    : condition (N_expr)
node[1]    : then part
node[2]    : else part

N_do, N_while:
==============
node[0]    : termination conditon of the loop
node[1]    : body of the loop
/* for-loops are transformed into while-loops while parsing */

N_ap:
=====
node[0]    : arguments of function application (N_exprs)
node[1]    : pointer to the belonging functiondeclaration
             this pointer will be set while typechecking
             !!! nnode will not be increased !!!
info_node  : name of function to apply ( info.fun_name.id, 
                                         info.fun_name.id_mod)
/* the application node is only used for userdefined functions */

N_with:
=======
node[0]    : generator (N_generator)
node[1]    : body of with-statement

N_id:
=====
info.id    : name of identificator
node[0]    : pointer to the belonging variable declaration.
             it will be set while typechecking. 
             nnode is still 0 !!!! 
             

N_float:
========
info.cfloat : float value

N_Num:
======
info.cint   : interger value

N_prf:
======
node[0] - node[3] : arguments for primitive function
info.prf          : tag for kind of primitive function (F_add, F_sub,
	            F_mul, F_div, F_take, F_drop, F_psi, F_shape,
		    F_reshape, F_cat, F_dim, F_rotate, F_and, F_or, 
		    F_not, F_le, F_lt, F_eq, F_ge, F_gt, F_neq)

N_generator:
============
node[0]     : expression for left border of arraymanipulation
node[1]     : expression for right border of arrymanipulation
info.id     : name of bound variable for arraymanipulation

N_genarray, N_modarray:
=======================
node[0]     : array that will be manupulated
node[1]     : body

N_exprs:
========
node[0]     : expression
node[1]     : next expression (N_exprs), if any

N_array:
========
node[0]     : elements of the array (N_exprs)

N_empty:
========
/* this node  indicates that a block is empty */

N_post:
======
node[0]     : indicates whether it is a postincrement or postdecrement
info.id     : name of the identificator to be modified
node[1]     : will be set to belonging varaiable declaration while typechecking
              !!! nnode is still 1 !!!

N_pre:
======
node[0]     : indicates wheter it is a preincrement or predecrement
info.id     : name of modified identifikator
node[1]     : will be set to belonging varaiable declaration while typechecking
              !!! nnode is still 1 !!!

N_inc:
======
/* this node indicates that the unary operator is an incrementation */

N_dec :
=======
/* this node indicates that the unary operator is a decrementation */

