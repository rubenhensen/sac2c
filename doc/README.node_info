/*
 * $Log$
 * Revision 1.18  1995/06/06 08:01:31  cg
 * status in types added.
 *
# Revision 1.17  1995/05/31  15:50:33  hw
# changed information for node N_foldfun (node[1])
#
# Revision 1.16  1995/05/30  12:03:42  cg
# Storage of constants and global objects in the syntax tree described.
#
# Revision 1.15  1995/05/30  10:10:04  hw
# informations updated
#
# Revision 1.14  1995/03/14  10:51:52  asi
# added node informations created while optimization
#
# Revision 1.13  1995/03/02  09:10:10  hw
# changed information about N_generator
#
# Revision 1.12  1995/02/14  12:47:18  sbs
# N_foldfun, N_foldprf inserted
#
# Revision 1.11  1995/01/16  11:11:21  hw
# added information about N_ap
# changed information about struct types
#
# Revision 1.10  1994/12/31  15:14:17  sbs
# N_explist updated
#
# Revision 1.9  1994/12/21  13:22:34  hw
# removed N_addon etc
# changed information about N_typedef
#
# Revision 1.8  1994/12/20  14:46:25  hw
# added information about references to the variable declaration
#
# Revision 1.7  1994/12/20  13:12:29  sbs
# some typos corrected
#
# Revision 1.6  1994/12/16  14:50:49  sbs
# N_moduldec, N_classdec & N_explist inserted
#
# Revision 1.5  1994/12/16  09:35:53  sbs
# N_modul, N_implist, N_typedef & N_cast inserted
#
# Revision 1.4  1994/12/08  14:13:13  hw
# changed information about N_fundef
#
# Revision 1.3  1994/12/06  11:17:01  hw
# changed information about N_fundef and N_block
#
# Revision 1.2  1994/11/21  13:43:28  hw
# Log-header modified
#
 *
 */

This file contains information about the sac2c-syntaxtree-nodes.


type structure of syntax-tree:

typedef struct NODE
{
   nodetype  nodetype;
   union
   {
      ids        *ids;      /* liste of identificators   */
      id         *id;       /* identifikator              */
      types      *types;    /* typinformation             */
      int        cint;      /* integer-value              */
      float      cfloat;    /* float-value                */
      fun_name   fun_name;  /* used in N_ap nodes         */
      struct
      {
         int tag;           /* tag for return type */
         int tc;            /* type class */
      }          prf_dec;   /* used for declaration of primitive functions 
                             * this declarations are used to look for argument 
                             * and result type of primitive functions
                             */
   }            info;      /* used for special information */
   int          refcnt;    /* is used as reference count information */
   int          bblock;    /* number of basic block assign node belongs to */
   int          flag;      /* the flag is used for node-status */
                           /* (loop invariant/not loop invariant , ...) */

   int          varno;    /* number of variables in function */
   long         *mask[MAX_MASK]; /* informations about variables belonging to this node */
                          /* mask[0] contains defined variables                         */
			  /* mask[1] contains used variables                            */
			  /* e.g. mask[0][10] = 10 means :                              */
			  /*      variable number 10 is defined 10 times in this node   */
   int          nnode;    /* number of used children nodes */
   int          lineno;   /* commands linenumber */
   struct NODE *node[6];  /* children nodes */
} node;                   
          
typedef struct TYPES{
   simpletype   simpletype;
   char         *name;         /* only used for T_user !! */
   char         *name_mod;     /* name of modul belonging to 'name' */
   int          dim;           /* if (dim == 0) => simpletype */
   shpseg       *shpseg;
   struct TYPES *next;         /* only needed for fun-results */
   id           *id;           /* Bezeichner  */
   char         *id_mod;       /* name of modul belonging to 'id' */
   statustype   status;        /* status of this type, used to identify */
                               /* hidden, unique or artificially        */
                               /* inserted types                        */
} types;
 
typedef struct IDS{
   id            *id;
   int           refcnt;     /* refcount information
                              * it is set while refcounting
                              * and is used while compilation
                              * /
   struct NODE   *node;    /* ptr. to decleration after typechecking */
   struct NCHAIN *nchain;  /* ptr. to definition(s) resp. usage(s) */
   struct IDS    *next;
} ids;

typedef struct FUN_NAME{
   char    *id;         /* name of function */
   char    *id_mod;     /* name of modul belonging to 'id' */
}fun_name;


===============================================================================


Description of the different node types:


N_moduldec, N_classdec:
=======================
node[0]    : export-list (N_explist)
node[1]    : import_list (N_implist) if present...
info.id    : name of the modul/class

N_explist:
==========
node[0]    : implicit types (N_typedef) if present...
node[1]    : explicit types (N_typedef) if present...
node[2]    : function declarations (N_fundef with NULL-body) if present...
node[3]    : constant declarations (N_constdef with optional value) if present...
              !! not yet implemented !!
node[4]    : object declarations (N_objdef with NULL-initialization) if present...
              !! not yet implemented !!

N_modul:
========
nnode = 0 !!!!
node[0]    : import-list (N_implist) if present...
node[1]    : typedefs (N_typedef) if present...
node[2]    : fundefs (N_fundef) if present...
node[3]    : constdefs (N_constdef) if present...
              !! not yet implemented !!
node[4]    : objdefs (N_objdef) if present...
              !! not yet implemented !!
node[5]    : N_isclass node if module is a class implementation
              !! not yet implemented !!
info.id    : Modul name/ NULL if simple program.

N_implist:
==========
nnode=0/1 !!!
node[0]    : subsequent imports if present...
node[1]    : casted to (ids *) !!! list of implicit type names!
node[2]    : casted to (ids *) !!! list of explicit type names!
node[3]    : casted to (ids *) !!! list of function names!
node[4]    : casted to (ids *) !!! list of constant names!
              !! not yet implemented !!
node[5]    : casted to (ids *) !!! list of object names!
              !! not yet implemented !!
info.id    : name of import-file.

- If all identifier lists are empty then it's an "import all" -

N_typedef:
==========
node[0]    : subsequent typedefs if present...
info.types : containes type and new typename (info.type->id) in one types-structure.

N_constdef:
==========
              !! not yet implemented !!
nnode = 1/2 !!!
node[0]    : value of constant (expr)
node[1]    : subsequent constdefs if present...
node[2]    : N_imported node if constant is imported from another module/class
info.types : containes type and name of constant.

N_objdef:
==========
              !! not yet implemented !!
node[0]    : generator function call (N_ap)
node[1]    : subsequent objdefs if present...
info.types : containes type and name of global object.

N_fundef:
=========
node[0]	   : functionbody (N_block)
node[1]    : next function (N_fundef), if there is one
node[2]    : arguments of function (N_arg), if there are some

info.types : first types structure contains the functions name (info.types->id,
             info.types->id_mod) and the first part of the functions type. 
             If a function has more than one return value, the types of these return 
	     values are stored in following types structure.

-added after type check:
node[3]    : pointer to corresponding N_return
node[4]    : casted to (ids *) !!! list of global object identifiers
             used in this function 
              !! not yet implemented !!

-Created before optimizing:
varno      : lenght of the masks in this function
mask[0]    : contains number of definitions for all variables in this function
mask[1]    : contains number of usages for all variables in this function

N_arg:
=====
node[0]    : next argument (N_arg), if any
info.types : contains name and type of the argument. For infomation
	     about the structure of `types` look at description of
	     N_fundef.
-Created before optimizing:
varno      : number assignd to this argument

N_block:
========
node[0]    : first node of the block (N_assign or N_empty)
node[1]    : variable declaration, if there are any
-Created before optimizing:
see N_cond, N_do, N_while and N_with

N_vardec:
=========
node[0]    : next declaration (N_vardec), if any
info.types : contains name and type of the declaration. For infomation
	     about the structure of `types` look at description of
	     N_fundef.
-Created before optimizing:
varno      : number assignd to this variable

N_assign:
=========
node[0]    : instruction (N_let, N_cond, N_while, N_do, N_return, ...)
node[1]    : next assign node(N_assign), if any
-Created before optimizing:
mask[0]    : contains number of definitions for all variables in the instruction
mask[1]    : contains number of usages for all variables in the instruction

N_let:
======
node[0]    : expression 
info.ids   : names of variables to assign to.
	     The structure of ids is:

N_cast:
=======
node[0]    : expression
info.type  : new type

N_return:
=========
node[0]    : returnvalues (N_exprs)
/* N_return is used in two differnt ways. First it is the returnvalue
   of function and secondly it defines how an array is modified in a
   with-expression. */

N_cond:
=======
node[0]    : condition (N_expr)
node[1]    : then part
node[2]    : else part
node[3]    : (N_info) list of N_id nodes with refcount information (only
             arrays are considered) will be set while refcounting and is
             used while compilation.
             The child nodes of N_info:
               node[0]: variables of then-part whose refcount has to be decremented
               node[1]: variables of else-part whose refcount has to be decremented
                        (number of decremantation is stored in info.refcnt of N_id)
             !! nnode is still 3 !!
-Created before optimizing:
mask[1]    : contains number of usages for all variables in conditon 
node[1]->mask[0] : contains number of definitions for all variables in then part
node[1]->mask[1] : contains number of usages for all variables in then part
node[2]->mask[0] : contains number of definitions for all variables in else part
node[2]->mask[1] : contains number of usages for all variables in else part


N_do, N_while:
==============
node[0]    : termination conditon of the loop
node[1]    : body of the loop
node[2]    : (N_info) list of N_id nodes with refcount information (only 
             arrays are considered) will be set while refcounting and is
             used while compilation. 
             The child nodes of N_info: 
              node[0]: variables that are used before they will be defined
                       in the body of the loop
              node[1]: variables that are defined in the body of the loop
                       and are used in the rest of the program
             !!! nnode will be still 2 !!!
-Created before optimizing:
mask[1]    : contains number of usages for all variables in termination conditon 
node[1]->mask[0] : contains number of definitions for all variables in loop body
node[1]->mask[1] : contains number of usages for all variables in loop body
/* for-loops are transformed into while-loops while parsing */

N_ap:
=====
node[0]    : arguments of function application (N_exprs)
node[1]    : pointer to the belonging functiondeclaration
             this pointer will be set while typechecking
             !!! nnode will not be increased !!!
info_node  : name of function to apply ( info.fun_name.id, 
                                         info.fun_name.id_mod)

/* the application node is only used for userdefined functions */

N_with:
=======
node[0]    : generator (N_generator)
node[1]    : body of with-statement
node[2]    : (N_info node[0]) contains list of N_id nodes (node[0]: next N_id) with 
             refcount information (this list is build while refcounting and is used while
             compilation) 
-Created before optimizing:
node[0]->mask[0] : contains number of definitions for all variables in generator
node[0]->mask[1] : contains number of usages for all variables in generator
node[1]->mask[1] : contains number of usages for all variables in genarray or modarray
mask[0] : contains number of definitions for all variables in with body
mask[1] : contains number of usages for all variables in with body

N_id:
=====
info.ids->id     : name of identificator
info.ids->node   : pointer to the belonging variable declaration.
                   it will be set while typechecking. 
info.ids->refcnt : set while refcounting and is used while compilation
                   -1    => does not belong to an array
                    n >0 => there are still more than n referenzes to belonging array

N_float:
========
info.cfloat : float value

N_Num:
======
info.cint   : interger value

N_bool:
=======
info.cint   : 0 => false
              1 => true

N_prf:
======
node[0]           : arguments of primitive function (N_exprs)
info.prf          : tag for kind of primitive function (F_add, F_sub,
	            F_mul, F_div, F_take, F_drop, F_psi, F_shape,
		    F_reshape, F_cat, F_dim, F_rotate, F_and, F_or, 
		    F_not, F_le, F_lt, F_eq, F_ge, F_gt, F_neq, ...)

N_generator:
============
node[0]        : expression for left border of arraymanipulation
node[1]        : expression for right border of arrymanipulation
info.ids->id   : name of bound variable for arraymanipulation

N_genarray, N_modarray:
=======================
node[0]     : array that will be manupulated
node[1]     : body

N_foldprf:
==========
info.prf    : fold-function( F_add, F_sub, F_mul, F_div, F_and, F_or, F_eq, F_neq, ...)
node[0]     : body

N_foldfun:
==========
info.fun_name.id     : name of user defined fold-function
info.fun_name.id_mod : name of modul where fold_function is defined
node[0]              : body
node[1]              : expression to compute neutral element of fold_function
node[2]              : pointer to declaration of fold-function ( it is set while
                        typechecking.
                        !!! nnode will not be increased (it is still 2) !!! )

N_exprs:
========
node[0]     : expression
node[1]     : next expression (N_exprs), if any

N_array:
========
node[0]     : elements of the array (N_exprs)

N_empty:
========
/* this node  indicates that a block is empty */

N_post:
======
node[0]     : indicates whether it is a postincrement or postdecrement
info.id     : name of the identificator to be modified
node[1]     : will be set to belonging varaiable declaration while typechecking
              !!! nnode is still 1 !!!

N_pre:
======
node[0]     : indicates wheter it is a preincrement or predecrement
info.id     : name of modified identifikator
node[1]     : will be set to belonging varaiable declaration while typechecking
              !!! nnode is still 1 !!!

N_inc:
======
/* this node indicates that the unary operator is an incrementation */

N_dec :
=======
/* this node indicates that the unary operator is a decrementation */

N_imported:
===========
/* This node indicates that a constant is imported from another module/class. 
   It is necessary because the value of the constant can be made public 
   in a module/class declaration.
*/

N_class:
========
/* this node indicates that a module/class implementation is in fact a class
   implementation.
*/
