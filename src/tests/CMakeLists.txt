# FIXME (hans)
# we need to be super carefully to have actually build the compiler/libs *before*
# we call ctest/`make test` as seemingly there is no implicit dependency between
# the two stages. It is completely possible for ctest to be called after configure
# and exit cleanly (missing tests do not cause an error!).
# Issue is dealt with and reported here: https://stackoverflow.com/q/733475 and
# https://gitlab.kitware.com/cmake/cmake/issues/8774.

# find GTest on system
FIND_PACKAGE (GTest REQUIRED)

# get ctest functions for gtest infrastructure
INCLUDE (GoogleTest)

#  Add some boilerplate GTest definitions.
INCLUDE_DIRECTORIES (${GTEST_INCLUDE_DIR})

# As we are going to interface libsac2c.so, we want to define all the
# include paths, to avoid writing function declarations manually.
FILE (GLOB_RECURSE headers ${PROJECT_SOURCE_DIR}/src/libsac2c/*.h)
SET (dirlist "")
FOREACH (hpath ${headers})
   GET_FILENAME_COMPONENT (hdir ${hpath} PATH)
   LIST (APPEND dirlist ${hdir})
ENDFOREACH ()
LIST (REMOVE_DUPLICATES dirlist)

# All the src/libsac2c subdirs that contain *.h
INCLUDE_DIRECTORIES (${dirlist})

# All the generated files
INCLUDE_DIRECTORIES (${PROJECT_BINARY_DIR}/src/libsac2c)

# Generated global files like config, fun-attrs, etc.
INCLUDE_DIRECTORIES (${PROJECT_BINARY_DIR}/src/include)

# All paths as found via sac2c/config.cmake for sac2crc
INCLUDE_DIRECTORIES (${SAC2CRC_INCS})

# Generated dummy runtime library, includes dummy functions to satisfy linker
ADD_LIBRARY (runtimedummy STATIC "runtime_dummy.c")

# Some general variables
SET (SAC2C_TESTS_PATH "${PROJECT_SOURCE_DIR}/src/tests")

MACRO (ADD_FUNC_TEST BIN_NAME SRC_NAME)
    # Compile the test
    ADD_EXECUTABLE (${BIN_NAME} ${SRC_NAME})
    ADD_DEPENDENCIES (${BIN_NAME} sac2cShared)
    # Ensure that executable is built before run test
    ADD_DEPENDENCIES (check ${BIN_NAME})
    # Link against Gtest
    TARGET_LINK_LIBRARIES (${BIN_NAME} GTest::GTest GTest::Main sac2cShared)
    # Make sure we compile with at least C++11
    SET_TARGET_PROPERTIES (${BIN_NAME}
        PROPERTIES
            CXX_STANDARD 11
            CXX_STANDARD_REQUIRED YES)
    # Make it a part of the global testsuite so that it is executed via ctests.
    GTEST_DISCOVER_TESTS (${BIN_NAME})
ENDMACRO ()

MACRO (ADD_RUNTIME_FUNC_TEST BIN_NAME SRC_NAME LIB_TARGET EXTRA_LINKS)
    # Compile the test
    ADD_EXECUTABLE (${BIN_NAME} ${SRC_NAME})
    ADD_DEPENDENCIES (${BIN_NAME} libsac-${LIB_TARGET})
    # Ensure that executable is built before run test
    ADD_DEPENDENCIES (check ${BIN_NAME})
    # we get properties from the utility target that we pass to the binary properties
    GET_TARGET_PROPERTY (__libpath libsac-${LIB_TARGET} OUTPUT_NAME)
    GET_TARGET_PROPERTY (__rpath libsac-${LIB_TARGET} BUILD_RPATH)
    # pass information to the binary (additionally we also pass RPATH information explicitly,
    # this is needed in order to run the test binary
    SET_TARGET_PROPERTIES (${BIN_NAME}
        PROPERTIES
        COMPILE_DEFINITIONS "CMAKE_TESTS_PATH=\"${SAC2C_TESTS_PATH}\""
        BUILD_RPATH "${__rpath}")
    # for EXTRA_LINKS we find the appropriate library
    SET (__extra_links "")
    FOREACH (_lib ${EXTRA_LINKS})
        FIND_LIBRARY (__${_lib}
            NAMES ${_lib}
            PATHS ${CUDAToolkit_LIBRARY_DIR}
            NO_PACKAGE_ROOT_PATH)
        IF (__${_lib})
            LIST (APPEND __extra_links "${__${_lib}}")
        ELSE ()
            MESSAGE (FATAL_ERROR "Cannot find '${_lib}' library for ${BIN_NAME}!")
        ENDIF ()
    ENDFOREACH ()
    # Link against Gtest and SaC runtime library (we need to link manually as the ExternalProject does not encode this information)
    # we also link a dummy library to define functions which are expected (normally generated by sac2c)
    TARGET_LINK_LIBRARIES (${BIN_NAME} GTest::GTest GTest::Main "${__libpath}" runtimedummy ${__extra_links})
    # Make sure we compile with at least C++11
    SET_TARGET_PROPERTIES (${BIN_NAME}
        PROPERTIES
            CXX_STANDARD 11
            CXX_STANDARD_REQUIRED YES)
    # Make it a part of the global testsuite so that it is executed via ctests.
    GTEST_DISCOVER_TESTS (${BIN_NAME})
ENDMACRO ()

# libsac2c tests
ADD_FUNC_TEST (test-string test-str.cpp)
ADD_FUNC_TEST (test-string-vec test-str-vec.cpp)
ADD_FUNC_TEST (test-assoc-law test-assoc-law.cpp)
ADD_FUNC_TEST (test-icm-compilation test-icm-compilation.cpp)
ADD_FUNC_TEST (test-macros test-macros.cpp)
ADD_FUNC_TEST (test-traverse-optcounter test-traverse-optcounter.cpp)
ADD_FUNC_TEST (test-new-types test-new-types.cpp)
ADD_FUNC_TEST (test-lut test-lut.cpp)
ADD_FUNC_TEST (test-dataflowmask test-dataflowmask.cpp)
ADD_FUNC_TEST (test-jupyter-interface test-jupyter-interface.cpp)
ADD_FUNC_TEST (test-str-buffer test-str-buffer.cpp)
ADD_FUNC_TEST (test-compile-time-formatting test-compile-time-formatting.cpp)

# libsac + runtime tests
# XXX (hans) we can only create one test suite, *not* per-target, due to name-clashes
IF (${ENABLE_HWLOC})
    ADD_RUNTIME_FUNC_TEST (test-hwloc-runtime test-hwloc-runtime.cpp "seq" "hwloc")
ENDIF ()

# CUDA related tests
ADD_FUNC_TEST (test-cuda-utils test-cuda-utils.cpp)

IF (${ENABLE_CUDA}) # requires CUDA-targets
    ADD_RUNTIME_FUNC_TEST (test-cuda-async-locks test-cuda-async-locks.cpp "cuda" "cudart")
ENDIF ()
