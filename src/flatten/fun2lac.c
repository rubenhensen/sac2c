/*
 *
 * $Log$
 * Revision 1.1  2000/02/17 16:15:25  cg
 * Initial revision
 *
 *
 *
 */

/*****************************************************************************
 *
 * file:   fun2lac.c
 *
 * prefix: FUN2LAC
 *
 * description:
 *
 *   This compiler module implements the reconversion of conditionals and
 *   loops from their true functional representation generated by routines
 *   found in lac2fun.c into an explicit representation suitable for code
 *   generation.
 *
 *****************************************************************************/

#include "tree.h"
#include "traverse.h"
#include "free.h"
#include "dbug.h"

#include "adjust_ids.h"

/******************************************************************************
 *
 * function:
 *
 *
 * description:
 *
 *
 *
 *
 *
 ******************************************************************************/

/******************************************************************************
 *
 * function:
 *   node *InlineWhileFun(node *fundef)
 *
 * description:
 *
 *   This function transforms the given while-loop function into an assignment
 *   that is suitable to replace the corresponding function application.
 *
 *
 ******************************************************************************/

static node *
InlineWhileFun (node *fundef)
{
    DBUG_ENTER ("InlineWhileFun");

    DBUG_RETURN (fundef);
}

/******************************************************************************
 *
 * function:
 *   node *InlineDoFun(node *fundef)
 *
 * description:
 *
 *   This function transforms the given do-loop function into an assignment
 *   that is suitable to replace the corresponding function application.
 *
 *
 ******************************************************************************/

static node *
InlineDoFun (node *fundef)
{
    DBUG_ENTER ("InlineDoFun");

    DBUG_RETURN (fundef);
}

/******************************************************************************
 *
 * function:
 *   node *InlineCondFun(node *fundef)
 *
 * description:
 *
 *   This function transforms the given conditional function into an assignment
 *   that is suitable to replace the corresponding function application.
 *
 *
 ******************************************************************************/

static node *
InlineCondFun (node *fundef)
{
    DBUG_ENTER ("InlineCondFun");

    DBUG_RETURN (fundef);
}

/******************************************************************************
 *
 * function:
 *   node *FUN2LACap( node *arg_node, node *arg_info)
 *
 * description:
 *
 *   If the function applied is a cond or loop function, then the identifiers
 *   in the corresponding function definition are adjusted in order to allow
 *   naive inlining during the bottom-up traversal.
 *
 ******************************************************************************/

node *
FUN2LACap (node *arg_node, node *arg_info)
{
    DBUG_ENTER ("FUN2LACap");

    if ((FUNDEF_STATUS (AP_FUNDEF (arg_node)) == ST_condfun)
        && (FUNDEF_STATUS (AP_FUNDEF (arg_node)) == ST_whilefun)
        && (FUNDEF_STATUS (AP_FUNDEF (arg_node)) == ST_dofun)) {

        AdjustIdentifiers (AP_FUNDEF (arg_node), INFO_FUN2LAC_LET (arg_info));
        INFO_FUN2LAC_FUNDEF (arg_info) = AP_FUNDEF (arg_node);
    }

    DBUG_RETURN (arg_node);
}

/******************************************************************************
 *
 * function:
 *   node *FUN2LAClet( node *arg_node, node *arg_info)
 *
 * description:
 *
 *   The main purpose of this function is to store the let variables in the
 *   arg_info node in order to have them available if the right hand side
 *   contains an application of a cond or loop function whose identifiers
 *   have to be adjusted to the calling context.
 *
 ******************************************************************************/

node *
FUN2LAClet (node *arg_node, node *arg_info)
{
    DBUG_ENTER ("FUN2LAClet");

    INFO_FUN2LAC_LET (arg_info) = arg_node;

    LET_EXPR (arg_node) = Trav (LET_EXPR (arg_node), arg_info);

    INFO_FUN2LAC_LET (arg_info) = NULL;

    DBUG_RETURN (arg_node);
}

/******************************************************************************
 *
 * function:
 *   node *FUN2LACassign( node *arg_node, node *arg_info)
 *
 * description:
 *
 *   The instruction behind the assignment is traversed. Iff it represents the
 *   application of a cond or loop function, this application is replaced by
 *   the inlined code of the cond or loop function, respectively.
 *   Prior to this, the identifiers of the function to be inlined have already
 *   been adjusted in a way that allows rather naive inlining.
 *
 ******************************************************************************/

node *
FUN2LACassign (node *arg_node, node *arg_info)
{
    DBUG_ENTER ("FUN2LACassign");

    arg_node = Trav (ASSIGN_INSTR (arg_node), arg_info);

    if (INFO_FUN2LAC_FUNDEF (arg_info) != NULL) {
        ASSIGN_INSTR (arg_node) = FreeTree (ASSIGN_INSTR (arg_node));

        switch (FUNDEF_STATUS (INFO_FUN2LAC_FUNDEF (arg_info))) {
        case ST_condfun: {
            ASSIGN_INSTR (arg_node) = InlineCondFun (INFO_FUN2LAC_FUNDEF (arg_info));
            break;
        }
        case ST_whilefun: {
            ASSIGN_INSTR (arg_node) = InlineWhileFun (INFO_FUN2LAC_FUNDEF (arg_info));
            break;
        }
        case ST_dofun: {
            ASSIGN_INSTR (arg_node) = InlineDoFun (INFO_FUN2LAC_FUNDEF (arg_info));
            break;
        }
        default: {
            DBUG_ASSERT (0, "Illegal status of abstracted cond or loop fun");
        }
        }

        INFO_FUN2LAC_FUNDEF (arg_info) = NULL;

        ASSIGN_INSTR (arg_node) = Trav (ASSIGN_INSTR (arg_node), arg_info);
    }

    if (ASSIGN_NEXT (arg_node) != NULL) {
        ASSIGN_NEXT (arg_node) = Trav (ASSIGN_NEXT (arg_node), arg_info);
    }

    DBUG_RETURN (arg_node);
}

/******************************************************************************
 *
 * function:
 *   node *FUN2LACblock( node *arg_node, node *arg_info)
 *
 * description:
 *
 *   This function initiates the traversal of the instruction chain
 *   of an assignment block. The vardecs are not traversed.
 *
 *
 ******************************************************************************/

node *
FUN2LACblock (node *arg_node, node *arg_info)
{
    DBUG_ENTER ("FUN2LACblock");

    if (BLOCK_INSTR (arg_node) != NULL) {
        BLOCK_INSTR (arg_node) = Trav (BLOCK_INSTR (arg_node), arg_info);
    }

    DBUG_RETURN (arg_node);
}

/******************************************************************************
 *
 * function:
 *   node *FUN2LACfundef( node *arg_node, node *arg_info)
 *
 * description:
 *
 *   This function traverses the function body of any function that does NOT
 *   represent an abstracted conditional or loop.
 *
 ******************************************************************************/

node *
FUN2LACfundef (node *arg_node, node *arg_info)
{
    DBUG_ENTER ("FUN2LACfundef");

    if ((FUNDEF_STATUS (arg_node) != ST_condfun)
        && (FUNDEF_STATUS (arg_node) != ST_whilefun)
        && (FUNDEF_STATUS (arg_node) != ST_dofun) && (FUNDEF_BODY (arg_node) != NULL)) {
        INFO_FUN2LAC_FUNBLOCK (arg_info) = FUNDEF_BODY (arg_node);
        FUNDEF_BODY (arg_node) = Trav (FUNDEF_BODY (arg_node), arg_info);
        INFO_FUN2LAC_FUNBLOCK (arg_info) = NULL;
    }

    if (FUNDEF_NEXT (arg_node) != NULL) {
        FUNDEF_NEXT (arg_node) = Trav (FUNDEF_NEXT (arg_node), arg_info);
    }

    if ((FUNDEF_STATUS (arg_node) != ST_condfun)
        && (FUNDEF_STATUS (arg_node) != ST_whilefun)
        && (FUNDEF_STATUS (arg_node) != ST_dofun)) {
        arg_node = FreeNode (arg_node);
    }

    DBUG_RETURN (arg_node);
}

/******************************************************************************
 *
 * function:
 *   node *FUN2LACmodul( node *arg_node, node *arg_info)
 *
 * description:
 *
 *   This function traverses all function definitions under an N_modul
 *   node.
 *
 *
 ******************************************************************************/

node *
FUN2LACmodul (node *arg_node, node *arg_info)
{
    DBUG_ENTER ("FUN2LACmodul");

    if (MODUL_FUNS (arg_node) != NULL) {
        MODUL_FUNS (arg_node) = Trav (MODUL_FUNS (arg_node), arg_info);
    }

    DBUG_RETURN (arg_node);
}

/******************************************************************************
 *
 * function:
 *   node *Fun2Lac( node *syntax_tree)
 *
 * description:
 *
 *   This function initiates the tree traversal process for reconverting
 *   functional representations of loops and conditionals into their
 *   explicit representations.
 *
 ******************************************************************************/

node *
Fun2Lac (node *syntax_tree)
{
    node *info_node;

    DBUG_ENTER ("Fun2Lac");

    act_tab = fun2lac_tab;
    info_node = MakeInfo ();

    syntax_tree = Trav (syntax_tree, info_node);

    FreeNode (info_node);

    DBUG_RETURN (syntax_tree);
}
