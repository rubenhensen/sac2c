/*
 * File : globals.mac
 *
 * This file should contain the definitions of all global variables
 * used in the implementation of the sac2c compiler which are not restricted
 * to the use within one particular file.
 *
 * However, the usage of global variables should be as limited as possible
 * since a functional programming style is preferred in the SAC project. The
 * major application of global variables therefore is the storage of such
 * global information as determined by the command line arguments of a sac2c
 * compiler call.
 *
 */

#include "config.h"

/* The source file of sac program can come from various files due to
   recognition of #line directives.  Usually massively used by preprocessor.
   Every token keeps a pointer to the file name.  In order to share file names
   we keep a table of file names we've seen so far.  The table is just a dynamic
   array with size attached.

   Currently such a simple format suffises, as the lexer keeps file names in the
   hash table, and on exit it dumps the list to this table.  We do not search over
   this table and we do not support multiple file compilation, which means that one
   global table would work.  */
GLOBAL (size_t, file_table_size, 0, xfree_dummy, )
GLOBAL (char **, file_table, NULL, xfree_char_ptr_ptr, , global.file_table_size)

/*
 * Memory allocation
 */

GLOBAL (unsigned int, current_allocated_mem, 0, xfree_dummy, )
GLOBAL (unsigned int, max_allocated_mem, 0, xfree_dummy, )

/*
 * Tool type
 */

GLOBAL (tool_t, tool, TOOL_sac2c, xfree_dummy, )
GLOBAL (char *, toolname, NULL, xfree_dummy, )

/*
 * Syntax tree root
 */

GLOBAL (node *, syntax_tree, NULL, xfree_dummy, )

/*
 * Parsing
 */

GLOBAL (int, start_token, 0, xfree_dummy, )

/*
 *  Version control
 */

GLOBAL (const char *, version_id, "v1.00-beta (Haggis And Apple)", xfree_dummy, )
/*
 * version string
 */

GLOBAL (const char *, target_platform, OS "_" ARCH, xfree_dummy, )
/*
 * operating system platform string
 */

/*
 *  Standard prelude name
 */

GLOBAL (const char *, preludename, SAC_PRELUDE_NAME, xfree_dummy, )

/*
 *  Flag to enable/disable loading of prelude
 */
GLOBAL (bool, loadprelude, TRUE, xfree_dummy, )

/*
 *  File handling
 */

GLOBAL (FILE *, outfile, NULL, xfree_dummy, )
GLOBAL (bool, install, FALSE, xfree_dummy, )

/*
 * stream to write result to
 */

GLOBAL (char *, sacfilename, NULL, xfree_char_ptr, )
/*
 * name of file to be compiled
 */

GLOBAL (char *, puresacfilename, "stdin", xfree_dummy, )
/*
 * sacfilename without path specification
 */

GLOBAL (char *, outfilename, NULL, xfree_char_ptr, )
/*
 * name of executable
 */

GLOBAL (char *, modulename, NULL, xfree_char_ptr, )
/*
 * name of module/class which is compiled
 */

GLOBAL (namespace_t *, modulenamespace, NULL, xfree_dummy, )
/*
 * namespace of module/class which is compiled
 */

GLOBAL (char *, cfilename, NULL, xfree_char_ptr, )
/*
 * name of C source code file
 */

GLOBAL (char *, targetdir, NULL, xfree_dummy, )
/*
 * name of C source code file
 */

GLOBAL (file_type, filetype, FT_prog, xfree_dummy, )
/*
 * kind of file: FT_prog, FT_modimp or FT_classimp
 */

GLOBAL (char *, tmp_dirname, NULL, xfree_char_ptr, )
/*
 * directory for storing temporary files
 */

GLOBAL (char *, system_cleanup, NULL, xfree_char_ptr, )
/*
 * directory for storing temporary files
 */

/* FIXME: This one also needs special attention; dummy for the time being.  */
GLOBAL (stringset_t *, exported_modules, NULL, xfree_dummy, )
/*
 * list of modules that will be exported by sac4c
 */

GLOBAL (bool, printldflags, FALSE, xfree_dummy, )
/*
 * enables printing of ldflags in sac4c
 */

GLOBAL (bool, printccflags, FALSE, xfree_dummy, )
/*
 * enables printing of ccflags in sac4c
 */

GLOBAL (char *, lib_dirname, NULL, xfree_char_ptr, )
/*
 * directory for wrapper file generated by sac4c
 */

GLOBAL (char *, inc_dirname, NULL, xfree_char_ptr, )
/*
 * directory for include file generated by sac4c
 */

GLOBAL (int, sac4c_udt_offset, 20, xfree_dummy, )
/*
 * sac4c udt offset, needs to be greater than max( usertype)
 */

GLOBAL (char *, ccflags, (char *)MEMmalloc (NAME_MAX), xfree_char_ptr, )
/*
 * Command line arguments
 */

GLOBAL (int, argc, 0, xfree_dummy, )
GLOBAL (char **, argv, NULL, xfree_dummy, )

/*
 * Target architecture description
 */

GLOBAL (char *, target_name, "default", xfree_dummy, )
/*
 * name of target architecture selected by -target option
 */

/* Default component name of the typedef node.  */
GLOBAL (const char *, default_component_name, "element", xfree_dummy, )

/*
 * Backend option
 */
GLOBAL (backend_t, backend, BE_c99, xfree_dummy, )

/*
 * Dynamic-sized arrays option
 */

/*
 * Dynamic shapes are disabled by default
 */
GLOBAL (bool, dynamic_shapes, FALSE, xfree_dummy, )

/*
 * Struct support options
 */
GLOBAL (bool, enable_structs, FALSE, xfree_dummy, )

/* -- Runtime Specialization -- */

/*
 * Runtime specialization flag for generating runtime optimization
 * functionality.
 */

GLOBAL (bool, rtspec, FALSE, xfree_dummy, )
/*
 * Runtime specialization is disabled by default.
 */

/*
 * Type info provided as a commandline argument for runtime optimization.
 */

GLOBAL (char *, rt_type_info, "", xfree_dummy, )
/*
 * Default it has no value.
 */

/*
 * Shape info provided as a commandline argument for runtime optimization.
 */

GLOBAL (char *, rt_shape_info, "", xfree_dummy, )
/*
 * Default it has no value
 */

/*
 * The name of the module from which to import the previous function instances.
 */

GLOBAL (char *, rt_old_module, "", xfree_dummy, )
/*
 * Default it has no value.
 */

/*
 * The name of the new module that is to be created at runtime.
 */

GLOBAL (char *, rt_new_module, "", xfree_dummy, )
/*
 * Default it has no value.
 */

/*
 * The name of the function being optimized.
 */
GLOBAL (char *, rt_fun_name, "", xfree_dummy, )
/*
 * Default it has no value.
 */

/*
 * The name the new wrapper should get.
 */
GLOBAL (char *, rt_new_name, "", xfree_dummy, )
/*
 * Default it has no value.
 */

/*
 * The functions arguments as they should be after optimization.
 *
 * The last element (xfree_dummy) should not be changed to 'xfree_node' as
 * 'rt_args' is not a proper syntax tree. Setting it to xfree_node leads to a
 * segfault *after* compilation has finished.
 */
GLOBAL (node *, rt_args, NULL, xfree_dummy, )
/*
 * Default it is NULL.
 */

/*
 * The number of arguments in the rt_args chain..
 */
GLOBAL (int, rt_num_args, 0, xfree_dummy, )
/*
 * Default it is zero.
 */

/*
 * Runtime specialization flag for recompiling at runtime.
 */

GLOBAL (bool, runtime, FALSE, xfree_dummy, )
/*
 * Runtime specialization is disabled by default.
 */

/* -- Runtime Specialization -- */

/*
 * Extended LaC fun option
 */

GLOBAL (bool, elf, FALSE, xfree_dummy, )
/*
 * Extended LaC fun option disabled per default
 */

/*
 * SIMD options
 */

GLOBAL (bool, simd, FALSE, xfree_dummy, )
/*
 * SIMD code generation disabled per default
 */

/*
 * Multi-thread options
 */

GLOBAL (mtmode_t, mtmode, MT_none, xfree_dummy, )
/*
 * Multi-thread mode set according to -mt and -mtmode compiler flags
 */

GLOBAL (char *, ompschedule, "static", xfree_dummy, )
/*
 * OMP schedule technique
 */

GLOBAL (int, ompbenchmark, 10000, xfree_dummy, )
/*
 * OMP benchmark in if statement
 */

GLOBAL (int, ompnestlevel, 1, xfree_dummy, )
/*
 * OMP nesting level
 */

GLOBAL (int, ompchunksize, 1, xfree_dummy, )
/*
 * OMP chunk size
 */

GLOBAL (int, num_threads, 1, xfree_dummy, )
/*
 * Number of threads to be generated.
 *  0  : dynamic number of threads, specified as first command line argument
 *       on application program startup.
 *  1  : sequential program
 *  >1 : exact number of threads to be started
 */

GLOBAL (bool, no_fold_parallel, FALSE, xfree_dummy, )
/*
 * Switch whether or not to parallelize fold with-loops.
 */

GLOBAL (int, max_threads, 32, xfree_dummy, )
/*
 * Maximum number of threads if exact number is determined dynamically.
 */

GLOBAL (int, min_parallel_size, 250, xfree_dummy, )
/*
 * Minimum generator size for parallel execution of with-loops.
 */

GLOBAL (int, max_replication_size, 250, xfree_dummy, )
/*
 * Maximum size of array for replication, otherwise the calculation will be
 * executed single-threaded.
 */

GLOBAL (int, max_schedulers, 0, xfree_dummy, )
/*
 * This variable is used to collect the maximum number of schedulers in a
 * single SPMD block/function in order to generate an appropriate number
 * of local data structure sets for the scheduler implementations.
 */

GLOBAL (int, min_parallel_size_per_thread, 8, xfree_dummy, )
/*
 * Minimum generator size per thread for parallel execution of with-loops
 * e.g., max_threads = 4, min_parallel_size_per_thread=8
 *       => generator size must be >= 32 to be executed parallel
 */

GLOBAL (bool, enforce_float, FALSE, xfree_dummy, )

GLOBAL (bool, fp, FALSE, xfree_dummy, )
/*
 * Use functional parallelism
 */

GLOBAL (bool, fpnoopt, FALSE, xfree_dummy, )
/*
 * Do FP optimizations
 */

/*
 * Preprocessor options
 *
 *  refer to -D, -cppI command line options:
 */

GLOBAL (char *, cpp_options, NULL, xfree_char_ptr, )

/*
 * C compiler options
 */

GLOBAL (bool, cc_debug, FALSE, xfree_dummy, )
/* Enable/disable inclusion of debug code into object files. */

#ifdef PRODUCTION
GLOBAL (int, cc_optimize, 3, xfree_dummy, )
#else  /* PRODUCTION */
GLOBAL (int, cc_optimize, 0, xfree_dummy, )
#endif /* PRODUCTION                                                                     \
          C compiler level of optimization */

/*
 * Optimization counters
 */
GLOBAL (optimize_counter_t, optcounters, optimize_counter_init, xfree_dummy, )

/*
 * Command line options for triggering optimizations
 */

GLOBAL (optimize_flags_t, optimize_developer, optimize_developer_init, xfree_dummy, )
GLOBAL (optimize_flags_t, optimize_production, optimize_production_init, xfree_dummy, )
GLOBAL (optimize_flags_t, optimize_all, optimize_all_init, xfree_dummy, )
GLOBAL (optimize_flags_t, optimize_none, optimize_none_init, xfree_dummy, )

#ifdef PRODUCTION
GLOBAL (optimize_flags_t, optimize, optimize_production_init, xfree_dummy, )
#else  /* PRODUCTION */
GLOBAL (optimize_flags_t, optimize, optimize_developer_init, xfree_dummy, )
#endif /* PRODUCTION */

/*
 * Command line options for triggering optimization parameters
 */

GLOBAL (bool, valid_ssaform, FALSE, xfree_dummy, )
/*
 * Flag indicating whether ast is in valid ssa form
 */

GLOBAL (int, ssaform_phase, 0, xfree_dummy, )
/*
 * Counter indicating how often the ssa form has been created FROM
 * SCRATCH(!), i.e., how often UndoSSATransform has been called.
 */

GLOBAL (int, maxwls, 1, xfree_dummy, )
/*
 * Apply aggressive withloop scalarization regardless of wls_aggressive
 * as long as the size of the inner withloop does not exceed maxwls.
 */

GLOBAL (bool, enforce_ieee, FALSE, xfree_dummy, )
/*
 * Restrict symbolic optimizations on floating point numbers according to
 * IEEE-754 standard
 */

GLOBAL (int, maxspec, 20, xfree_dummy, )
/*
 * Maximum number of specializations per function
 */

GLOBAL (ivetype_t, ive, IVE_all, xfree_dummy, )
/*
 * IVE_all: If IVE is enabled, apply it to AKS and AKD arrays
 * This is the normal setting.
 * IVE_akd: Treat AKS arrays as AKD within IVE
 * IVE_aks: Perform IVE on AKS arrays only.
 */

GLOBAL (iveotype_t, iveo, IVEO_all, xfree_dummy, )
/*
 * IVEO_all: do all ive optimisations (default)
 * IVEO_wlidx: do wlidx only
 * IVEO_idxs: use idxs2offset
 * IVEO_copt: optimize computations
 */

GLOBAL (sigspec_mode_t, sigspec_mode, SSP_aks, xfree_dummy, )
GLOBAL (char *const *, sigspec_mode_str, sigspec_mode_str_init, xfree_dummy, )
/*
 * strategy for specilization of function signatures
 */

GLOBAL (spec_mode_t, spec_mode, SS_aks, xfree_dummy, )
GLOBAL (char *const *, spec_mode_str, spec_mode_str_init, xfree_dummy, )

/*
 * Force wlt to work in naive mode
 */
GLOBAL (bool, force_naive_with2, FALSE, xfree_dummy, )
/* Force the byte size of the descriptor */
GLOBAL (int, force_desc_size, -1, xfree_dummy, )
/*
 * Command line options for specifying particular side conditions
 * for the (new) type inference.
 */

GLOBAL (int, max_recursive_inlining, 0, xfree_dummy, )
GLOBAL (int, unrnum, 2, xfree_dummy, )
GLOBAL (int, wlunrnum, 9, xfree_dummy, )
GLOBAL (int, prfunrnum, 6, xfree_dummy, )
GLOBAL (int, minarray, 4, xfree_dummy, )
GLOBAL (int, max_optcycles, 10, xfree_dummy, )
GLOBAL (int, max_newgens, 100, xfree_dummy, )
GLOBAL (bool, no_fold_fusion, FALSE, xfree_dummy, )
/*
 * Command line options for specifying particular side conditions
 * for some optimizations.
 */

GLOBAL (int, initial_master_heapsize, 1024, xfree_dummy, )
GLOBAL (int, initial_worker_heapsize, 64, xfree_dummy, )
GLOBAL (int, initial_unified_heapsize, 0, xfree_dummy, )
/*
 * Command line options for specifying particular side conditions
 * of the private heap manager.
 *
 * Why is the default initial top arena size 0?
 *
 * Unfortunately, it turned out that pthread_key_create() allocates
 * some amount of memory, actually one page, without using malloc()
 * but by direct manipulation of the process' break value via sbrk().
 * Since in multi-threaded execution malloc() is always called upon
 * program startup, early intitialization of the heap manager's internal
 * data structures is enforced.
 * Subsequent manipulation of the break value, however, leads to memory
 * fragmentation as the initial top arena cannot be extended smoothly
 * due to the missing page on top of the initially requested heap memory.
 *
 * As long as there is no elegant solution to this problem, there should
 * be no initialization of the top arena, except when an upper boundary
 * for the total memory consumption is known and used for initialization.
 */

/*
 * Primitive function info tables
 */

GLOBAL (const char **, prf_name, prf_name_init, xfree_dummy, )
GLOBAL (const arg_encoding_t *, prf_arg_encoding, prf_arg_encoding_init, xfree_dummy, )

/*
 * This array contains string representations of primitive function names.
 */

/*
 * Runtime options
 */

GLOBAL (bool, print_after_break, TRUE, xfree_dummy, )
GLOBAL (bool, visual_after_break, FALSE, xfree_dummy, )
GLOBAL (const char *, visual_format, "png", xfree_dummy, )

GLOBAL (bool, dotrace, FALSE, xfree_dummy, )
GLOBAL (bool, dousertrace, FALSE, xfree_dummy, )

/*
 * whether to enable renaming of WL IVs into SSA form
 * This option is intended to be transitory;
 * We eventually want to do WL IV renaming all the time.
 * However, we expect problems from doing this, including:
 *   - code generator assumes no renaming
 *   - other optimizations (e.g., DLIR??) make the assumption
 *     that all partitions in WL have identical IV names.
 */
GLOBAL (bool, ssaiv, FALSE, xfree_dummy, )

/*
 * whether to enable MAXVAL/MINVAL insertion for guard removal
 * and with-loop folding
 */
GLOBAL (bool, doivext, FALSE, xfree_dummy, )

/*
 * activate/control grouping of local functions
 */
GLOBAL (bool, local_funs_grouped, FALSE, xfree_dummy, )

/*
 * whether to enable the stuff tog does (-:
 */
GLOBAL (bool, dotogstuff, FALSE, xfree_dummy, )

GLOBAL (bool, insertconformitychecks, FALSE, xfree_dummy, )
GLOBAL (bool, stripconformitychecks, FALSE, xfree_dummy, )

GLOBAL (trace_flags_t, trace, trace_init, xfree_dummy, )
GLOBAL (trace_flags_t, trace_all, trace_all_init, xfree_dummy, )
GLOBAL (trace_flags_t, trace_none, trace_none_init, xfree_dummy, )

GLOBAL (bool, doruntimecheck, FALSE, xfree_dummy, )

GLOBAL (runtimecheck_flags_t, runtimecheck, runtimecheck_init, xfree_dummy, )
GLOBAL (runtimecheck_flags_t, runtimecheck_all, runtimecheck_all_init, xfree_dummy, )
GLOBAL (runtimecheck_flags_t, runtimecheck_none, runtimecheck_none_init, xfree_dummy, )

GLOBAL (bool, dovisualizefunsets, FALSE, xfree_dummy, )
GLOBAL (visualizefunsets_flags_t, visualizefunsets, visualizefunsets_init, xfree_dummy, )
GLOBAL (visualizefunsets_flags_t, visualizefunsets_all, visualizefunsets_all_init,
        xfree_dummy, )
GLOBAL (visualizefunsets_flags_t, visualizefunsets_none, visualizefunsets_none_init,
        xfree_dummy, )

GLOBAL (bool, doprint, FALSE, xfree_dummy, )
GLOBAL (bool, doprintfunsets, TRUE, xfree_dummy, )
GLOBAL (printfunsets_flags_t, printfunsets, printfunsets_init, xfree_dummy, )
GLOBAL (printfunsets_flags_t, printfunsets_all, printfunsets_all_init, xfree_dummy, )
GLOBAL (printfunsets_flags_t, printfunsets_none, printfunsets_none_init, xfree_dummy, )

GLOBAL (print_flags_t, print, print_init, xfree_dummy, )
GLOBAL (print_flags_t, print_all, print_all_init, xfree_dummy, )
GLOBAL (print_flags_t, print_none, print_none_init, xfree_dummy, )

GLOBAL (bool, doprofile, FALSE, xfree_dummy, )

GLOBAL (profile_flags_t, profile, profile_init, xfree_dummy, )
GLOBAL (profile_flags_t, profile_all, profile_all_init, xfree_dummy, )
GLOBAL (profile_flags_t, profile_none, profile_none_init, xfree_dummy, )

GLOBAL (bool, docachesim, FALSE, xfree_dummy, )

GLOBAL (cachesim_flags_t, cachesim, cachesim_init, xfree_dummy, )
GLOBAL (cachesim_flags_t, cachesim_all, cachesim_all_init, xfree_dummy, )
GLOBAL (cachesim_flags_t, cachesim_none, cachesim_none_init, xfree_dummy, )

GLOBAL (char *, cachesim_host, (char *)MEMmalloc (NAME_MAX), xfree_char_ptr, )
GLOBAL (char *, cachesim_file, (char *)MEMmalloc (NAME_MAX), xfree_char_ptr, )
GLOBAL (char *, cachesim_dir, (char *)MEMmalloc (NAME_MAX), xfree_char_ptr, )

/*
 * Profiling information storage facilities
 */

GLOBAL (int, profile_funcntr, 0, xfree_dummy, )
GLOBAL (char **, profile_funnme, (char **)MEMmalloc (PF_MAXFUN * sizeof (char *)),
        xfree_char_ptr_ptr, , PF_MAXFUN)
GLOBAL (int *, profile_funapcntr, (int *)MEMmalloc (PF_MAXFUN * sizeof (int)),
        xfree_int_ptr, )
/* FIXME: How do we free those guys?  */
GLOBAL (int **, profile_funapline, BuildFunApLine (PF_MAXFUN, PF_MAXFUNAP), xfree_apline,
        , PF_MAXFUN)
GLOBAL (int **, profile_parentfunno, BuildFunApLine (PF_MAXFUN, PF_MAXFUNAP),
        xfree_apline, , PF_MAXFUN)
GLOBAL (int, profile_funapmax, 1, xfree_dummy, )

/*
 * Compile time options
 */

GLOBAL (bool, treecheck, FALSE, xfree_dummy, )
/*
 * check syntax tree for consistency with xml specification
 */

GLOBAL (bool, lacfuncheck, FALSE, xfree_dummy, )
/*
 * check syntax tree single call property of LaC functions
 */

GLOBAL (int, check_frequency, 2, xfree_dummy, )
/*
 * treecheck and lacfuncheck frequency
 */

#ifdef PRODUCTION
GLOBAL (bool, sancheck, FALSE, xfree_dummy, )
#else  /* PRODUCTION */
GLOBAL (bool, sancheck, FALSE, xfree_dummy, )
#endif /* PRODUCTION */
       /*
        * check syntax tree for structural consistency
        */

GLOBAL (bool, memcheck, global.memcheck, xfree_dummy, )
GLOBAL (bool, nofree, FALSE, xfree_dummy, )
GLOBAL (bool, memclean, TRUE, xfree_dummy, )
/*
 * check syntaxtree for memoryproblems with xml specification
 *
 * CAUTION:
 * memcheck requires initiatilisation BEFORE anything else.
 * Therefore, we look for -d memcheck in presetup options
 * and set global.memcheck there accordingly. We re-initialise
 * global.memcheck to its existing value here for purely technical
 * reasons.
 */

GLOBAL (int, timefreq, 0, xfree_dummy, )

GLOBAL (bool, use_efence, FALSE, xfree_dummy, )
/*
 * link executable with ElectricFence (Malloc Debugger)
 */

GLOBAL (bool, on_demand_lib, FALSE, xfree_dummy, )
/*
 * build only the tree file when compiling a module
 */

/* GLOBAL( int, linksetsize,  INT_MAX) */
GLOBAL (int, linksetsize, 10, xfree_dummy, )
/*
 * number of functions written to the same file when creating library
 * Zero means unlimited.
 */

GLOBAL (bool, cleanup, TRUE, xfree_dummy, )
/*
 * Don't remove temporary files and directory when compiling
 * module/class implementations.
 */

GLOBAL (bool, libstat, FALSE, xfree_dummy, )
/*
 * Don't actually compile, but display library information.
 */

GLOBAL (bool, print_resources, FALSE, xfree_dummy, )
/*
 * Don't actually compile, but display resource information.
 */

GLOBAL (bool, makedeps, FALSE, xfree_dummy, )
/*
 * Don't actually compile, but infer module dependencies.
 */

GLOBAL (bool, makelibdeps, FALSE, xfree_dummy, )
/*
 * Don't actually compile, but infer extended module dependencies.
 */

GLOBAL (char *, printConfig, NULL, xfree_dummy, )
/*
 * Don't actually compile, but print an entry from the config file
 */

GLOBAL (bool, gen_cccall, FALSE, xfree_dummy, )
/*
 * Generate shell script '.sac2c' in current directory
 * that contains the C compiler call produced by sac2c.
 */

GLOBAL (bool, show_syscall, FALSE, xfree_dummy, )
/*
 * Show system calls during compilation.
 */

GLOBAL (bool, lacinline, TRUE, xfree_dummy, )
/*
 * Inline LAC functions
 */

GLOBAL (int, phase_num, 0, xfree_dummy, )
/*
 * Stop compilation process after given phase.
 */

GLOBAL (compiler_phase_t, break_after_phase, PH_undefined, xfree_dummy, )
/*
 * Stop compilation process after given phase.
 */

GLOBAL (compiler_phase_t, break_after_subphase, PH_undefined, xfree_dummy, )
/*
 * Stop compilation process after given subphase.
 */

GLOBAL (compiler_phase_t, break_after_cyclephase, PH_undefined, xfree_dummy, )
/*
 * Stop compilation process after given cycle optimization.
 */

GLOBAL (int, break_cycle_specifier, 1, xfree_dummy, )
/*
 * Additional break specifier that allows a designated break within
 * a particular (optimization) loop.
 */

GLOBAL (bool, prt_cycle_range, FALSE, xfree_dummy, )
/*
 * Start printing the specific function at this phase.
 */

GLOBAL (char *, break_fun_name, NULL, xfree_dummy, )
/*
 *  break_fun_name for finding function information during a break and print
 */

GLOBAL (compiler_phase_t, prtphafun_start_phase, PH_undefined, xfree_dummy, )
/*
 * Start printing the specific function at this phase.
 */

GLOBAL (compiler_phase_t, prtphafun_start_subphase, PH_undefined, xfree_dummy, )
/*
 * Start printing the specific function at this subphase.
 */
GLOBAL (compiler_phase_t, prtphafun_start_cycle, PH_undefined, xfree_dummy, )
/*
 * Start printing the specific function at this cycle.
 */

GLOBAL (int, prtphafun_start_cycle_specifier, 1, xfree_dummy, )
/*
 * Specifies the the start pass to print within a specific cyclephase loop.
 */

GLOBAL (compiler_phase_t, prtphafun_stop_phase, PH_undefined, xfree_dummy, )
/*
 * Start printing the specific function at this phase.
 */

GLOBAL (compiler_phase_t, prtphafun_stop_subphase, PH_undefined, xfree_dummy, )
/*
 * Start printing the specific function at this subphase.
 */
GLOBAL (compiler_phase_t, prtphafun_stop_cycle, PH_undefined, xfree_dummy, )
/*
 * Start printing the specific function at this cycle.
 */

GLOBAL (int, prtphafun_stop_cycle_specifier, 0, xfree_dummy, )
/*
 * Specifies the the stop pass to print within a specific cyclephase loop.
 */

GLOBAL (int, padding_overhead_limit, 10, xfree_dummy, )
/*
 * Limit for additional resource allocation due to array padding in
 * percentage. Can be modified via -aplimit option.
 */

GLOBAL (bool, apdiag, FALSE, xfree_dummy, )
/*
 * Diagnostics of array padding may be written into a file.
 * Per default no information is written. Use -apdiag to enable
 * output to "modulename.ap".
 */

GLOBAL (int, apdiag_limit, 20000, xfree_dummy, )
/*
 * Limit for size of diagnostic output given in approximate number of lines.
 * This avoids the creation of extremely huge diagnostic output files.
 */

/*
 *  Compile time information system parameters
 */

GLOBAL (te_info *, act_info_chn, NULL, xfree_dummy, )
/*
 * Info chain for extended error messages during TC
 */

#ifdef PRODUCTION
GLOBAL (int, verbose_level, 1, xfree_dummy, )
#else  /* PRODUCTION */
GLOBAL (int, verbose_level, 3, xfree_dummy, )
#endif /* PRODUCTION */
       /*
        * Verbosity of compile time output
        */

GLOBAL (compiler_phase_t, compiler_phase, PH_initial, xfree_dummy, )
/*
 * Counter for compilation phases
 */

GLOBAL (compiler_phase_t, compiler_subphase, PH_initial, xfree_dummy, )
/*
 * Counter for compilation subphases
 */

GLOBAL (compiler_phase_t, compiler_cyclephase, PH_initial, xfree_dummy, )
/*
 * Counter for cycle optimizations
 */

GLOBAL (compiler_phase_t, compiler_anyphase, PH_initial, xfree_dummy, )
/*
 * Counter for any kind of compiler phase/subphase/cyclephase
 */

GLOBAL (int, cycle_counter, 0, xfree_dummy, )
/*
 * Counter for current cycle, made global for improved bug report
 */

GLOBAL (node *, current_fundef, NULL, xfree_dummy, )
/*
 * Counter for any kind of compiler phase/subphase/cyclephase
 */

GLOBAL (bool, run_stabilization_cycle, FALSE, xfree_dummy, )
/*
 * only run stabilization cycle if main cycle pass limit exhausted
 */

GLOBAL (int, linenum, 1, xfree_dummy, )
/*
 * Current line number
 */

GLOBAL (char *, filename, NULL, xfree_dummy, )
/*
 * Current file name
 */

/*
 * DBUG options
 */

GLOBAL (compiler_phase_t, my_dbug_from, PH_initial, xfree_dummy, )
GLOBAL (compiler_phase_t, my_dbug_to, PH_final, xfree_dummy, )
GLOBAL (bool, my_dbug, FALSE, xfree_dummy, )
GLOBAL (bool, my_dbug_active, FALSE, xfree_dummy, )
GLOBAL (char *, my_dbug_str, NULL, xfree_dummy, )

/*
 * for arg tags
 */

GLOBAL (bool *, argtag_has_shp, argtag_has_shp_init, xfree_dummy, )
GLOBAL (bool *, argtag_has_rc, argtag_has_rc_init, xfree_dummy, )
GLOBAL (bool *, argtag_has_desc, argtag_has_desc_init, xfree_dummy, )
GLOBAL (bool *, argtag_is_in, argtag_is_in_init, xfree_dummy, )
GLOBAL (bool *, argtag_is_out, argtag_is_out_init, xfree_dummy, )
GLOBAL (bool *, argtag_is_inout, argtag_is_inout_init, xfree_dummy, )
GLOBAL (const char **, argtag_string, argtag_string_init, xfree_dummy, )

/*
 * Special purpose global variables
 */

GLOBAL (bool, print_objdef_for_header_file, FALSE, xfree_dummy, )
/*
 *  This global variable serves a very special purpose.
 *  When generating separate C-files for functions and global variables,
 *  a header file is required which contains declarations of them all.
 *  In this case the ICM ND_KS_DECL_GLOBAL_ARRAY must be written
 *  differently. This global variable triggers the respective print
 *  function defined in icm2c.c. It is set by PrintModul.
 */

GLOBAL (int, object_counter, 0, xfree_dummy, )
/*
 *  This global variable is used whenever the objectinitflags of a module
 *  are written to separate files.
 */

GLOBAL (int, indent, 0, xfree_dummy, )
/*
 *  This global variable is used for indenting while printing SAC-code.
 *  It has to be made global since printing is not only done in the printing-
 *  directory but from within icm2c_xxx.c as well!
 */

GLOBAL (const int *, basetype_size, basetype_size_init, xfree_dummy, )
/*
 * This array of integers keeps the lengths of all simpletypes.
 * It at least is used in compile.c, tile_size_inference.c, and constants.c!
 */

GLOBAL (min_array_rep_t, min_array_rep, MAR_scl_aks, xfree_dummy, )
/*
 * This global variable can be used to restrict the set of
 * array representations used by the backend
 */

/*
 * Name tuples
 */

GLOBAL (char **, nt_shape_string, nt_shape_string_init, xfree_dummy, )
GLOBAL (char **, nt_hidden_string, nt_hidden_string_init, xfree_dummy, )
GLOBAL (char **, nt_unique_string, nt_unique_string_init, xfree_dummy, )
/* mutc */
GLOBAL (char **, nt_mutc_storage_class_string, nt_mutc_storage_class_string_init,
        xfree_dummy, )
GLOBAL (char **, nt_mutc_scope_string, nt_mutc_scope_string_init, xfree_dummy, )
GLOBAL (char **, nt_mutc_usage_string, nt_mutc_usage_string_init, xfree_dummy, )
GLOBAL (char **, nt_bitarray_string, nt_bitarray_string_init, xfree_dummy, )
/*
 * These character arrays are the macro-name-parts used to select
 * array class and array uniqueness properties.
 */

GLOBAL (const char **, backend_string, backend_string, xfree_dummy, )
/*
 * Primitive zip function tables, previously defined in zipcv.c
 */

GLOBAL (const zipcvfunptr *, zipcv_plus, zipcv_plus_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_minus, zipcv_minus_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_mul, zipcv_mul_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_div, zipcv_div_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_mod, zipcv_mod_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_min, zipcv_min_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_max, zipcv_max_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_and, zipcv_and_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_or, zipcv_or_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_eq, zipcv_eq_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_neq, zipcv_neq_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_le, zipcv_le_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_lt, zipcv_lt_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_gt, zipcv_gt_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_ge, zipcv_ge_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_not, zipcv_not_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_tob, zipcv_tob_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_tos, zipcv_tos_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_toc, zipcv_toc_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_tobool, zipcv_tobool, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_toi, zipcv_toi_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_tol, zipcv_tol_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_toll, zipcv_toll_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_toub, zipcv_toub_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_tous, zipcv_tous_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_toui, zipcv_toui_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_toul, zipcv_toul_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_toull, zipcv_toull_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_tof, zipcv_tof_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_tod, zipcv_tod_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_abs, zipcv_abs_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_neg, zipcv_neg_init, xfree_dummy, )

/*
 * Primitive base function tables, previously defined in basecv.c
 */

GLOBAL (const basecvfunptr *, basecv_negativeone, basecv_negativeone_init, xfree_dummy, )
GLOBAL (const basecvfunptr *, basecv_zero, basecv_zero_init, xfree_dummy, )
GLOBAL (const basecvfunptr *, basecv_one, basecv_one_init, xfree_dummy, )

/*
 * Constant vector copying function table, previously defined in cv2cv.c
 */

GLOBAL (const cv2cvfunptr *, cv2cv, cv2cv_init, xfree_dummy, )

/*
 * Constant vector to scalar conversion function table, previously defined in cv2scalar.c
 */

GLOBAL (const cv2scalarfunptr *, cv2scalar, cv2scalar_init, xfree_dummy, )

/*
 * Constant vector to string conversion function table, previously defined in cv2str.c
 */

GLOBAL (const cv2strfunptr *, cv2str, cv2str_init, xfree_dummy, )

/*
 * Debug string tables
 */

GLOBAL (const char **, mdb_nodetype, mdb_nodetype_init, xfree_dummy, )
GLOBAL (const char **, mdb_type, mdb_type_init, xfree_dummy, )

/*
 * Type to string conversion tables
 */

GLOBAL (const char **, type_string, type_string_init, xfree_dummy, )
GLOBAL (const char **, rename_type, rename_type_init, xfree_dummy, )

/*
 * Resource / configuration management
 */

GLOBAL (target_list_t *, target_list, NULL, xfree_dummy, )
/*
 * When the configuration files are parsed, a dynamic tree like structure
 * is generated and its root is stored in target_list. This dynamic structure
 * is afterwards processed, the relevant information is stored in the static
 * structure config, and the target_list is finally released.
 */

GLOBAL (configuration_t, config, config_init, xfree_configuration, )
/*
 * This global variable permanently stores the desired configuration
 * which is read from the sac2crc file.
 */

/*
 * Storing module dependencies
 */

/* FIXME this is another place fot careful freeing.  */
GLOBAL (stringset_t *, dependencies, NULL, xfree_dummy, )

GLOBAL (bool, debug_rc, FALSE, xfree_dummy, )
/*
 * MUTC backend options
 */

GLOBAL (bool, mutc_fun_as_threads, FALSE, xfree_dummy, )
GLOBAL (bool, mutc_thread_mem, FALSE, xfree_dummy, )
GLOBAL (bool, mutc_disable_thread_mem, FALSE, xfree_dummy, )
GLOBAL (bool, mutc_benchmark, FALSE, xfree_dummy, )
GLOBAL (bool, mutc_suballoc_desc_one_level_up, FALSE, xfree_dummy, )
GLOBAL (bool, mutc_static_resource_management, FALSE, xfree_dummy, )
GLOBAL (mutc_distribution_mode_t, mutc_distribution_mode, MUTC_DMODE_default,
        xfree_dummy, )
GLOBAL (int, mutc_distribution_mode_arg, -1, xfree_dummy, )
GLOBAL (int, mutc_force_block_size, -1, xfree_dummy, )
GLOBAL (char *, mutc_force_spawn_flags, NULL, xfree_char_ptr, )
GLOBAL (int, mutc_unroll, 1, xfree_dummy, )
GLOBAL (int, mutc_rc_places, 1, xfree_dummy, )
GLOBAL (bool, mutc_rc_indirect, FALSE, xfree_dummy, )
GLOBAL (bool, mutc_seq_data_parallel, FALSE, xfree_dummy, )

/*
 * CUDA backend options
 */
GLOBAL (int, optimal_threads, 0, xfree_dummy, ) /* optimal number of threads per block */
GLOBAL (int, optimal_blocks, 0, xfree_dummy, )  /* optimal number of  blocks per SM */
GLOBAL (int, cuda_1d_block_x, 0, xfree_dummy, )
GLOBAL (int, cuda_1d_block_large, 0, xfree_dummy, )
GLOBAL (int, cuda_1d_block_small, 0, xfree_dummy, )
GLOBAL (int, cuda_2d_block_x, 0, xfree_dummy, )
GLOBAL (int, cuda_2d_block_y, 0, xfree_dummy, )
GLOBAL (int, cuda_blocking_factor, 0, xfree_dummy, )

/*
 * cygwin compatibility globals
 */
#if IS_CYGWIN
GLOBAL (cyg_fun_table_t *, cyg_fun_table, NULL, xfree_dummy)
/*
 * Stores a list of function pointers for compiled sac modules to call.
 * This is in order to solve a problem where a compiled module will be
 * dependant on the compiler used. See sac2ccyg.c
 */
#endif /* IS_CYGWIN */

#undef GLOBALtype
#undef GLOBALname
#undef GLOBALinit
#undef GLOBAL
