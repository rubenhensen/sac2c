/*
 * File : globals.mac
 *
 * This file should contain the definitions of all global variables
 * used in the implementation of the sac2c compiler which are not restricted
 * to the use within one particular file.
 *
 * However, the usage of global variables should be as limited as possible
 * since a functional programming style is preferred in the SAC project. The
 * major application of global variables therefore is the storage of such
 * global information as determined by the command line arguments of a sac2c
 * compiler call.
 *
 */

#include "config.h"
#include "sacdirs.h"

/* The source file of sac program can come from various files due to
   recognition of #line directives.  Usually massively used by preprocessor.
   Every token keeps a pointer to the file name.  In order to share file names
   we keep a table of file names we've seen so far.  The table is just a dynamic
   array with size attached.

   Currently such a simple format suffises, as the lexer keeps file names in the
   hash table, and on exit it dumps the list to this table.  We do not search over
   this table and we do not support multiple file compilation, which means that one
   global table would work.  */
GLOBAL (size_t, file_table_size, 0, xfree_dummy, )
GLOBAL (char **, file_table, NULL, xfree_char_ptr_ptr, , global.file_table_size)

/*
 * Memory allocation
 */

GLOBAL (size_t, current_allocated_mem, 0, xfree_dummy, )
GLOBAL (size_t, max_allocated_mem, 0, xfree_dummy, )

/*
 * Tool type
 */

GLOBAL (tool_t, tool, TOOL_sac2c, xfree_dummy, )
GLOBAL (const char *, toolname, NULL, xfree_dummy, )

/*
 * Syntax tree root
 */

GLOBAL (node *, syntax_tree, NULL, xfree_dummy, )

/*
 * Parsing
 */

GLOBAL (int, start_token, 0, xfree_dummy, )

/*
 *  Version control
 */

GLOBAL (const char *, version_id, SAC2C_VERSION, xfree_dummy, )
/*
 * version string
 */

/*
 *  Standard prelude name
 */

GLOBAL (const char *, preludename, SAC_PRELUDE_NAME, xfree_dummy, )

/*
 *  Flag to enable/disable loading of prelude
 */
GLOBAL (bool, loadprelude, TRUE, xfree_dummy, )

/* This triggers whether to load libsac, libphm, and friends.
   We use this when compiling sacprelude.  This flag can be possibly
   avoided if libsacprelude would depend on libsac, libphm, etc.  */
GLOBAL (bool, loadsaclibs, TRUE, xfree_dummy, )

/*
 *  File handling
 */

GLOBAL (FILE *, outfile, NULL, xfree_dummy, )
GLOBAL (bool, install, FALSE, xfree_dummy, )

/* Avoid compiling Tree files.  */
GLOBAL (bool, notree, FALSE, xfree_dummy, )

/*
 * stream to write result to
 */

GLOBAL (char *, sacfilename, NULL, xfree_char_ptr, )
/*
 * name of file to be compiled
 */

GLOBAL (char *, puresacfilename, "stdin", xfree_dummy, )
/*
 * sacfilename without path specification
 */

GLOBAL (char *, outfilename, NULL, xfree_char_ptr, )
/*
 * name of executable / target base directory for module tree files
 */

GLOBAL (char *, target_modlibdir, NULL, xfree_char_ptr, )
/*
 * target base directory for module lib files
 */

GLOBAL (char *, modulename, NULL, xfree_char_ptr, )
/*
 * name of module/class which is compiled
 */

GLOBAL (namespace_t *, modulenamespace, NULL, xfree_dummy, )
/*
 * namespace of module/class which is compiled
 */

GLOBAL (char *, targetdir, NULL, xfree_char_ptr, )
/*
 * name of C source code file
 */

GLOBAL (file_type, filetype, FT_prog, xfree_dummy, )
/*
 * kind of file: FT_prog, FT_modimp or FT_classimp
 */

GLOBAL (char *, cwd, NULL, xfree_char_ptr, )
/*
 * current working directory of the compiler,
 * used to canonicalize relative paths.
 */

GLOBAL (char *, tmp_dirname, NULL, xfree_char_ptr, )
/*
 * directory for storing temporary files
 */

GLOBAL (char *, system_cleanup, NULL, xfree_char_ptr, )
/*
 * directory for storing temporary files
 */

GLOBAL (int, polylib_filenumber, 0, xfree_dummy, )
/*
 * polylib file counter, used to ensure no collisions among
 * polylib file names created by PHUT and friends.
 */

/* FIXME: This one also needs special attention; dummy for the time being.  */
GLOBAL (stringset_t *, exported_modules, NULL, xfree_dummy, )
/*
 * list of modules that will be exported by sac4c
 */

GLOBAL (bool, genfortran, FALSE, xfree_dummy, )
/*
 * enables the generation of a Fortran interface in addition to
 * the C-lib/header through sac4c
 */

GLOBAL (bool, printldflags, FALSE, xfree_dummy, )
/*
 * enables printing of ldflags in sac4c
 */

GLOBAL (bool, printccflags, FALSE, xfree_dummy, )
/*
 * enables printing of ccflags in sac4c
 */

GLOBAL (do_c_type_t, do_clink, DO_C_none, xfree_dummy, )
/*
 * enables just linking a bunch of C objects in sac2c
 */

GLOBAL (do_c_type_t, do_ccompile, DO_C_none, xfree_dummy, )
/*
 * enables just compiling a C source in sac2c
 */

GLOBAL (char *, lib_dirname, NULL, xfree_char_ptr, )
/*
 * directory for wrapper file generated by sac4c
 */

GLOBAL (char *, inc_dirname, NULL, xfree_char_ptr, )
/*
 * directory for include file generated by sac4c
 */

GLOBAL (int, sac4c_udt_offset, 20, xfree_dummy, )
/*
 * sac4c udt offset, needs to be greater than max( usertype)
 */

GLOBAL (char *, cppflags, NULL, xfree_char_ptr, )
/*
 * Additional C preprocessor flags for program/module code
 */

GLOBAL (char *, cflags, NULL, xfree_char_ptr, )
/*
 * Additional compiler flags for program/module code
 */

GLOBAL (char *, ldflags, NULL, xfree_char_ptr, )
/*
 * Additional linker flags for program/module code
 */

GLOBAL (char *, tree_cflags, NULL, xfree_char_ptr, )
/*
 * Additional compiler flags for tree code
 */

GLOBAL (char *, tree_ldflags, NULL, xfree_char_ptr, )
/*
 * Additional linker flags for tree code
 */

GLOBAL (char *, command_line, NULL, xfree_char_ptr, )
/*
 * All command line arguments
 */

GLOBAL (int, num_fun_files, 0, xfree_dummy, )
/*
 * Number of funNNN.c files generated.
 */

GLOBAL (int, argc, 0, xfree_dummy, )
GLOBAL (char **, argv, NULL, xfree_dummy, )

/*
 * Target architecture description
 */

GLOBAL (char *, target_name, "default_sbi", xfree_dummy, )
/*
 * name of target architecture selected by -target option
 */

/* Default component name of the typedef node.  */
GLOBAL (const char *, default_component_name, "element", xfree_dummy, )

/*
 * Backend option
 */
GLOBAL (backend_t, backend, BE_c99, xfree_dummy, )

/*
 * Dynamic-sized arrays option
 */

/*
 * Dynamic shapes are disabled by default
 */
GLOBAL (bool, dynamic_shapes, FALSE, xfree_dummy, )

/*
 * Struct support options
 */
GLOBAL (bool, enable_structs, FALSE, xfree_dummy, )

/* -- Runtime Specialization -- */


/*
 * Runtime specialization mode. Only relevant in case rtspec is 
 * enabled which happens through sac2crc's RTSPEC.
 * Like all sac2crc values, it is available in global.config as
 * global.config.rtspec
 */
#if ENABLE_UUID
GLOBAL (int, rtspec_mode, 2, xfree_dummy, )
#elif ENABLE_HASH
GLOBAL (int, rtspec_mode, 1, xfree_dummy, )
#else
GLOBAL (int, rtspec_mode, 0, xfree_dummy, )
#endif /* ENABLE_UUID */

/*
 * Type info provided as a commandline argument for runtime optimization.
 */

GLOBAL (char *, rt_type_info, "", xfree_dummy, )
/*
 * Default it has no value.
 */

/*
 * Shape info provided as a commandline argument for runtime optimization.
 */

GLOBAL (char *, rt_shape_info, "", xfree_dummy, )
/*
 * Default it has no value
 */

/*
 * The name of the module from which to import the previous function instances.
 */

GLOBAL (char *, rt_old_module, "", xfree_dummy, )
/*
 * Default it has no value.
 */

/*
 * The name of the new module that is to be created at runtime.
 */

GLOBAL (char *, rt_new_module, "", xfree_dummy, )
/*
 * Default it has no value.
 */

/*
 * The name of the function being optimized.
 */
GLOBAL (char *, rt_fun_name, "", xfree_dummy, )
/*
 * Default it has no value.
 */

/*
 * The name the new wrapper should get.
 */
GLOBAL (char *, rt_new_name, "", xfree_dummy, )
/*
 * Default it has no value.
 */

/*
 * The functions arguments as they should be after optimization.
 *
 * The last element (xfree_dummy) should not be changed to 'xfree_node' as
 * 'rt_args' is not a proper syntax tree. Setting it to xfree_node leads to a
 * segfault *after* compilation has finished.
 */
GLOBAL (node *, rt_args, NULL, xfree_dummy, )
/*
 * Default it is NULL.
 */

/*
 * The number of arguments in the rt_args chain..
 */
GLOBAL (int, rt_num_args, 0, xfree_dummy, )
/*
 * Default it is zero.
 */

/*
 * Runtime specialization flag for recompiling at runtime.
 */

GLOBAL (bool, runtime, FALSE, xfree_dummy, )
/*
 * Runtime specialization is disabled by default.
 */

/* -- Runtime Specialization -- */

/*
 * Extended LaC fun option
 */

GLOBAL (bool, elf, FALSE, xfree_dummy, )
/*
 * Extended LaC fun option disabled per default
 */

/*
 * Multi-thread options
 */

GLOBAL (mtmode_t, mtmode, MT_none, xfree_dummy, )
/*
 * Multi-thread mode set according to -mt and -mtmode compiler flags
 */

GLOBAL (int, mt_barrier_type, 0, xfree_dummy, )
/*
 * Select barrier type for synchronization of threads
 * 0:"spin"   : (default) uses a spinlock technique to implement the barrier
 * 1:"mutex"  : a barrier implementation solely based on mutex locks and counters
 * 2:"cond"   : uses pthread_cond_wait to implement the barrier
 * 3:"pthread": uses the built-in POSIX thread barrier implementation
 * 4:"futex"  : a barrier that uses the low level futex lock technique
 */

GLOBAL (int, mt_smart_mode, 0, xfree_dummy, )
/*
 * Select smart decision mode
 * 0:"off"    : (default) do not use the smart decision technique
 * 1:"train"  : toggles the smart decision tool into training mode
 * 2:"on"     : use smart decisions to optimize the number of threads being used
 *              to compute spmd functions
 */

GLOBAL (char *, mt_smart_filename, "default", xfree_dummy, )
/*
 * Filename for smart decision database file
 */

GLOBAL (char *, mt_smart_arch, NULL, xfree_dummy, )
/*
 * The name of the computer architecture you are using.
 */

GLOBAL (int, mt_smart_period, 500, xfree_dummy, )
/*
 * To be able to make smart decisions, a performance profile is being created by
 * performing a number of time measurements. This value is an indication for the
 * time (ms) a single measurement should take. The real time can be a bit shorter
 * or a bit longer.
 */

GLOBAL (int, mt_smart_gradient, 1, xfree_dummy, )
/*
 * To be able to make smart decisions, a performance profile is being created.
 * This profile is used to create a performance graph for each parallelizable
 * with loop. The smart decision tool tries to find the point on the performance
 * graph where the gradient matches the 'mt_smart_gradient' value (degrees). This
 * point on the performance graph will be used to determine the optimal number
 * of threads to be used to parallelize the with loop.
 */

GLOBAL (char *, ompschedule, "static", xfree_dummy, )
/*
 * OMP schedule technique
 */

GLOBAL (int, ompbenchmark, 10000, xfree_dummy, )
/*
 * OMP benchmark in if statement
 */

GLOBAL (int, ompnestlevel, 1, xfree_dummy, )
/*
 * OMP nesting level
 */

GLOBAL (int, ompchunksize, 1, xfree_dummy, )
/*
 * OMP chunk size
 */

GLOBAL (int, num_threads, 0, xfree_dummy, )
/*
 * Number of threads to be generated.
 *  0  : dynamic number of threads, specified as first command line argument
 *       on application program startup.
 *  1  : sequential program
 *  >1 : exact number of threads to be started
 */

GLOBAL (cpubindstrategy_t, cpubindstrategy, HWLOC_off, xfree_dummy, )

GLOBAL (bool, no_fold_parallel, FALSE, xfree_dummy, )
/*
 * Switch whether or not to parallelize fold with-loops.
 */

GLOBAL (int, max_threads, 128, xfree_dummy, )
/*
 * Maximum number of threads if exact number is determined dynamically.
 */

GLOBAL (unsigned int, distmem_max_memory_mb, 512, xfree_dummy, )
/*
 * Amount of memory in MB for the DSM subsystem (for both local segment and cache)
 * when the distributed memory backend is used.
 */

GLOBAL (bool, distmem_cache_outside_dsm, FALSE, xfree_dummy, )
/*
 * Assign cache segments outside of DSM segment when the distributed memory backend
 * is used.
 */

GLOBAL (int, distmem_tr_pf_node, -1, xfree_dummy, )
/*
 * If not equal to -1, trace and profile output is only produced for the node with the
 * provided rank.
 */

GLOBAL (bool, distmem_ptrs_desc, FALSE, xfree_dummy, )
/*
 * Flag for the distributed memory backend: Keep pointers to the start of a distributed
 * array at every node in the array descriptor.
 */

GLOBAL (bool, distmem_ptr_cache, TRUE, xfree_dummy, )
/*
 * Flag for the distributed memory backend: Enable the pointer cache.
 */

GLOBAL (unsigned int, distmem_min_elems_per_node, 10, xfree_dummy, )
/*
 * Minimum number of array elements per node such that the array is distributed
 * when the distributed memory backend is used.
 */

GLOBAL (int, dmgs_min_selects, 3, xfree_dummy, )
/*
 * Minimum number of selects that have not been marked as local in the
 * DMMLS optimisation so that the DMGS optimisation is applied.
 */

GLOBAL (int, dmgs_max_selects, 0, xfree_dummy, )
/*
 * Maximum number of selects that have not been marked as local in the
 * DMMLS optimisation so that the DMGS optimisation is applied.
 */

GLOBAL (int, num_rtspec_threads, 1, xfree_dummy, )
/*
 * Number of rtspec controller threads to be generated.
 */

GLOBAL (int, min_parallel_size, 250, xfree_dummy, )
/*
 * Minimum generator size for parallel execution of with-loops.
 */

GLOBAL (int, max_replication_size, 250, xfree_dummy, )
/*
 * Maximum size of array for replication, otherwise the calculation will be
 * executed single-threaded.
 */

GLOBAL (int, max_schedulers, 0, xfree_dummy, )
/*
 * This variable is used to collect the maximum number of schedulers in a
 * single SPMD block/function in order to generate an appropriate number
 * of local data structure sets for the scheduler implementations.
 */

GLOBAL (int, min_parallel_size_per_thread, 8, xfree_dummy, )
/*
 * Minimum generator size per thread for parallel execution of with-loops
 * e.g., max_threads = 4, min_parallel_size_per_thread=8
 *       => generator size must be >= 32 to be executed parallel
 */

GLOBAL (bool, enforce_float, FALSE, xfree_dummy, )

GLOBAL (bool, fp, FALSE, xfree_dummy, )
/*
 * Use functional parallelism
 */

GLOBAL (bool, fpnoopt, FALSE, xfree_dummy, )
/*
 * Do FP optimizations
 */

/*
 * Preprocessor options
 *
 *  refer to -D, -cppI command line options:
 */

GLOBAL (char *, cpp_options, NULL, xfree_char_ptr, )

/*
 * C compiler options
 */

GLOBAL (bool, cc_debug, FALSE, xfree_dummy, )
/* Enable/disable inclusion of debug code into object files. */

GLOBAL (bool, cc_debug_extra, FALSE, xfree_dummy, )
/* On enable, this causes more debug information to be added to the
 * generated C source code that can be read by tools like GDB -
 * this sets cc_debug to TRUE as well.
 */

#ifdef PRODUCTION
GLOBAL (int, cc_optimize, 3, xfree_dummy, )
#else  /* PRODUCTION */
GLOBAL (int, cc_optimize, 0, xfree_dummy, )
#endif /* PRODUCTION
        * C compiler level of optimization
        */

GLOBAL (bool, cc_tune_generic, FALSE, xfree_dummy, )
/* On true, we wil build using the C compilers tune=generic
 * flag, instead of its tune=native or similar flag.
 */

/*
 * Optimization counters
 */
GLOBAL (optimize_counter_t, optcounters, optimize_counter_init, xfree_dummy, )

/*
 * Command line options for triggering optimizations
 */

GLOBAL (optimize_flags_t, optimize_developer, optimize_developer_init, xfree_dummy, )
GLOBAL (optimize_flags_t, optimize_production, optimize_production_init, xfree_dummy, )
GLOBAL (optimize_flags_t, optimize_all, optimize_all_init, xfree_dummy, )
GLOBAL (optimize_flags_t, optimize_none, optimize_none_init, xfree_dummy, )

#ifdef PRODUCTION
GLOBAL (optimize_flags_t, optimize, optimize_production_init, xfree_dummy, )
#else  /* PRODUCTION */
GLOBAL (optimize_flags_t, optimize, optimize_developer_init, xfree_dummy, )
#endif /* PRODUCTION */

/*
 * Command line options for triggering optimization parameters
 */

GLOBAL (bool, valid_ssaform, FALSE, xfree_dummy, )
/*
 * Flag indicating whether ast is in valid ssa form
 */

GLOBAL (int, ssaform_phase, 0, xfree_dummy, )
/*
 * Counter indicating how often the ssa form has been created FROM
 * SCRATCH(!), i.e., how often UndoSSATransform has been called.
 */

GLOBAL (int, maxwls, 1, xfree_dummy, )
/*
 * Apply aggressive withloop scalarization regardless of wls_aggressive
 * as long as the size of the inner withloop does not exceed maxwls.
 */

GLOBAL (bool, enforce_ieee, FALSE, xfree_dummy, )
/*
 * Restrict symbolic optimizations on floating point numbers according to
 * IEEE-754 standard
 */

GLOBAL (int, maxspec, 20, xfree_dummy, )
/*
 * Maximum number of specializations per function
 */

GLOBAL (ivetype_t, ive, IVE_all, xfree_dummy, )
/*
 * IVE_all: If IVE is enabled, apply it to AKS and AKD arrays
 * This is the normal setting.
 * IVE_akd: Treat AKS arrays as AKD within IVE
 * IVE_aks: Perform IVE on AKS arrays only.
 */

GLOBAL (iveotype_t, iveo, IVEO_all, xfree_dummy, )
/*
 * IVEO_all: do all ive optimisations (default)
 * IVEO_wlidx: do wlidx only
 * IVEO_idxs: use idxs2offset
 * IVEO_copt: optimize computations
 */

GLOBAL (sigspec_mode_t, sigspec_mode, SSP_aks, xfree_dummy, )
GLOBAL (char *const *, sigspec_mode_str, sigspec_mode_str_init, xfree_dummy, )
/*
 * strategy for specilization of function signatures
 */

GLOBAL (spec_mode_t, spec_mode, SS_aks, xfree_dummy, )
GLOBAL (char *const *, spec_mode_str, spec_mode_str_init, xfree_dummy, )

/*
 * Force wlt to work in naive mode
 */
GLOBAL (bool, force_naive_with2, FALSE, xfree_dummy, )
/* Force the byte size of the descriptor */
GLOBAL (int, force_desc_size, -1, xfree_dummy, )
/*
 * Command line options for specifying particular side conditions
 * for the (new) type inference.
 */

GLOBAL (int, max_recursive_inlining, 0, xfree_dummy, )
GLOBAL (int, unrnum, 2, xfree_dummy, )
GLOBAL (int, wlunrnum, 9, xfree_dummy, )
GLOBAL (int, prfunrnum, 6, xfree_dummy, )
GLOBAL (int, minarray, 4, xfree_dummy, )
GLOBAL (int, max_optcycles, 10, xfree_dummy, )
GLOBAL (int, max_newgens, 100, xfree_dummy, )
GLOBAL (bool, no_fold_fusion, FALSE, xfree_dummy, )
/*
 * Command line options for specifying particular side conditions
 * for some optimizations.
 */

GLOBAL (int, initial_master_heapsize, 1024, xfree_dummy, )
GLOBAL (int, initial_worker_heapsize, 64, xfree_dummy, )
GLOBAL (int, initial_unified_heapsize, 0, xfree_dummy, )
/*
 * Command line options for specifying particular side conditions
 * of the private heap manager.
 *
 * Why is the default initial top arena size 0?
 *
 * Unfortunately, it turned out that pthread_key_create() allocates
 * some amount of memory, actually one page, without using malloc()
 * but by direct manipulation of the process' break value via sbrk().
 * Since in multi-threaded execution malloc() is always called upon
 * program startup, early intitialization of the heap manager's internal
 * data structures is enforced.
 * Subsequent manipulation of the break value, however, leads to memory
 * fragmentation as the initial top arena cannot be extended smoothly
 * due to the missing page on top of the initially requested heap memory.
 *
 * As long as there is no elegant solution to this problem, there should
 * be no initialization of the top arena, except when an upper boundary
 * for the total memory consumption is known and used for initialization.
 */

/*
 * Primitive function info tables
 */

GLOBAL (const char **, prf_name, prf_name_init, xfree_dummy, )
GLOBAL (const arg_encoding_t *, prf_arg_encoding, prf_arg_encoding_init, xfree_dummy, )

/*
 * This array contains string representations of primitive function names.
 */

/*
 * Runtime options
 */

GLOBAL (bool, print_after_break, TRUE, xfree_dummy, )
GLOBAL (bool, visual_after_break, FALSE, xfree_dummy, )
GLOBAL (const char *, visual_format, "png", xfree_dummy, )

GLOBAL (bool, dotrace, FALSE, xfree_dummy, )
GLOBAL (bool, dousertrace, FALSE, xfree_dummy, )

/*
 * whether to enable renaming of WL IVs into SSA form
 * This option is intended to be transitory;
 * We eventually want to do WL IV renaming all the time.
 * However, we expect problems from doing this, including:
 *   - code generator assumes no renaming
 *   - other optimizations (e.g., DLIR??) make the assumption
 *     that all partitions in WL have identical IV names.
 */
GLOBAL (bool, ssaiv, FALSE, xfree_dummy, )

/*
 * whether to enable MAXVAL/MINVAL insertion for guard removal
 * and with-loop folding
 */
GLOBAL (bool, doivext, FALSE, xfree_dummy, )

/*
 * activate/control grouping of local functions
 */
GLOBAL (bool, local_funs_grouped, FALSE, xfree_dummy, )

/*
 * whether to enable the stuff tog does (-:
 */
GLOBAL (bool, dotogstuff, FALSE, xfree_dummy, )

GLOBAL (bool, insertconformitychecks, FALSE, xfree_dummy, )
GLOBAL (bool, stripconformitychecks, FALSE, xfree_dummy, )

GLOBAL (feedback_flags_t, feedback, feedback_init, xfree_dummy, )
GLOBAL (feedback_flags_t, feedback_all, feedback_all_init, xfree_dummy, )
GLOBAL (feedback_flags_t, feedback_none, feedback_none_init, xfree_dummy, )

GLOBAL (trace_flags_t, trace, trace_init, xfree_dummy, )
GLOBAL (trace_flags_t, trace_all, trace_all_init, xfree_dummy, )
GLOBAL (trace_flags_t, trace_none, trace_none_init, xfree_dummy, )

GLOBAL (bool, doruntimecheck, FALSE, xfree_dummy, )

GLOBAL (runtimecheck_flags_t, runtimecheck, runtimecheck_init, xfree_dummy, )
GLOBAL (runtimecheck_flags_t, runtimecheck_all, runtimecheck_all_init, xfree_dummy, )
GLOBAL (runtimecheck_flags_t, runtimecheck_none, runtimecheck_none_init, xfree_dummy, )

GLOBAL (bool, dovisualizefunsets, FALSE, xfree_dummy, )
GLOBAL (visualizefunsets_flags_t, visualizefunsets, visualizefunsets_init, xfree_dummy, )
GLOBAL (visualizefunsets_flags_t, visualizefunsets_all, visualizefunsets_all_init,
        xfree_dummy, )
GLOBAL (visualizefunsets_flags_t, visualizefunsets_none, visualizefunsets_none_init,
        xfree_dummy, )

GLOBAL (bool, doprint, FALSE, xfree_dummy, )
GLOBAL (bool, doprintfunsets, TRUE, xfree_dummy, )
GLOBAL (printfunsets_flags_t, printfunsets, printfunsets_init, xfree_dummy, )
GLOBAL (printfunsets_flags_t, printfunsets_all, printfunsets_all_init, xfree_dummy, )
GLOBAL (printfunsets_flags_t, printfunsets_none, printfunsets_none_init, xfree_dummy, )

GLOBAL (print_flags_t, print, print_init, xfree_dummy, )
GLOBAL (print_flags_t, print_all, print_all_init, xfree_dummy, )
GLOBAL (print_flags_t, print_none, print_none_init, xfree_dummy, )

GLOBAL (bool, doprofile, FALSE, xfree_dummy, )

GLOBAL (profile_flags_t, profile, profile_init, xfree_dummy, )
GLOBAL (profile_flags_t, profile_all, profile_all_init, xfree_dummy, )
GLOBAL (profile_flags_t, profile_none, profile_none_init, xfree_dummy, )

GLOBAL (bool, docachesim, FALSE, xfree_dummy, )

GLOBAL (cachesim_flags_t, cachesim, cachesim_init, xfree_dummy, )
GLOBAL (cachesim_flags_t, cachesim_all, cachesim_all_init, xfree_dummy, )
GLOBAL (cachesim_flags_t, cachesim_none, cachesim_none_init, xfree_dummy, )

GLOBAL (char *, cachesim_host, (char *)MEMmalloc (NAME_MAX), xfree_char_ptr, )
GLOBAL (char *, cachesim_file, (char *)MEMmalloc (NAME_MAX), xfree_char_ptr, )
GLOBAL (char *, cachesim_dir, (char *)MEMmalloc (NAME_MAX), xfree_char_ptr, )

/*
 * Profiling information storage facilities
 */

GLOBAL (size_t, profile_funcntr, 0, xfree_dummy, )
GLOBAL (char **, profile_funnme, (char **)MEMmalloc (PF_MAXFUN * sizeof (char *)),
        xfree_char_ptr_ptr, , PF_MAXFUN)
GLOBAL (int *, profile_funapcntr, (int *)MEMmalloc (PF_MAXFUN * sizeof (int)),
        xfree_int_ptr, )
/* FIXME: How do we free those guys?  */
GLOBAL (size_t **, profile_funapline, BuildFunApLine (PF_MAXFUN, PF_MAXFUNAP), xfree_apline,
        , PF_MAXFUN)
GLOBAL (size_t **, profile_parentfunno, BuildFunApLine (PF_MAXFUN, PF_MAXFUNAP),
        xfree_apline, , PF_MAXFUN)
GLOBAL (int, profile_funapmax, 1, xfree_dummy, )

/*
 * Compile time options
 */

GLOBAL (bool, gpukernel, FALSE, xfree_dummy, )
/*
 * relevant for debugging CUDA code only! Extensive checks whether the
 * index-space to thread-space mapping works correctly.
 */

GLOBAL (bool, treecheck, FALSE, xfree_dummy, )
/*
 * check syntax tree for consistency with xml specification
 */

GLOBAL (bool, lacfuncheck, FALSE, xfree_dummy, )
/*
 * check syntax tree single call property of LaC functions
 */

GLOBAL (int, check_frequency, 2, xfree_dummy, )
/*
 * treecheck and lacfuncheck frequency
 */

#ifdef PRODUCTION
GLOBAL (bool, sancheck, FALSE, xfree_dummy, )
#else  /* PRODUCTION */
GLOBAL (bool, sancheck, FALSE, xfree_dummy, )
#endif /* PRODUCTION */
       /*
        * check syntax tree for structural consistency
        */

GLOBAL (bool, memcheck, global.memcheck, xfree_dummy, )
GLOBAL (bool, nofree, FALSE, xfree_dummy, )
GLOBAL (bool, memclean, TRUE, xfree_dummy, )
/*
 * check syntaxtree for memoryproblems with xml specification
 *
 * CAUTION:
 * memcheck requires initiatilisation BEFORE anything else.
 * Therefore, we look for -d memcheck in presetup options
 * and set global.memcheck there accordingly. We re-initialise
 * global.memcheck to its existing value here for purely technical
 * reasons.
 */

GLOBAL (int, timefreq, 0, xfree_dummy, )

GLOBAL (bool, on_demand_lib, FALSE, xfree_dummy, )
/*
 * build only the tree file when compiling a module
 */

/* GLOBAL( int, linksetsize,  INT_MAX) */
GLOBAL (int, linksetsize, 10, xfree_dummy, )
/*
 * number of functions written to the same file when creating library
 * Zero means unlimited.
 */

GLOBAL (bool, cleanup, TRUE, xfree_dummy, )
/*
 * Don't remove temporary files and directory when compiling
 * module/class implementations.
 */

GLOBAL (bool, libstat, FALSE, xfree_dummy, )
/*
 * Don't actually compile, but display library information.
 */

GLOBAL (bool, print_resources, FALSE, xfree_dummy, )
/*
 * Don't actually compile, but display resource information.
 */

GLOBAL (bool, makedeps, FALSE, xfree_dummy, )
/*
 * Don't actually compile, but infer module dependencies.
 */

GLOBAL (char *, printConfig, NULL, xfree_dummy, )
/*
 * Don't actually compile, but print an entry from the config file
 */

GLOBAL (bool, gen_cccall, FALSE, xfree_dummy, )
/*
 * Generate shell script '.sac2c' in current directory
 * that contains the C compiler call produced by sac2c.
 */

GLOBAL (bool, show_syscall, FALSE, xfree_dummy, )
/*
 * Show system calls during compilation.
 */

GLOBAL (bool, lacinline, TRUE, xfree_dummy, )
/*
 * Inline LAC functions
 */

GLOBAL (int, phase_num, 0, xfree_dummy, )
/*
 * Stop compilation process after given phase.
 */

GLOBAL (compiler_phase_t, break_after_phase, PH_undefined, xfree_dummy, )
/*
 * Stop compilation process after given phase.
 */

GLOBAL (compiler_phase_t, break_after_subphase, PH_undefined, xfree_dummy, )
/*
 * Stop compilation process after given subphase.
 */

GLOBAL (compiler_phase_t, break_after_cyclephase, PH_undefined, xfree_dummy, )
/*
 * Stop compilation process after given cycle optimization.
 */

GLOBAL (int, break_cycle_specifier, 1, xfree_dummy, )
/*
 * Additional break specifier that allows a designated break within
 * a particular (optimization) loop.
 */

GLOBAL (bool, prt_cycle_range, FALSE, xfree_dummy, )
/*
 * Start printing the specific function at this phase.
 */

GLOBAL (char *, break_fun_name, NULL, xfree_dummy, )
/*
 *  break_fun_name for finding function information during a break and print
 */

GLOBAL (compiler_phase_t, prtphafun_start_phase, PH_undefined, xfree_dummy, )
/*
 * Start printing the specific function at this phase.
 */

GLOBAL (compiler_phase_t, prtphafun_start_subphase, PH_undefined, xfree_dummy, )
/*
 * Start printing the specific function at this subphase.
 */
GLOBAL (compiler_phase_t, prtphafun_start_cycle, PH_undefined, xfree_dummy, )
/*
 * Start printing the specific function at this cycle.
 */

GLOBAL (int, prtphafun_start_cycle_specifier, 1, xfree_dummy, )
/*
 * Specifies the the start pass to print within a specific cyclephase loop.
 */

GLOBAL (compiler_phase_t, prtphafun_stop_phase, PH_undefined, xfree_dummy, )
/*
 * Start printing the specific function at this phase.
 */

GLOBAL (compiler_phase_t, prtphafun_stop_subphase, PH_undefined, xfree_dummy, )
/*
 * Start printing the specific function at this subphase.
 */
GLOBAL (compiler_phase_t, prtphafun_stop_cycle, PH_undefined, xfree_dummy, )
/*
 * Start printing the specific function at this cycle.
 */

GLOBAL (int, prtphafun_stop_cycle_specifier, 0, xfree_dummy, )
/*
 * Specifies the the stop pass to print within a specific cyclephase loop.
 */

GLOBAL (int, padding_overhead_limit, 10, xfree_dummy, )
/*
 * Limit for additional resource allocation due to array padding in
 * percentage. Can be modified via -aplimit option.
 */

GLOBAL (bool, apdiag, FALSE, xfree_dummy, )
/*
 * Diagnostics of array padding may be written into a file.
 * Per default no information is written. Use -apdiag to enable
 * output to "modulename.ap".
 */

GLOBAL (int, apdiag_limit, 20000, xfree_dummy, )
/*
 * Limit for size of diagnostic output given in approximate number of lines.
 * This avoids the creation of extremely huge diagnostic output files.
 */

/*
 *  Compile time information system parameters
 */

GLOBAL (te_info *, act_info_chn, NULL, xfree_dummy, )
/*
 * Info chain for extended error messages during TC
 */

#ifdef PRODUCTION
GLOBAL (int, verbose_level, 1, xfree_dummy, )
#else  /* PRODUCTION */
GLOBAL (int, verbose_level, 2, xfree_dummy, )
#endif /* PRODUCTION */
       /*
        * Verbosity of compile time output
        */

GLOBAL (bool, verbose_help, FALSE, xfree_dummy, )

GLOBAL (compiler_phase_t, compiler_phase, PH_initial, xfree_dummy, )
/*
 * Counter for compilation phases
 */

GLOBAL (compiler_phase_t, compiler_subphase, PH_initial, xfree_dummy, )
/*
 * Counter for compilation subphases
 */

GLOBAL (compiler_phase_t, compiler_cyclephase, PH_initial, xfree_dummy, )
/*
 * Counter for cycle optimizations
 */

GLOBAL (compiler_phase_t, compiler_anyphase, PH_initial, xfree_dummy, )
/*
 * Counter for any kind of compiler phase/subphase/cyclephase
 */

GLOBAL (int, cycle_counter, 0, xfree_dummy, )
/*
 * Counter for current cycle, made global for improved bug report
 */

GLOBAL (node *, current_fundef, NULL, xfree_dummy, )
/*
 * Counter for any kind of compiler phase/subphase/cyclephase
 */

GLOBAL (bool, run_stabilization_cycle, FALSE, xfree_dummy, )
/*
 * only run stabilization cycle if main cycle pass limit exhausted
 */

GLOBAL (size_t, linenum, 1, xfree_dummy, )
/*
 * Current line number
 */

GLOBAL (size_t, colnum, 1, xfree_dummy, )
/*
 * Current column number
 */

GLOBAL (char *, filename, NULL, xfree_dummy, )
/*
 * Current file name
 */

/*
 * DBUG options
 */

GLOBAL (compiler_phase_t, my_dbug_from, PH_initial, xfree_dummy, )
GLOBAL (compiler_phase_t, my_dbug_to, PH_final, xfree_dummy, )
GLOBAL (bool, my_dbug, FALSE, xfree_dummy, )
GLOBAL (bool, my_dbug_active, FALSE, xfree_dummy, )
GLOBAL (char *, my_dbug_str, NULL, xfree_dummy, )

/*
 * for arg tags
 */

GLOBAL (bool *, argtag_has_shp, argtag_has_shp_init, xfree_dummy, )
GLOBAL (bool *, argtag_has_rc, argtag_has_rc_init, xfree_dummy, )
GLOBAL (bool *, argtag_has_desc, argtag_has_desc_init, xfree_dummy, )
GLOBAL (bool *, argtag_is_in, argtag_is_in_init, xfree_dummy, )
GLOBAL (bool *, argtag_is_out, argtag_is_out_init, xfree_dummy, )
GLOBAL (bool *, argtag_is_inout, argtag_is_inout_init, xfree_dummy, )
GLOBAL (const char **, argtag_string, argtag_string_init, xfree_dummy, )

/*
 * Special purpose global variables
 */

GLOBAL (bool, print_objdef_for_header_file, FALSE, xfree_dummy, )
/*
 *  This global variable serves a very special purpose.
 *  When generating separate C-files for functions and global variables,
 *  a header file is required which contains declarations of them all.
 *  In this case the ICM ND_KS_DECL_GLOBAL_ARRAY must be written
 *  differently. This global variable triggers the respective print
 *  function defined in icm2c.c. It is set by PrintModul.
 */

GLOBAL (int, object_counter, 0, xfree_dummy, )
/*
 *  This global variable is used whenever the objectinitflags of a module
 *  are written to separate files.
 */

GLOBAL (size_t, indent, 0, xfree_dummy, )
/*
 *  This global variable is used for indenting while printing SAC-code.
 *  It has to be made global since printing is not only done in the printing-
 *  directory but from within icm2c_xxx.c as well!
 */

GLOBAL (const size_t *, basetype_size, basetype_size_init, xfree_dummy, )
/*
 * This array of integers keeps the lengths of all simpletypes.
 * It at least is used in compile.c, tile_size_inference.c, and constants.c!
 */

GLOBAL (min_array_rep_t, min_array_rep, MAR_scl_aks, xfree_dummy, )
/*
 * This global variable can be used to restrict the set of
 * array representations used by the backend
 */

/*
 * Name tuples
 */

GLOBAL (char **, nt_shape_string, nt_shape_string_init, xfree_dummy, )
GLOBAL (char **, nt_hidden_string, nt_hidden_string_init, xfree_dummy, )
GLOBAL (char **, nt_unique_string, nt_unique_string_init, xfree_dummy, )
/* mutc */
GLOBAL (char **, nt_mutc_storage_class_string, nt_mutc_storage_class_string_init,
        xfree_dummy, )
GLOBAL (char **, nt_mutc_scope_string, nt_mutc_scope_string_init, xfree_dummy, )
GLOBAL (char **, nt_mutc_usage_string, nt_mutc_usage_string_init, xfree_dummy, )
GLOBAL (char **, nt_bitarray_string, nt_bitarray_string_init, xfree_dummy, )
GLOBAL (char **, nt_distributed_string, nt_distributed_string_init, xfree_dummy, )
GLOBAL (char **, nt_cbasetype_string, nt_cbasetype_string_init, xfree_dummy, )
/*
 * These character arrays are the macro-name-parts used to select
 * array class and array uniqueness properties.
 */

GLOBAL (const char **, backend_string, backend_string, xfree_dummy, )
/*
 * Primitive zip function tables, previously defined in zipcv.c
 */

GLOBAL (const zipcvfunptr *, zipcv_plus, zipcv_plus_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_minus, zipcv_minus_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_mul, zipcv_mul_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_div, zipcv_div_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_mod, zipcv_mod_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_min, zipcv_min_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_max, zipcv_max_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_and, zipcv_and_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_or, zipcv_or_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_eq, zipcv_eq_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_neq, zipcv_neq_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_le, zipcv_le_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_lt, zipcv_lt_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_gt, zipcv_gt_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_ge, zipcv_ge_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_not, zipcv_not_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_tob, zipcv_tob_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_tos, zipcv_tos_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_toc, zipcv_toc_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_tobool, zipcv_tobool, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_toi, zipcv_toi_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_tol, zipcv_tol_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_toll, zipcv_toll_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_toub, zipcv_toub_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_tous, zipcv_tous_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_toui, zipcv_toui_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_toul, zipcv_toul_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_toull, zipcv_toull_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_tof, zipcv_tof_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_tod, zipcv_tod_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_abs, zipcv_abs_init, xfree_dummy, )
GLOBAL (const zipcvfunptr *, zipcv_neg, zipcv_neg_init, xfree_dummy, )

/*
 * Primitive base function tables, previously defined in basecv.c
 */

GLOBAL (const basecvfunptr *, basecv_negativeone, basecv_negativeone_init, xfree_dummy, )
GLOBAL (const basecvfunptr *, basecv_zero, basecv_zero_init, xfree_dummy, )
GLOBAL (const basecvfunptr *, basecv_one, basecv_one_init, xfree_dummy, )

/*
 * Constant vector copying function table, previously defined in cv2cv.c
 */

GLOBAL (const cv2cvfunptr *, cv2cv, cv2cv_init, xfree_dummy, )

/*
 * Constant vector to scalar conversion function table, previously defined in cv2scalar.c
 */

GLOBAL (const cv2scalarfunptr *, cv2scalar, cv2scalar_init, xfree_dummy, )

/*
 * Constant vector to string conversion function table, previously defined in cv2str.c
 */

GLOBAL (const cv2strfunptr *, cv2str, cv2str_init, xfree_dummy, )

/*
 * Debug string tables
 */

GLOBAL (const char **, mdb_nodetype, mdb_nodetype_init, xfree_dummy, )
GLOBAL (const char **, mdb_type, mdb_type_init, xfree_dummy, )

/*
 * Type to string conversion tables
 */

GLOBAL (const char **, type_string, type_string_init, xfree_dummy, )
GLOBAL (const char **, rename_type, rename_type_init, xfree_dummy, )

/*
 * Type to C basetype conversion table
 */
GLOBAL (const cbasetype_class_t *, type_cbasetype, type_cbasetype_init, xfree_dummy, )

/*
 * Resource / configuration management
 */

GLOBAL (target_list_t *, target_list, NULL, xfree_dummy, )
/*
 * When the configuration files are parsed, a dynamic tree like structure
 * is generated and its root is stored in target_list. This dynamic structure
 * is afterwards processed, the relevant information is stored in the static
 * structure config, and the target_list is finally released.
 */

GLOBAL (configuration_t, config, config_init, xfree_configuration, )
/*
 * This global variable permanently stores the desired configuration
 * which is read from the sac2crc file.
 */

GLOBAL_NOINIT (char *, global_sac2crc_location, NULL, xfree_dummy, )
GLOBAL_NOINIT (char *, build_sac2crc_location, NULL, xfree_dummy, )
/*
 * These global (static) variables are used during runtime to locate the
 * sac2crc file. Because we now allow for the user to compile the
 * sac2c/sac2tex/sac4c/etc. binaries in order to `burn-in' there own
 * install paths, we can no longer use the defuncted SAC2CRC_CONF and
 * SAC2CRC_BUILD_CONF macros to search for the sac2crc file. These
 * globals are meant to be modified by launch_function_from_library
 * in sactools.h *before* we call the main function.
 */

/*
 * Storing module dependencies
 */

/* FIXME this is another place fot careful freeing.  */
GLOBAL (stringset_t *, dependencies, NULL, xfree_dummy, )

GLOBAL (bool, debug_rc, FALSE, xfree_dummy, )

/*
 * Whether to print help and exit.
 */

GLOBAL (bool, print_help_and_exit, FALSE, xfree_dummy, )

/*
 * Whether to print targets and exit.
 */

GLOBAL (bool, print_targets_and_exit, FALSE, xfree_dummy, )

/*
 * MUTC backend options
 */

GLOBAL (bool, mutc_fun_as_threads, FALSE, xfree_dummy, )
GLOBAL (bool, mutc_thread_mem, FALSE, xfree_dummy, )
GLOBAL (bool, mutc_disable_thread_mem, FALSE, xfree_dummy, )
GLOBAL (bool, mutc_benchmark, FALSE, xfree_dummy, )
GLOBAL (bool, mutc_suballoc_desc_one_level_up, FALSE, xfree_dummy, )
GLOBAL (bool, mutc_static_resource_management, FALSE, xfree_dummy, )
GLOBAL (mutc_distribution_mode_t, mutc_distribution_mode, MUTC_DMODE_default,
        xfree_dummy, )
GLOBAL (int, mutc_distribution_mode_arg, -1, xfree_dummy, )
GLOBAL (int, mutc_force_block_size, -1, xfree_dummy, )
GLOBAL (char *, mutc_force_spawn_flags, NULL, xfree_char_ptr, )
GLOBAL (int, mutc_unroll, 1, xfree_dummy, )
GLOBAL (int, mutc_rc_places, 1, xfree_dummy, )
GLOBAL (bool, mutc_rc_indirect, FALSE, xfree_dummy, )
GLOBAL (bool, mutc_seq_data_parallel, FALSE, xfree_dummy, )

/*
 * CUDA backend options
 */
GLOBAL (cuda_options_t, cuda_options, cuda_options_init, xfree_dummy, )
GLOBAL (cuda_async_mode_t, cuda_async_mode, CUDA_SYNC_DEVICE, xfree_dummy, )
GLOBAL (char *, cuda_block_spec, (char *)MEMmalloc (1024), xfree_char_ptr, )
GLOBAL (size_t, cuda_gpu_branching, 0, xfree_dummy, )
GLOBAL (enum gpu_mapping_strategy_t, gpu_mapping_strategy, Foldall, xfree_dummy, )
GLOBAL (bool, gpu_mapping_compress, TRUE, xfree_dummy, )

/*
 * DistMem backend options
 */
GLOBAL (distmem_commlib_t, distmem_commlib, DISTMEM_COMMLIB_UNKNOWN, xfree_dummy, )

/*
 * cygwin compatibility globals
 */
#if IS_CYGWIN
GLOBAL (cyg_fun_table_t *, cyg_fun_table, NULL, xfree_dummy)
/*
 * Stores a list of function pointers for compiled sac modules to call.
 * This is in order to solve a problem where a compiled module will be
 * dependant on the compiler used. See sac2ccyg.c
 */
#endif /* IS_CYGWIN */

#undef GLOBALtype
#undef GLOBALname
#undef GLOBALinit
#undef GLOBAL
#undef GLOBAL_NOINIT
