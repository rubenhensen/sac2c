#include "dependencies.h"

#include <libgen.h>

#include "globals.h"
#include "stringset.h"
#include "tree_basic.h"
#include "modulemanager.h"
#include "filemgr.h"
#include "str_buffer.h"
#include "str.h"
#include "memory.h"
#include "namespaces.h"
#include "ctinfo.h"

#define DBUG_PREFIX "DEP"
#include "debug.h"

/*
 * functions for generating the dependency table c file
 */
static void
GenerateDependencyTableHead (FILE *file)
{
    DBUG_ENTER ();

    fprintf (file, "/* generated by sac2c %s */\n\n", global.version_id);
    fprintf (file, "#include \"sac_serialize.h\"\n\n");
    fprintf (file, "void *__%s__DEPTAB( void) {\n", global.modulename);
    fprintf (file, "void *result = (void *) 0;\n");

    DBUG_RETURN ();
}

static void
GenerateDependencyTableTail (FILE *file)
{
    DBUG_ENTER ();

    fprintf (file, "return(result);\n}\n");

    DBUG_RETURN ();
}

static void *
TableEntriesFoldFun (const char *val, strstype_t kind, void *rest)
{
    str_buf *result = (str_buf *)rest;

    DBUG_ENTER ();

    switch (kind) {
    case STRS_saclib:
    case STRS_extlib:
        result = SBUFprintf ((str_buf *)rest, "result = STRSadd( \"%s\", %d, result);\n",
                             val, kind);
        break;
    default:
        break;
    }

    DBUG_RETURN (result);
}

static void
GenerateDependencyTableEntries (stringset_t *deps, FILE *file)
{
    str_buf *buffer;

    DBUG_ENTER ();

    buffer = SBUFcreate (4096);

    buffer = (str_buf *)STRSfold (&TableEntriesFoldFun, deps, buffer);

    fprintf (file, "%s", SBUFgetBuffer (buffer));

    buffer = SBUFfree (buffer);

    DBUG_RETURN ();
}

static void
GenerateDependencyTable (stringset_t *deps)
{
    FILE *file;

    DBUG_ENTER ();

    file = FMGRwriteOpen ("%s/dependencytable.c", global.tmp_dirname);

    GenerateDependencyTableHead (file);

    GenerateDependencyTableEntries (deps, file);

    GenerateDependencyTableTail (file);

    fclose (file);

    DBUG_RETURN ();
}

/*
 * functions for printing dependency information
 */
static void *
BuildDepClosFoldFun (const char *entry, strstype_t kind, void *rest)
{
    stringset_t *result = NULL;
    module_t *module;

    DBUG_ENTER ();

    DBUG_PRINT ("Adding dependencies for %s...", entry);

    if (kind == STRS_saclib) {
        module = MODMloadModule (entry);
        result = MODMgetDependencyTable (module);
        module = MODMunLoadModule (module);
    }

    result = STRSjoin ((stringset_t *)rest, result);

    DBUG_RETURN ((void *)result);
}

static stringset_t *
BuildDependencyClosure (stringset_t *deps)
{
    stringset_t *result;

    DBUG_ENTER ();

    result = (stringset_t *)STRSfold (&BuildDepClosFoldFun, deps, NULL);

    if (result != NULL) {
        /**
         * we have found some second level dependencies,
         * so next we build the closure over them.
         */
        result = BuildDependencyClosure (result);
    }

    result = STRSjoin (result, deps);

    DBUG_RETURN (result);
}

/*
 * We use a rather weird signature here to fit the framework of the
 * compiler phase mechanism.
 */
node *
DEPdoHandleDependencies (node *syntax_tree)
{
    DBUG_ENTER ();

    if ((global.filetype == FT_modimp) || (global.filetype == FT_classimp)) {
        /*
         * finally generate the dependency table.
         * we do this here as new dependencies may be introduced
         * during the compilation steps up to here
         */
        GenerateDependencyTable (global.dependencies);
    } else {
        /*
         * for programs, we build the closure of all dependencies.
         * again, we cannot do this earlier, as new dependencies
         * might have been introduced until here.
         */
        global.dependencies = BuildDependencyClosure (global.dependencies);
    }

    DBUG_RETURN (syntax_tree);
}

#undef DBUG_PREFIX
