/*****************************************************************************
 *
 * file:   DataFlowMask.c
 *
 * prefix: DFM
 *
 * description:
 *
 *   This module implements support for binary data flow masks.
 *   See the header file DataFlowMask.h for a detailed description.
 *
 *****************************************************************************/

#include <stdio.h>

#include "DataFlowMask.h"

#define DBUG_PREFIX "DFM"
#include "debug.h"

#include "globals.h"
#include "types.h"
#include "tree_basic.h"
#include "tree_compound.h"
#include "str.h"
#include "memory.h"
#include "check_mem.h"

/*******************************************************************************
 * Definition of static data, structs, and macros
 ******************************************************************************/

static size_t *access_mask_table = NULL;

struct MASK_BASE_T {
    size_t num_decls;
    size_t num_bitfields;
    node **decls;
};

struct MASK_T {
    bool is_set_by_default;
    size_t num_bitfields;
    size_t *bitfield;
    dfmask_base_t *mask_base;
};

// Call ExtendMask if the mask base expanded in size, which can happen after
// calling DFMupdateMaskBase
#define CHECK_MASK(mask)                                                       \
    if (mask->num_bitfields < mask->mask_base->num_bitfields)                  \
        ExtendMask (mask);

// Produce a boolean indicating whether the Nth bit is set
#define IS_NTH_BIT_SET(mask, position)                                         \
    (((mask)->bitfield[(position) / (8 * sizeof (size_t))]                     \
     & access_mask_table[(position) % (8 * sizeof (size_t))]) > 0)


/*******************************************************************************
 * Internal functions
 ******************************************************************************/

/*******************************************************************************
 * @fn void ExtendMask( dfmask_t *mask)
 *
 * @brief Extends the mask to match the new size of the underlying mask base
 *        by adding new bits initialized to match mask->is_set_by_default.
 * 
 ******************************************************************************/
static void
ExtendMask (dfmask_t *mask)
{
    size_t *old;
    size_t bitfield_extension;

    DBUG_ENTER ();

    DBUG_PRINT ("Extending mask from %zu to %zu entries", 
                mask->num_bitfields, mask->mask_base->num_bitfields);

    old = mask->bitfield;
    mask->bitfield = (size_t *)MEMmalloc (mask->mask_base->num_bitfields
                                          * sizeof (size_t));
    for (size_t i = 0; i < mask->num_bitfields; i++) {
        mask->bitfield[i] = old[i];
    }

    // When we extend the mask, we do so based on how it was originally
    // generated:
    // If it was generated by DFMgenMaskClear, we extend with zeroes.
    // If it was generated by DFMgenMaskSet, we extend with ones.
    bitfield_extension = mask->is_set_by_default ? ~((size_t)0) : 0;
    for (size_t i = mask->num_bitfields; 
         i < mask->mask_base->num_bitfields; i++) 
    {
        mask->bitfield[i] = bitfield_extension;
    }
    mask->num_bitfields = mask->mask_base->num_bitfields;
    old = MEMfree (old);

    DBUG_RETURN ();
}

/*******************************************************************************
 * @fn size_t SafeGetBackref( dfmask_base_t *mask_base, node *avis)
 *
 * @brief Safely retrieves the backref from the avis, testing for possible
 *        backref corruption in the process. 
 *        This is the only way the backrefs should ever be read.
 * 
 ******************************************************************************/
static size_t
SafeGetBackref (dfmask_base_t *mask_base, node *avis)
{
    size_t backref;
    DBUG_ENTER ();

    DBUG_ASSERT (mask_base != NULL, "Got NULL instead of a mask");
    DBUG_ASSERT (avis != NULL, "Got NULL instead of an avis");
    
    backref = AVIS_MASKBASEBACKREF (avis);

    DBUG_EXECUTE (if (mask_base->decls[backref] != AVIS_DECL (avis)
                      || backref < mask_base->num_decls) {
        DBUG_PRINT ("About to trigger an assertion on mask base %p:", 
                    (void *)mask_base);
        DFMprintMaskBase (stderr, mask_base);
    });

    DBUG_ASSERT (backref < mask_base->num_decls, 
                "Identifier not present in mask: %s. Backref refers to position"
                " %zu, but the mask contains %zu entries",
                AVIS_NAME (avis), backref, mask_base->num_decls);

    DBUG_ASSERT (mask_base->decls[backref] == AVIS_DECL (avis), 
        "Inconsistent backref entry for \"%s\": %zu relates to %s.\n"
        "The backreferences of the AVIS nodes likely got corrupted by "
        "constructing another mask base on the same function as this mask.\n"
        "Confirm this using DFMrepairMaskBaseBackrefs().\n"
        "To display the mask base, rerun the DEBUG release with -#d,DFM.",
        AVIS_NAME (avis), backref,
        mask_base->decls[backref] == NULL 
            ? "NULL" 
            : VARDEC_OR_ARG_NAME (mask_base->decls[backref])
    );

    DBUG_RETURN (backref);
}

/*******************************************************************************
 * @fn bool IsPartOfMaskBase( dfmask_base_t *mask_base, node *vardec_or_arg)
 *
 * @brief Checks whether the given vardec or arg is part of the given mask base.
 * 
 ******************************************************************************/
static bool
IsPartOfMaskBase (dfmask_base_t *mask_base, node *vardec_or_arg)
{
    size_t backref;
    bool result;

    DBUG_ENTER ();

    DBUG_ASSERT (mask_base != NULL, "Got NULL instead of a mask base");
    DBUG_ASSERT (vardec_or_arg != NULL, "Got NULL instead of a vardec or arg");
    DBUG_ASSERT (NODE_TYPE (vardec_or_arg) == N_vardec
                 || NODE_TYPE (vardec_or_arg) == N_arg,
                 "Expected a vardec or arg but got %s", 
                 NODE_TEXT (vardec_or_arg));


    // We cannot use SafeGetBackref because doing so would trigger an assertion
    // when the backref is invalid, whereas we just want to return false
    backref = AVIS_MASKBASEBACKREF (VARDEC_OR_ARG_AVIS (vardec_or_arg));

    // NOTE: Since this function is used in the update function, we cannot
    //       do ANYTHING with mask_base->decls[backref] other than a pointer
    //       equality because the arg/vardec may be freed.
    // An avis is part of the mask base if it points to a valid location
    // on the mask and the mask points back to the avis.
    result = (backref < mask_base->num_decls
              && mask_base->decls[backref] == vardec_or_arg);

    DBUG_RETURN (result);
}

/*******************************************************************************
 * @fn size_t GetMaskEntryPosClear( dfmask_t *mask)
 *
 * @brief Iterates over the positions whose bit is clear in the given mask,
 *        similar to the C library function strtok().
 *        Once no more positions are found, mask->mask_base->num_decls is 
 *        returned.
 *
 * For an extended description and example code, see the documentation of the
 * function DFMgetMaskEntryDeclClear.
 * This differs from DFMgetMaskEntryDeclClear in that this returns positions.
 *
 ******************************************************************************/
static size_t
GetMaskEntryPosClear (dfmask_t *mask)
{
    static dfmask_t *store_mask;
    static size_t i;

    DBUG_ENTER ();
    DBUG_PRINT ("Getting mask entries that are clear");

    if (mask != NULL) {
        DBUG_PRINT ("Storing mask for further calls");
        CHECK_MASK (mask);
        store_mask = mask;
        i = 0;
    }
    DBUG_ASSERT (store_mask != NULL, "Never got a non-NULL mask!");

    // Skip positions as long as we have more positions to explore and the
    // positions we encounter are set
    while ((i < store_mask->mask_base->num_decls)
           && IS_NTH_BIT_SET (store_mask, i)) {
        i++;
    }

    DBUG_RETURN (i++);
}

/*******************************************************************************
 * @fn size_t GetMaskEntryPosSet( dfmask_t *mask)
 *
 * @brief Iterates over the positions whose bit is set in the given mask,
 *        similar to the C library function strtok().
 *        Once no more positions are found, mask->mask_base->num_decls is 
 *        returned.
 *
 * For an extended description and example code, see the documentation of the
 * function DFMgetMaskEntryDeclClear.
 * This differs from DFMgetMaskEntryDeclSet in that this returns positions.
 *
 ******************************************************************************/
static size_t
GetMaskEntryPosSet (dfmask_t *mask)
{
    static dfmask_t *store_mask;
    static size_t i;

    DBUG_ENTER ();
    DBUG_PRINT ("Getting mask entries that are set");

    if (mask != NULL) {
        DBUG_PRINT ("Storing mask for further calls");
        CHECK_MASK (mask);
        store_mask = mask;
        i = 0;
    }
    DBUG_ASSERT (store_mask != NULL, "Never got a non-NULL mask!");

    // Skip positions as long as we have more positions to explore and the
    // positions we encounter are clear
    while ((i < store_mask->mask_base->num_decls)
           && !IS_NTH_BIT_SET (store_mask, i)) {
        i++;
    }

    DBUG_RETURN (i++);
}

/*******************************************************************************
 * Functions concerning mask bases
 ******************************************************************************/

/*******************************************************************************
 * @fn dfmask_base_t *DFMgenMaskBase (node *arguments, node *vardecs)
 *
 * @brief Creates a mask base from the given arguments and vardecs.
 *
 * @param arguments - An N_arg node or NULL
 * @param vardecs   - An N_vardec node or NULL
 *
 * @return A newly created mask base
 *
 ******************************************************************************/
dfmask_base_t *
DFMgenMaskBase (node *arguments, node *vardecs)
{
    dfmask_base_t *base;
    size_t access_mask;
    bool traversing_args;
    node *cur_decl;

    DBUG_ENTER ();

    DBUG_PRINT ("Creating Mask Base");

    if (access_mask_table == NULL) {
        /*
         * The first time this function is called, a so-called access mask table
         * is created. For each bit in a bit mask, implemented as size_t, a
         * particular mask, of type size_t, is generated that allows
         * extraction of one bit from a data flow mask.
         *
         */

        access_mask_table
          = (size_t *)MEMmalloc (8 * sizeof (size_t) * sizeof (size_t));
        access_mask = 1;

        for (size_t i = 0; i < 8 * sizeof (size_t); i++) {
            DBUG_PRINT ("i %zu mask %zu", i, access_mask);
            access_mask_table[i] = access_mask;
            access_mask <<= 1;
        }
    }

    base = (dfmask_base_t *)MEMmalloc (sizeof (dfmask_base_t));
    base->num_decls = TCcountArgs (arguments) + TCcountVardecs (vardecs);
    base->decls = (node **)MEMmalloc (base->num_decls * sizeof (node *));    
    base->num_bitfields = (base->num_decls / (sizeof (size_t) * 8)) + 1;

    DBUG_PRINT ("Number of bitfields is %zu", base->num_bitfields);

    // We traverse the arg + vardec chains to populate the mask base
    // and assign backreferences.
    traversing_args = arguments != NULL;
    cur_decl = traversing_args ? arguments : vardecs;
    for (size_t i = 0; cur_decl != NULL;) {
        DBUG_ASSERT (VARDEC_OR_ARG_AVIS (cur_decl) != NULL,
                     "Got a declaration without an avis");
        DBUG_PRINT_TAG ("DFM_GEN", "Adding %s %s as element #%zu",
                        NODE_TEXT (cur_decl), 
                        AVIS_NAME (VARDEC_OR_ARG_AVIS (cur_decl)),
                        i);

        // Assign forward and backreference
        base->decls[i] = cur_decl;        
        AVIS_MASKBASEBACKREF (VARDEC_OR_ARG_AVIS (cur_decl)) = i;

        // Continue iterating from args to vardecs when the args chain runs out
        cur_decl = VARDEC_OR_ARG_NEXT (cur_decl);
        i++;
        if (cur_decl == NULL && traversing_args) {
            cur_decl = vardecs;
            traversing_args = false;
        }
    }

    DBUG_PRINT ("Created mask base at pointer %p", (void *)base);
    DBUG_RETURN (base);
}

/*******************************************************************************
 * @fn dfmask_base_t *DFMupdateMaskBase( dfmask_base_t *mask_base, 
 *                                     node *arguments, node *vardecs)
 *
 * @brief Updates the mask base, to include ONLY the given arguments and vardecs
 *        Declarations present in the mask base that aren't in the arguments and
 *        vardecs are set to NULL.
 *        For declarations not present in the mask base that are part of the 
 *        arguments or vardecs, 
 *        New memory is allocated to the mask base such that declarations not 
 *        present in the mask base that are part of arguments or vardecs can be
 *        appended to the mask base.
 * 
 ******************************************************************************/
dfmask_base_t *
DFMupdateMaskBase (dfmask_base_t *mask_base, node *arguments, node *vardecs)
{
    size_t new_num_decls;
    dfmask_t *usage_mask;
    bool traversing_args;
    node **new_decls;

    DBUG_ENTER ();

    DBUG_PRINT ("Updating mask base %p", (void *)mask_base);
    DBUG_ASSERT (mask_base != NULL, "Got NULL instead of a mask base");
    // We start counting the required number of decls at the previous number
    new_num_decls = mask_base->num_decls;

    // We create a new mask on the existing mask base
    // We use this to figure out which existing decls are still
    // used and which of them became stale.
    usage_mask = DFMgenMaskClear (mask_base);
    
    // We traverse the arg + vardec chains to populate the usage_mask and
    // count the required size for the update mask base:
    //    If the backref is part of the mask base, set the value in the mask
    //    Else, it is a new decl so we increase new_num_decls by one
    traversing_args = arguments != NULL;
    for (node *cur_decl = traversing_args ? arguments : vardecs; 
         cur_decl != NULL;) 
    {
        if (IsPartOfMaskBase (mask_base, cur_decl)) {
            DFMsetMaskEntrySet (usage_mask, VARDEC_OR_ARG_AVIS (cur_decl));
        } else {
            new_num_decls++;
        }

        // Continue iterating from args to vardecs when the args chain runs out
        cur_decl = VARDEC_OR_ARG_NEXT (cur_decl);
        if (cur_decl == NULL && traversing_args) {
            cur_decl = vardecs;
            traversing_args = false;
        }
    }
    DBUG_PRINT ("Original num_decls: %zu\t"
                "Unused decls: %d\t"
                "New num_decls: %zu", 
                mask_base->num_decls, 
                (int)mask_base->num_decls - DFMtestMask (usage_mask),
                new_num_decls);

    // We traverse the newly created mask:
    //    For values that aren't set, we replace the avis in the maskbase
    //    with NULL
    //    We cannot remove the backref since the pointer to the avis has
    //    likely already been freed.
    for (size_t unused_decl = GetMaskEntryPosClear (usage_mask); 
         unused_decl != usage_mask->mask_base->num_decls; 
         unused_decl = GetMaskEntryPosClear (NULL)) 
    {
        mask_base->decls[unused_decl] = NULL;
    }
    usage_mask = DFMremoveMask (usage_mask);

    // We allocate space for new_num_decls
    new_decls = (node **)MEMmalloc (new_num_decls * sizeof (node *));
    
    // We copy over the old declarations
    for (size_t i = 0; i < mask_base->num_decls; i++) {
        new_decls[i] = mask_base->decls[i];
    }

    // We retraverse arg + vardec chains to add the ones that hadn't been
    // added yet to the new decls
    // The pos starts at the end of the previous mask
    size_t pos = mask_base->num_decls; 
    traversing_args = arguments != NULL;
    for (node *cur_decl = traversing_args ? arguments : vardecs;
         cur_decl != NULL;) 
    {
        if (!IsPartOfMaskBase (mask_base, cur_decl)) {
            // If a declaration wasn't part of the mask base yet, add it to
            // the mask base and assign the backreference, then increase
            // the pos.
            new_decls[pos] = cur_decl;
            AVIS_MASKBASEBACKREF (VARDEC_OR_ARG_AVIS (cur_decl)) = pos;
            pos++;
        }

        // Continue iterating from args to vardecs when the args chain runs out
        cur_decl = VARDEC_OR_ARG_NEXT (cur_decl);
        if (cur_decl == NULL && traversing_args) {
            cur_decl = vardecs;
            traversing_args = false;
        }
    }
    DBUG_ASSERT (pos == new_num_decls, 
                 "Not all arguments and vardecs were added to the mask base!"
                 " We expected to fill %zu positions but we filled %zu pos!",
                 new_num_decls, pos);

    // We set the number of bitfields
    mask_base->num_bitfields = (new_num_decls / (sizeof (size_t) * 8)) + 1;
    DBUG_PRINT ("Number of bitfields is %zu", mask_base->num_bitfields);

    // Free the old decls and assign the new declarations to the mask base
    mask_base->decls = MEMfree (mask_base->decls);
    mask_base->decls = new_decls;
    mask_base->num_decls = new_num_decls;

    DBUG_RETURN (mask_base);
}

/*******************************************************************************
 * @fn dfmask_base_t *DFMremoveMaskBase( dfmask_base_t *mask_base)
 *
 * @brief Frees a the given mask base. 
 *        Masks generated from the mask base have to be freed separately.
 *
 ******************************************************************************/
dfmask_base_t *
DFMremoveMaskBase (dfmask_base_t *mask_base)
{
    DBUG_ENTER ();

    DBUG_PRINT ("Removing mask base %p", (void *)mask_base);

    DBUG_ASSERT (mask_base != NULL, "Got NULL instead of a mask base");

    mask_base->num_decls = 0;
    mask_base->num_bitfields = 0;

    mask_base->decls = MEMfree (mask_base->decls);
    mask_base = MEMfree (mask_base);

    DBUG_RETURN (mask_base);
}

/*******************************************************************************
 * @fn void *DFMrepairMaskBaseBackrefs( dfmask_base_t *mask_base)
 *
 * @brief Repairs AVIS_MASKBASEBACKREF for all AVISes present in the given 
 *        maskbase by making them point to their location in the mask base.
 * 
 * When a mask base is made, AVIS_MASKBASEBACKREF is set for all avises in the
 * mask base. This means that the backreferences for the avises in previous
 * mask bases and the masks that stem from these bases get corrupted.
 * To use the old masks and mask bases after generating a new mask base, the 
 * avises first have to have their backreferences restored, which this function
 * does for the given mask base.
 *
 * NOTE: Instead of using this function, your problem can likely be solved by
 *       storing your mask base in the DFM_BASE attribute of a fundef node.
 *       You can use this function to quickly check whether that's the case,
 *       but ideally you don't end up using this.
 * 
 ******************************************************************************/
void
DFMrepairMaskBaseBackrefs (dfmask_base_t *mask_base)
{
    DBUG_ENTER ();

    for (size_t i = 0; i < mask_base->num_decls; i++) {
        if (mask_base->decls[i] != NULL) {
            AVIS_MASKBASEBACKREF (VARDEC_OR_ARG_AVIS (mask_base->decls[i])) = i;
        }
    }

    DBUG_RETURN ();
}

/*******************************************************************************
 * @fn void DFMtouchMaskBase( dfmask_base_t *mask_base, info *arg_info)
 *
 * @brief Touches the mask base.
 *
 * What this does is lost to time, but it seems to have something to do
 * with the check_mem.c module.
 *
 ******************************************************************************/
void
DFMtouchMaskBase (dfmask_base_t *mask_base, info *arg_info)
{
    DBUG_ENTER ();

    DBUG_PRINT ("Touching mask base %p", (void *)mask_base);

    DBUG_ASSERT (mask_base != NULL, "Got NULL instead of a mask base");

    CHKMtouch (mask_base->decls, arg_info);
    CHKMtouch (mask_base, arg_info);

    DBUG_RETURN ();
}

/*******************************************************************************
 * @fn dfmask_base_t *DFMgetMaskBase (dfmask_t *mask)
 *
 * @brief Retrieves the mask base from the given mask.
 *
 ******************************************************************************/
dfmask_base_t *
DFMgetMaskBase (dfmask_t *mask)
{
    DBUG_ENTER ();

    DBUG_RETURN (mask->mask_base);
}

/*******************************************************************************
 * Functions for generating new masks
 ******************************************************************************/

/*******************************************************************************
 * @fn dfmask_t *genUninitializedMask( dfmask_base_t *mask_base, 
 *                                   bool is_set_by_default)
 *
 * @brief Creates a new mask from the given mask base, without assigning values
 *        to the bitfield.
 * 
 ******************************************************************************/
static dfmask_t *
genUninitializedMask (dfmask_base_t *mask_base, bool is_set_by_default)
{
    dfmask_t *new_mask;

    DBUG_ENTER ();
    DBUG_ASSERT (mask_base != NULL, "Got NULL instead of a mask base");

    new_mask = (dfmask_t *)MEMmalloc (sizeof (dfmask_t));

    new_mask->is_set_by_default = is_set_by_default;
    new_mask->num_bitfields = mask_base->num_bitfields;
    new_mask->mask_base = mask_base;

    DBUG_PRINT ("Allocating %zu bitfields", new_mask->num_bitfields);
    new_mask->bitfield = (size_t *)MEMmalloc (new_mask->num_bitfields 
                                              * sizeof (size_t));

    DBUG_RETURN (new_mask);
}

/*******************************************************************************
 * @fn dfmask_t *genInitializedMask( dfmask_base_t *mask_base, 
 *                                 bool is_set_by_default)
 *
 * @brief Create a new mask from the given mask base, with values initialized
 *        that match the is_set_by_default argument.
 * 
 ******************************************************************************/
static dfmask_t *
genInitializedMask (dfmask_base_t *mask_base, bool is_set_by_default)
{
    dfmask_t *new_mask;
    size_t initial_bitfield;

    DBUG_ENTER ();
    new_mask = genUninitializedMask (mask_base, is_set_by_default);

    // Initialize the mask with ones if is_set_by_default, else zeroes.
    initial_bitfield = new_mask->is_set_by_default ? ~((size_t)0) : 0;
    for (size_t i = 0; i < new_mask->mask_base->num_bitfields; i++) 
    {
        new_mask->bitfield[i] = initial_bitfield;
    }

    DBUG_RETURN (new_mask);
}

/*******************************************************************************
 * @fn dfmask_t *DFMgenMaskClear( dfmask_base_t *mask_base)
 *
 * @brief Create a new mask from the given mask base, with values all values
 *        set to 0, representing a cleared bit.
 * 
 ******************************************************************************/
dfmask_t *
DFMgenMaskClear (dfmask_base_t *mask_base)
{
    dfmask_t *new_mask;

    DBUG_ENTER ();
    DBUG_PRINT ("Generating a cleared mask");

    new_mask = genInitializedMask (mask_base, false);

    DBUG_RETURN (new_mask);
}

/*******************************************************************************
 * @fn dfmask_t *DFMgenMaskSet( dfmask_base_t *mask_base)
 *
 * @brief Create a new mask from the given mask base, with values all values
 *        set to 1, representing a set bit.
 * 
 ******************************************************************************/
dfmask_t *
DFMgenMaskSet (dfmask_base_t *mask_base)
{
    dfmask_t *new_mask;

    DBUG_ENTER ();
    DBUG_PRINT ("Generating a set mask");

    new_mask = genInitializedMask (mask_base, true);
    
    DBUG_RETURN (new_mask);
}

/*******************************************************************************
 * @fn dfmask_t *DFMgenMaskCopy( dfmask_t *mask)
 *
 * @brief Create an identical copy of the given mask.
 * 
 ******************************************************************************/
dfmask_t *
DFMgenMaskCopy (dfmask_t *mask)
{
    dfmask_t *new_mask;

    DBUG_ENTER ();
    DBUG_PRINT ("Generating a copy of a mask");
    DBUG_ASSERT (mask != NULL, "Got NULL instead of a mask");

    CHECK_MASK (mask);

    new_mask = genUninitializedMask (mask->mask_base, mask->is_set_by_default);

    for (size_t i = 0; i < new_mask->num_bitfields; i++) {
        new_mask->bitfield[i] = mask->bitfield[i];
    }

    DBUG_RETURN (new_mask);
}

/*******************************************************************************
 * @fn dfmask_t *DFMgenMaskInv( dfmask_t *mask)
 *
 * @brief Create an inverted copy of the given mask such that all values in the
 *        new mask are the inverse of the original.
 * 
 * NOTE: The new mask has the opposite default bit as the original mask.
 *       E.g. if the default in the original mask is Clear, it will be Set in
 *       the new mask.
 * 
 ******************************************************************************/
dfmask_t *
DFMgenMaskInv (dfmask_t *mask)
{
    dfmask_t *new_mask;

    DBUG_ENTER ();
    DBUG_PRINT ("Generating an inverted copy of a mask");
    DBUG_ASSERT (mask != NULL, "Got NULL instead of a mask");

    CHECK_MASK (mask);

    new_mask = genUninitializedMask (mask->mask_base, !mask->is_set_by_default);

    for (size_t i = 0; i < new_mask->num_bitfields; i++) {
        new_mask->bitfield[i] = ~(mask->bitfield[i]);
    }

    DBUG_RETURN (new_mask);
}

/*******************************************************************************
 * @fn dfmask_t *DFMgenMaskAnd( dfmask_t *mask1, dfmask_t *mask2)
 *
 * @brief Create a new mask from the given masks with all bits set to the
 *        bitwise AND of the bits in both masks.
 *
 ******************************************************************************/
dfmask_t *
DFMgenMaskAnd (dfmask_t *mask1, dfmask_t *mask2)
{
    dfmask_t *new_mask;

    DBUG_ENTER ();
    DBUG_PRINT ("Generating a bitwise-and copy of two masks");
    DBUG_ASSERT (mask1 != NULL, "Got NULL instead of mask1");
    DBUG_ASSERT (mask2 != NULL, "Got NULL instead of mask2");
    DBUG_ASSERT (mask1->mask_base == mask2->mask_base, "Combining incompatible masks");
    DBUG_ASSERT (mask1->is_set_by_default == mask2->is_set_by_default,
                "mask1 and mask2 must both be set by default or both be clear"
                " by default");

    CHECK_MASK (mask1);
    CHECK_MASK (mask2);

    new_mask = genUninitializedMask (mask1->mask_base, mask1->is_set_by_default);

    for (size_t i = 0; i < new_mask->num_bitfields; i++) {
        new_mask->bitfield[i] = mask1->bitfield[i] & mask2->bitfield[i];
    }

    DBUG_RETURN (new_mask);
}

/*******************************************************************************
 * @fn dfmask_t *DFMgenMaskOr( dfmask_t *mask1, dfmask_t *mask2)
 *
 * @brief Create a new mask from the given masks with all bits set to the
 *        bitwise OR of the bits in both masks.
 *
 ******************************************************************************/
dfmask_t *
DFMgenMaskOr (dfmask_t *mask1, dfmask_t *mask2)
{
    dfmask_t *new_mask;

    DBUG_ENTER ();
    DBUG_PRINT ("Generating a bitwise-or copy of two masks");
    DBUG_ASSERT (mask1 != NULL, "Got NULL instead of mask1");
    DBUG_ASSERT (mask2 != NULL, "Got NULL instead of mask2");
    DBUG_ASSERT (mask1->mask_base == mask2->mask_base, "Combining incompatible masks");
    DBUG_ASSERT (mask1->is_set_by_default == mask2->is_set_by_default,
                "mask1 and mask2 must both be set by default or both be clear"
                " by default");

    CHECK_MASK (mask1);
    CHECK_MASK (mask2);

    new_mask = genUninitializedMask (mask1->mask_base, mask1->is_set_by_default);

    for (size_t i = 0; i < new_mask->num_bitfields; i++) {
        new_mask->bitfield[i] = mask1->bitfield[i] | mask2->bitfield[i];
    }

    DBUG_RETURN (new_mask);
}

/*******************************************************************************
 * @fn dfmask_t *DFMgenMaskMinus( dfmask_t *mask1, dfmask_t *mask2)
 *
 * @brief Create a new mask from the given masks with all bits set to the
 *        inverted bitwise AND of the bits in both masks.
 *
 ******************************************************************************/
dfmask_t *
DFMgenMaskMinus (dfmask_t *mask1, dfmask_t *mask2)
{
    dfmask_t *new_mask;

    DBUG_ENTER ();

    DBUG_PRINT ("Generating an inverted bitwise-and copy of two masks");
    DBUG_ASSERT (mask1 != NULL, "Got NULL instead of mask1");
    DBUG_ASSERT (mask2 != NULL, "Got NULL instead of mask2");
    DBUG_ASSERT (mask1->mask_base == mask2->mask_base, "Combining incompatible masks");
    DBUG_ASSERT (mask1->is_set_by_default == mask2->is_set_by_default,
                "mask1 and mask2 must both be set by default or both be clear"
                " by default");

    CHECK_MASK (mask1);
    CHECK_MASK (mask2);

    new_mask = genUninitializedMask (mask1->mask_base, mask1->is_set_by_default);

    for (size_t i = 0; i < new_mask->num_bitfields; i++) {
        new_mask->bitfield[i] = mask1->bitfield[i] & ~(mask2->bitfield[i]);
    }

    DBUG_RETURN (new_mask);
}

/*******************************************************************************
 * @fn dfmask_t *DFMgenMaskXor( dfmask_t *mask1, dfmask_t *mask2)
 *
 * @brief Create a new mask from the given masks with all bits set to the
 *        bitwise XOR of the bits in both masks.
 *
 ******************************************************************************/
dfmask_t *
DFMgenMaskXor (dfmask_t *mask1, dfmask_t *mask2)
{
    dfmask_t *new_mask;

    DBUG_ENTER ();
    DBUG_PRINT ("Generating a bitwise-xor copy of two masks");
    DBUG_ASSERT (mask1 != NULL, "Got NULL instead of mask1");
    DBUG_ASSERT (mask2 != NULL, "Got NULL instead of mask2");
    DBUG_ASSERT (mask1->mask_base == mask2->mask_base, "Combining incompatible masks");
    DBUG_ASSERT (mask1->is_set_by_default == mask2->is_set_by_default,
                "mask1 and mask2 must both be set by default or both be clear"
                " by default");

    CHECK_MASK (mask1);
    CHECK_MASK (mask2);

    new_mask = genUninitializedMask (mask1->mask_base, mask1->is_set_by_default);

    for (size_t i = 0; i < new_mask->num_bitfields; i++) {
        new_mask->bitfield[i] ^= mask2->bitfield[i];
    }

    DBUG_RETURN (new_mask);
}

/*******************************************************************************
 * Functions for updating all bits in existing masks
 ******************************************************************************/

/*******************************************************************************
 * @fn void *DFMsetMaskClear( dfmask_t *mask)
 *
 * @brief Sets all values in the given mask to 0, representing a cleared bit.
 * 
 ******************************************************************************/
void
DFMsetMaskClear (dfmask_t *mask)
{
    DBUG_ENTER ();
    DBUG_PRINT ("Clearing all values for mask");
    DBUG_ASSERT (mask != NULL, "Got NULL instead of a mask");

    CHECK_MASK (mask);

    for (size_t i = 0; i < mask->num_bitfields; i++) {
        mask->bitfield[i] = 0;
    }

    DBUG_RETURN ();
}

/*******************************************************************************
 * @fn void *DFMsetMaskSet( dfmask_t *mask)
 *
 * @brief Sets all values in the given mask to 1, representing a set bit.
 * 
 ******************************************************************************/
void
DFMsetMaskSet (dfmask_t *mask)
{
    DBUG_ENTER ();
    DBUG_PRINT ("Setting all values for mask");
    DBUG_ASSERT (mask != NULL, "Got NULL instead of a mask");

    CHECK_MASK (mask);

    for (size_t i = 0; i < mask->num_bitfields; i++) {
        mask->bitfield[i] = ~((size_t)0);
    }

    DBUG_RETURN ();
}

/*******************************************************************************
 * @fn void *DFMsetMaskCopy( dfmask_t *mask, dfmask_t *mask2)
 *
 * @brief Sets all values in the given mask to equal the bits in the second mask
 *        such that mask is a copy of mask2.
 * 
 ******************************************************************************/
void
DFMsetMaskCopy (dfmask_t *mask, dfmask_t *mask2)
{
    DBUG_ENTER ();
    DBUG_PRINT ("Copying mask2 into mask");
    DBUG_ASSERT (mask != NULL, "Got NULL instead of a mask");
    DBUG_ASSERT (mask2 != NULL, "Got NULL instead of mask2");
    DBUG_ASSERT (mask->mask_base == mask2->mask_base, "Combining incompatible masks");

    CHECK_MASK (mask);
    CHECK_MASK (mask2);

    for (size_t i = 0; i < mask->num_bitfields; i++) {
        mask->bitfield[i] = mask2->bitfield[i];
    }

    DBUG_RETURN ();
}

/*******************************************************************************
 * @fn void *DFMsetMaskInv( dfmask_t *mask)
 *
 * @brief Sets all values in the given mask to the inverse of their original
 *        value.
 * 
 * NOTE: This also changes the default bit of the mask to the opposite of what
 *       it was before.
 *       E.g. if the default in the original mask is Clear, it will now be Set.
 *
 ******************************************************************************/
void
DFMsetMaskInv (dfmask_t *mask)
{
    DBUG_ENTER ();
    DBUG_PRINT ("Inverting all values of mask");
    DBUG_ASSERT (mask != NULL, "Got NULL instead of a mask");

    CHECK_MASK (mask);

    mask->is_set_by_default = !mask->is_set_by_default;
    for (size_t i = 0; i < mask->num_bitfields; i++) {
        mask->bitfield[i] = ~mask->bitfield[i];
    }

    DBUG_RETURN ();
}

/*******************************************************************************
 * @fn dfmask_t *DFMsetMaskAnd( dfmask_t *mask, dfmask_t *mask2)
 *
 * @brief Sets all values in the given mask to equal the bitwise AND of itself
 *        and the second mask.
 *
 ******************************************************************************/
void
DFMsetMaskAnd (dfmask_t *mask, dfmask_t *mask2)
{
    DBUG_ENTER ();
    DBUG_PRINT ("Assigning bitwise AND of mask and mask2 to mask");
    DBUG_ASSERT (mask != NULL, "Got NULL instead of a mask");
    DBUG_ASSERT (mask2 != NULL, "Got NULL instead of mask2");
    DBUG_ASSERT (mask->mask_base == mask2->mask_base, "Combining incompatible masks");

    CHECK_MASK (mask);
    CHECK_MASK (mask2);

    for (size_t i = 0; i < mask->num_bitfields; i++) {
        mask->bitfield[i] = mask->bitfield[i] & mask2->bitfield[i];
    }

    DBUG_RETURN ();
}

/*******************************************************************************
 * @fn dfmask_t *DFMsetMaskOr( dfmask_t *mask, dfmask_t *mask2)
 *
 * @brief Sets all values in the given mask to equal the bitwise OR of itself
 *        and the second mask.
 *
 ******************************************************************************/
void
DFMsetMaskOr (dfmask_t *mask, dfmask_t *mask2)
{
    DBUG_ENTER ();
    DBUG_PRINT ("Assigning bitwise OR of mask and mask2 to mask");
    DBUG_ASSERT (mask != NULL, "Got NULL instead of a mask");
    DBUG_ASSERT (mask2 != NULL, "Got NULL instead of mask2");
    DBUG_ASSERT (mask->mask_base == mask2->mask_base, "Combining incompatible masks");

    CHECK_MASK (mask);
    CHECK_MASK (mask2);

    for (size_t i = 0; i < mask->num_bitfields; i++) {
        mask->bitfield[i] = mask->bitfield[i] | mask2->bitfield[i];
    }

    DBUG_RETURN ();
}

/*******************************************************************************
 * @fn dfmask_t *DFMsetMaskMinus( dfmask_t *mask, dfmask_t *mask2)
 *
 * @brief Sets all values in the given mask to equal the inverted bitwise AND of 
 *        itself and the second mask.
 *
 ******************************************************************************/
void
DFMsetMaskMinus (dfmask_t *mask, dfmask_t *mask2)
{
    DBUG_ENTER ();
    DBUG_PRINT ("Assigning the inverted bitwise AND of mask and mask2 to mask");
    DBUG_ASSERT (mask != NULL, "Got NULL instead of a mask");
    DBUG_ASSERT (mask2 != NULL, "Got NULL instead of mask2");
    DBUG_ASSERT (mask->mask_base == mask2->mask_base, "Combining incompatible masks");

    CHECK_MASK (mask);
    CHECK_MASK (mask2);

    for (size_t i = 0; i < mask->num_bitfields; i++) {
        mask->bitfield[i] = mask->bitfield[i] & ~(mask2->bitfield[i]);
    }

    DBUG_RETURN ();
}

/*******************************************************************************
 * @fn dfmask_t *DFMsetMaskXor( dfmask_t *mask, dfmask_t *mask2)
 *
 * @brief Sets all values in the given mask to equal the bitwise XOR of itself
 *        and the second mask.
 *
 ******************************************************************************/
void
DFMsetMaskXor (dfmask_t *mask, dfmask_t *mask2)
{
    DBUG_ENTER ();
    DBUG_PRINT ("Assigning bitwise XOR of mask and mask2 to mask");
    DBUG_ASSERT (mask != NULL, "Got NULL instead of a mask");
    DBUG_ASSERT (mask2 != NULL, "Got NULL instead of mask2");
    DBUG_ASSERT (mask->mask_base == mask2->mask_base, "Combining incompatible masks");

    CHECK_MASK (mask);
    CHECK_MASK (mask2);

    for (size_t i = 0; i < mask->num_bitfields; i++) {
        mask->bitfield[i] ^= mask2->bitfield[i];
    }

    DBUG_RETURN ();
}

/*******************************************************************************
 * Functions for analying data flow masks
 ******************************************************************************/

/*******************************************************************************
 * @fn size_t DFMnumDecls( dfmask_base_t *mask_base)
 *
 * @brief Retrieves the number of declarations in the mask.
 *
 ******************************************************************************/
size_t
DFMnumDecls (dfmask_base_t *mask_base)
{
    DBUG_ENTER ();

    DBUG_ASSERT (mask_base != NULL, "Got NULL instead of a mask");

    DBUG_RETURN (mask_base->num_decls);
}

/*******************************************************************************
 * @fn size_t DFMnumBitFields( dfmask_base_t *mask_base)
 *
 * @brief Retrieves the number of bitfields in the mask.
 *
 ******************************************************************************/
size_t
DFMnumBitFields (dfmask_base_t *mask_base)
{
    DBUG_ENTER ();

    DBUG_ASSERT (mask_base != NULL, "Got NULL instead of a mask");

    DBUG_RETURN (mask_base->num_bitfields);
}

/*******************************************************************************
 * @fn int DFMtestMask( dfmask_t *mask)
 *
 * @brief Counts the number of set entries in the given mask.
 *
 ******************************************************************************/
int
DFMtestMask (dfmask_t *mask)
{
    int count;

    DBUG_ENTER ();
    DBUG_PRINT ("Testing mask %p", (void *)mask);
    DBUG_ASSERT (mask != NULL, "Got NULL instead of a mask");
    DBUG_PRINT ("num_bitfields = %zu", mask->num_bitfields);
    CHECK_MASK (mask);

    count = 0;
    for (size_t i = 0; i < mask->mask_base->num_decls; i++) {
        if (IS_NTH_BIT_SET (mask, i)) {
            count++;
        }
    }

    DBUG_ASSERT (count >= 0, "Expected %d to be non-negative", count);
    DBUG_RETURN (count);
}

/*******************************************************************************
 * @fn bool DFMtest2MaskBases( dfmask_t *mask1, dfmask_t *mask2)
 *
 * @brief Tests whether mask1 and mask2 have the same mask base
 *
 ******************************************************************************/
bool
DFMtest2MaskBases (dfmask_t *mask1, dfmask_t *mask2)
{
    DBUG_ENTER ();

    DBUG_RETURN (mask1->mask_base == mask2->mask_base);
}

/*******************************************************************************
 * @fn int DFMtest2Masks( dfmask_t *mask1, dfmask_t *mask2)
 *
 * @brief Counts the number of entries that are set in both masks for the same 
 *        decls.
 *
 ******************************************************************************/
int
DFMtest2Masks (dfmask_t *mask1, dfmask_t *mask2)
{
    int count;

    DBUG_ENTER ();
    DBUG_PRINT ("Testing two masks %p and %p", (void *)mask1, (void *)mask2);
    DBUG_ASSERT (mask1 != NULL, "Got NULL instead of mask1");
    DBUG_ASSERT (mask2 != NULL, "Got NULL instead of mask2");
    DBUG_ASSERT (mask1->mask_base == mask2->mask_base, "Combining incompatible masks");

    CHECK_MASK (mask1);
    CHECK_MASK (mask2);

    count = 0;
    for (size_t i = 0; i < mask1->mask_base->num_decls; i++) {
        if (IS_NTH_BIT_SET (mask1, i) && IS_NTH_BIT_SET (mask2, i)) {
            count++;
        }
    }

    DBUG_ASSERT (count >= 0, "Expected %d to be non-negative", count);
    DBUG_RETURN (count);
}

/*******************************************************************************
 * @fn int DFMtest3Masks( dfmask_t *mask1, dfmask_t *mask2, dfmask_t *mask3)
 *
 * @brief Counts the number of entries that are set in all three masks for the 
 * same decls.
 *
 ******************************************************************************/
int
DFMtest3Masks (dfmask_t *mask1, dfmask_t *mask2, dfmask_t *mask3)
{
    int count;

    DBUG_ENTER ();
    DBUG_PRINT ("Testing masks %p, %p, and %p", 
                (void *)mask1, (void *)mask2, (void *)mask3);
    DBUG_ASSERT (mask1 != NULL, "Got NULL instead of mask1");
    DBUG_ASSERT (mask2 != NULL, "Got NULL instead of mask2");
    DBUG_ASSERT (mask3 != NULL, "Got NULL instead of mask3");
    DBUG_ASSERT (((mask1->mask_base == mask2->mask_base)
                  && (mask1->mask_base == mask3->mask_base)),
                 "Combining incompatible masks");

    CHECK_MASK (mask1);
    CHECK_MASK (mask2);
    CHECK_MASK (mask3);

    count = 0;
    for (size_t i = 0; i < mask1->mask_base->num_decls; i++) {
        if (IS_NTH_BIT_SET (mask1, i) && IS_NTH_BIT_SET (mask2, i) 
                                      && IS_NTH_BIT_SET (mask3, i)) {
            count++;
        }
    }
    

    DBUG_ASSERT (count >= 0, "Expected %d to be non-negative", count);
    DBUG_RETURN (count);
}

/*******************************************************************************
 * @fn dfmask_t * DFMremoveMask( dfmask_t *mask)
 *
 * @brief Frees the given mask. The underlying mask base is not freed.
 *
 ******************************************************************************/
dfmask_t *
DFMremoveMask (dfmask_t *mask)
{
    DBUG_ENTER ();

    DBUG_ASSERT (mask != NULL, "Got NULL instead of a mask");

    MEMfree (mask->bitfield);
    mask = MEMfree (mask);

    DBUG_RETURN (mask);
}

/*******************************************************************************
 * @fn void DFMtouchMask( dfmask_t *mask, info *arg_info)
 *
 * @brief Touches the mask.
 *
 * What this does is lost to time, but it seems to have something to do
 * with the check_mem.c module.
 *
 ******************************************************************************/
void
DFMtouchMask (dfmask_t *mask, info *arg_info)
{
    DBUG_ENTER ();

    DBUG_ASSERT (mask != NULL, "Got NULL instead of a mask");

    CHKMtouch (mask->bitfield, arg_info);
    CHKMtouch (mask, arg_info);

    DBUG_RETURN ();
}

/*******************************************************************************
 * Functions for printing masks and mask bases
 ******************************************************************************/

/*******************************************************************************
 * @fn void DFMprintMaskNums( FILE *handle, dfmask_t *mask)
 *
 * @brief Prints the numerical overview of the given mask to the file handle.
 *
 ******************************************************************************/
void
DFMprintMaskNums (FILE *handle, dfmask_t *mask)
{
    DBUG_ENTER ();

    DBUG_ASSERT (mask != NULL, "Got NULL instead of a mask");

    fprintf (handle, "printing mask %p:\n", (void *)mask);
    fprintf (handle, "    num_bitfield: %zu\n", mask->num_bitfields);
    fprintf (handle, "       mask_base: %p\n", (void *)mask->mask_base);
    fprintf (handle, " mb num_bitfield: %zu\n", mask->mask_base->num_bitfields);

    DBUG_RETURN ();
}

/*******************************************************************************
 * @fn void DFMprintMask( FILE *handle, const char *format, dfmask_t *mask)
 *
 * @brief Prints the declarations whose bits are set to the file handle in 
 *        the given format.
 *
 ******************************************************************************/
void
DFMprintMask (FILE *handle, const char *format, dfmask_t *mask)
{
    DBUG_ENTER ();

    DBUG_PRINT ("Print mask...");

    DBUG_ASSERT (mask != NULL, "Got NULL instead of a mask");

    CHECK_MASK (mask);

    if (handle == NULL) {
        /*
         * NULL -> stderr
         * This is done for use in a debugging session.
         */
        handle = stderr;
    }

    for (size_t i = 0; i < mask->mask_base->num_decls; i++) {
        if (IS_NTH_BIT_SET (mask, i)) {
            fprintf (handle, format, 
                     VARDEC_OR_ARG_NAME (mask->mask_base->decls[i]));
        }
    }

    fprintf (handle, "\n");

    DBUG_RETURN ();
}

/*******************************************************************************
 * @fn void *DFMprintMaskBase ( FILE *handle, dfmask_base_t *mask_base)
 *
 * For debugging purposes, prints the number of decls and bitfields in the mask 
 * base.
 * For all avises, the following information is printed:
 *  1. The position in the mask base
 *  2. The pointer of the declaration
 *  3. The position as stored in the MaskBaseBackref attribute of the avis
 *  4. The name of the AVIS
 *
 * In a consistent mask base, properties 1 and 3 should be the same.
 * 
 ******************************************************************************/
void
DFMprintMaskBase (FILE *handle, dfmask_base_t *mask_base)
{
    DBUG_ENTER ();

    fprintf (handle, "Printing mask base at pointer %p:\n", (void *)mask_base);
    fprintf (handle, "num_decls: %zu\n", mask_base->num_decls);
    fprintf (handle, "num_bitfields: %zu\n", mask_base->num_bitfields);
    
    for (size_t i = 0; i < mask_base->num_decls; i++) {

        if (mask_base->decls[i] != NULL) {
            // We use AVIS_MASKBASEBACKREF in the print instead of SafeGetBackref
            // because we print for debugging purposes.
            fprintf (handle, "%zu: decl %p (%zu) %s\n", 
                i, (void *)mask_base->decls[i],
                AVIS_MASKBASEBACKREF (VARDEC_OR_ARG_AVIS (mask_base->decls[i])), 
                VARDEC_OR_ARG_NAME (mask_base->decls[i]));
        } else {
            fprintf (handle, "%zu: decl ---\n", i);
        }
    }

    DBUG_RETURN ();
}

/*******************************************************************************
 * @fn void DFMprintMaskDetailed( FILE *handle, dfmask_t *mask)
 *
 * @brief Wrapper for DFMprintMaskBase using mask instead of mask base.
 *
 ******************************************************************************/
void
DFMprintMaskDetailed (FILE *handle, dfmask_t *mask)
{
    DBUG_ENTER ();

    DFMprintMaskBase (handle, mask->mask_base);

    DBUG_RETURN ();
}

/*******************************************************************************
 * Functions for manipulating individual entries in masks
 ******************************************************************************/

/*******************************************************************************
 * @fn void DFMsetMaskEntryClear( dfmask_t *mask, node *avis)
 *
 * @brief Sets the entry for avis in the given mask to 0, representing a 
 *        cleared bit.
 *
 ******************************************************************************/
void
DFMsetMaskEntryClear (dfmask_t *mask, node *avis)
{
    size_t pos;

    DBUG_ENTER ();
    DBUG_PRINT ("Clear mask entry for N_avis %s", AVIS_NAME (avis));
    DBUG_ASSERT (mask != NULL, "Got NULL instead of a mask");
    DBUG_ASSERT (avis != NULL, "Got NULL instead of an avis");
    DBUG_PRINT ("Mask has %zu bitfields, mask base has %zu bitfields", 
                mask->num_bitfields, mask->mask_base->num_bitfields);

    CHECK_MASK (mask);

    pos = SafeGetBackref (mask->mask_base, avis);

    mask->bitfield[pos / (8 * sizeof (size_t))]
      &= ~(access_mask_table[pos % (8 * sizeof (size_t))]);

    DBUG_RETURN ();
}

/*******************************************************************************
 * @fn void DFMsetMaskEntrySet( dfmask_t *mask, node *avis)
 *
 * @brief Sets the entry for avis in the given mask to 1, representing a 
 *        set bit.
 *
 ******************************************************************************/
void
DFMsetMaskEntrySet (dfmask_t *mask, node *avis)
{
    size_t pos;

    DBUG_ENTER ();
    DBUG_PRINT ("Set mask entry for N_avis %s", AVIS_NAME (avis));
    DBUG_ASSERT (mask != NULL, "Got NULL instead of a mask");
    DBUG_ASSERT (avis != NULL, "Got NULL instead of an avis");
    DBUG_PRINT ("Mask has %zu bitfields, mask base has %zu bitfields",
                mask->num_bitfields, mask->mask_base->num_bitfields);

    CHECK_MASK (mask);

    pos = SafeGetBackref (mask->mask_base, avis);

    mask->bitfield[pos / (8 * sizeof (size_t))]
      |= access_mask_table[pos % (8 * sizeof (size_t))];

    DBUG_RETURN ();
}

/*******************************************************************************
 * @fn void DFMtestMaskEntry( dfmask_t *mask, node *avis)
 *
 * @brief Retrieves the bit for avis in the given mask.
 *
 ******************************************************************************/
bool
DFMtestMaskEntry (dfmask_t *mask, node *avis)
{
    size_t pos;
    bool res;

    DBUG_ENTER ();

    DBUG_PRINT ("Testing mask entry for avis %s", AVIS_NAME (avis));

    DBUG_ASSERT (mask != NULL, "Got NULL instead of a mask");
    DBUG_ASSERT (avis != NULL, "Got NULL instead of an avis");

    CHECK_MASK (mask);

    pos = SafeGetBackref (mask->mask_base, avis);

    res = IS_NTH_BIT_SET (mask, pos);

    DBUG_PRINT ("Mask entry for avis %s at pos %zu is %d",
                AVIS_NAME (avis), pos, res);
    DBUG_RETURN (res);
}

/*******************************************************************************
 * @fn node *DFMgetMaskEntryDeclClear (dfmask_t *mask)
 *
 * @brief Iterates over the decls whose bit is clear in the given mask, similar
 *        to the C library function strtok().
 *
 * When a mask is provided, the reference of the mask is stored and the first
 * node is retrieved. 
 * When NULL is provided, the function continues iterating over the mask,
 * returning subsequent nodes until finally NULL is returned when there are no
 * more nodes to be retrieved.
 *
 * The returned nodes can be N_vardec or N_arg nodes.
 *
 * An example of how to iterate over this:
 * 
 *   for (node *unset_decl = DFMgetMaskEntryDeclClear (your_mask_here); 
 *        unset_decl != NULL; 
 *        unset_decl = DFMgetMaskEntryDeclClear (NULL)) 
 *   {
 *       // Body using unset_decl here
 *   }
 *
 ******************************************************************************/
node *
DFMgetMaskEntryDeclClear (dfmask_t *mask)
{
    static dfmask_t *store_mask;

    node *ret;
    size_t pos;

    DBUG_ENTER ();
    DBUG_PRINT ("Getting mask entries that are clear");
    
    if (mask != NULL) {
        store_mask = mask;
    }

    pos = GetMaskEntryPosClear (mask);
    ret = (pos == store_mask->mask_base->num_decls)
          ? NULL
          : store_mask->mask_base->decls[pos];

    DBUG_RETURN (ret);
}

/*******************************************************************************
 * @fn node *DFMgetMaskEntryDeclSet (dfmask_t *mask)
 *
 * @brief Iterates over the decls whose bit is set in the given mask, similar
 *        to the C library function strtok().
 *
 * For an extended description and example code, see the documentation of the
 * function DFMgetMaskEntryDeclClear.
 *
 ******************************************************************************/
node *
DFMgetMaskEntryDeclSet (dfmask_t *mask)
{
    static dfmask_t *store_mask;

    node *ret;
    size_t pos;

    DBUG_ENTER ();
    DBUG_PRINT ("Getting mask entries that are set");
    
    if (mask != NULL) {
        store_mask = mask;
    }

    pos = GetMaskEntryPosSet (mask);
    ret = (pos == store_mask->mask_base->num_decls)
          ? NULL
          : store_mask->mask_base->decls[pos];

    DBUG_RETURN (ret);
}

/*******************************************************************************
 * @fn node *DFMgetMaskEntryAvisClear (dfmask_t *mask)
 *
 * @brief Iterates over the avises whose bit is clear in the given mask, similar
 *        to the C library function strtok().
 *
 * For an extended description and example code, see the documentation of the
 * function DFMgetMaskEntryDeclClear.
 * This differs from DFMgetMaskEntryDeclClear in that this returns avises.
 *
 ******************************************************************************/
node *
DFMgetMaskEntryAvisClear (dfmask_t *mask)
{
    node *res;

    DBUG_ENTER ();
    DBUG_PRINT ("Getting mask entries that are clear");

    res = DFMgetMaskEntryDeclClear (mask);
    res = res == NULL ? NULL : VARDEC_OR_ARG_AVIS (res);

    DBUG_RETURN (res);
}

/*******************************************************************************
 * @fn node *DFMgetMaskEntryAvisSet (dfmask_t *mask)
 *
 * @brief Iterates over the avises whose bit is set in the given mask, similar
 *        to the C library function strtok().
 *
 * For an extended description and example code, see the documentation of the
 * function DFMgetMaskEntryDeclClear.
 * This differs from DFMgetMaskEntryDeclSet in that this returns avises.
 *
 ******************************************************************************/
node *
DFMgetMaskEntryAvisSet (dfmask_t *mask)
{
    node *res;

    DBUG_ENTER ();
    DBUG_PRINT ("Getting mask entries that are set");

    res = DFMgetMaskEntryDeclSet (mask);
    res = res == NULL ? NULL : VARDEC_OR_ARG_AVIS (res);

    DBUG_RETURN (res);
}

#undef DBUG_PREFIX
