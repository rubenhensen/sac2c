/** <!--********************************************************************-->
 *
 * @defgroup gcf Generate Copy and Free
 *
 * @ingroup gcf
 *
 * @{
 *
 *****************************************************************************/

/** <!--********************************************************************-->
 *
 * @file generate_copy_and_free.c
 *
 * Prefix: GCF
 *
 *****************************************************************************/
#include "generate_copy_and_free.h"

/*
 * Other includes go here
 */

#define DBUG_PREFIX "UNDEFINED"
#include "debug.h"

#include "traverse.h"
#include "tree_basic.h"
#include "filemgr.h"
#include "globals.h"
#include "build.h"
#include "memory.h"
#include "type_utils.h"
#include "user_types.h"
#include "ctinfo.h"

/** <!--********************************************************************-->
 *
 * @name INFO structure
 * @{
 *
 *****************************************************************************/
struct INFO {
    FILE *copyfile;
    FILE *freefile;
};

#define INFO_COPYFILE(n) ((n)->copyfile)
#define INFO_FREEFILE(n) ((n)->freefile)

static info *
MakeInfo (void)
{
    info *result;

    DBUG_ENTER ();

    result = (info *)MEMmalloc (sizeof (info));

    INFO_COPYFILE (result) = NULL;
    INFO_FREEFILE (result) = NULL;

    DBUG_RETURN (result);
}

static info *
FreeInfo (info *info)
{
    DBUG_ENTER ();

    info = MEMfree (info);

    DBUG_RETURN (info);
}
/** <!--********************************************************************-->
 * @}  <!-- INFO structure -->
 *****************************************************************************/

/** <!--********************************************************************-->
 *
 * @name Entry functions
 * @{
 *
 *****************************************************************************/
/** <!--********************************************************************-->
 *
 * @fn node *TEMPdoTemplateTraversal( node *syntax_tree)
 *
 *****************************************************************************/
node *
GCFdoGenerateCopyAndFree (node *syntax_tree)
{
    info *info;

    DBUG_ENTER ();

    info = MakeInfo ();

    TRAVpush (TR_gcf);
    syntax_tree = TRAVdo (syntax_tree, info);
    TRAVpop ();

    info = FreeInfo (info);

    DBUG_RETURN (syntax_tree);
}

/** <!--********************************************************************-->
 * @}  <!-- Entry functions -->
 *****************************************************************************/

/** <!--********************************************************************-->
 *
 * @name Static helper funcions
 * @{
 *
 *****************************************************************************/

static void
PrintFileHeader (FILE *file)
{
    DBUG_ENTER ();

    fprintf (file,
             "/*\n"
             " * C interface helper functions.\n"
             " *\n"
             " * generated by sac4c %s (%s)\n"
             " */\n\n"
             "#include \"header.h\"\n\n",
             global.version_id, build_style);

    DBUG_RETURN ();
}

static void
PrintFreeHead (FILE *file)
{
    DBUG_ENTER ();

    fprintf (file, "SAC_C_EXTERN void SACARGfreeDataInternal( int btype, void *data);\n"
                   "\n");

    fprintf (file, "SAC_C_EXTERN void SACARGfreeDataUdt( int btype, void *data);\n"
                   "void SACARGfreeDataUdt( int btype, void *data)\n"
                   "{ \n"
                   "  switch( btype) {\n");

    DBUG_RETURN ();
}

static void
PrintFreeTail (FILE *file)
{
    DBUG_ENTER ();

    fprintf (file,
             "  default:\n"
             "    SAC_RuntimeError( \"No free function defined for type %%d\", btype);\n"
             "  }\n"
             "}\n\n");

    DBUG_RETURN ();
}

static void
PrintCopyHead (FILE *file)
{
    DBUG_ENTER ();

    fprintf (file,
             "SAC_C_EXTERN void *SACARGcopyDataInternal( int btype, int size, void *data);\n"
             "\n");

    fprintf (file, "SAC_C_EXTERN void *SACARGcopyDataUdt( int btype, int size, void *data);\n"
                   "void *SACARGcopyDataUdt( int btype, int size, void *data)\n"
                   "{\n"
                   "  void *result = (void *) 0;\n"
                   "\n"
                   "  switch( btype) {\n");

    DBUG_RETURN ();
}

static void
PrintCopyTail (FILE *file)
{
    DBUG_ENTER ();

    fprintf (file,
             "  default:\n"
             "    SAC_RuntimeError( \"No copy function defined for type %%d\", btype);\n"
             "  }\n"
             "\n"
             "  return( result);\n"
             "}\n\n");

    DBUG_RETURN ();
}

/** <!--********************************************************************-->
 * @}  <!-- Static helper functions -->
 *****************************************************************************/

/** <!--********************************************************************-->
 *
 * @name Traversal functions
 * @{
 *
 *****************************************************************************/

/** <!--********************************************************************-->
 *
 * @fn node *GCFtypedef(node *arg_node, info *arg_info)
 *
 * @brief Print the copy/free function part of this typedef
 *
 *****************************************************************************/
node *
GCFtypedef (node *arg_node, info *arg_info)
{
    simpletype inner;
    usertype udt;
    int btype;
    node *unaliased_tdef;

    DBUG_ENTER ();

    inner = TUgetBaseSimpleType (TYPEDEF_NTYPE (arg_node));
    udt = UTfindUserType (TYPEDEF_NAME (arg_node), TYPEDEF_NS (arg_node));

    DBUG_ASSERT (udt != UT_NOT_DEFINED, "udt for typedef not found!");

    btype = udt + global.sac4c_udt_offset;

    if (inner == T_hidden) {
        /*
         * external type, so we need to use its copy/free functions
         */
        unaliased_tdef = UTgetTdef (UTgetUnAliasedType (udt));

        fprintf (INFO_COPYFILE (arg_info), "  case %d:\n", btype);
        if (TYPEDEF_COPYFUN (unaliased_tdef) == NULL) {
            fprintf (INFO_COPYFILE (arg_info),
                     "    SAC_RuntimeError( \"No copy function defined for type "
                     "%s.\");\n",
                     CTIitemName (arg_node));

            CTIwarn (EMPTY_LOC, "No copy function defined for type `%s'. Copying SACargs "
                     "containing data of such type will fail at runtime.",
                     CTIitemName (arg_node));
        } else {
            fprintf (INFO_COPYFILE (arg_info), "    result = %s( data);\n",
                     TYPEDEF_COPYFUN (unaliased_tdef));
        }
        fprintf (INFO_COPYFILE (arg_info), "    break;\n");

        fprintf (INFO_FREEFILE (arg_info), "  case %d:\n", btype);
        if (TYPEDEF_FREEFUN (unaliased_tdef) == NULL) {
            fprintf (INFO_FREEFILE (arg_info),
                     "    SAC_RuntimeError( \"No free function defined for type "
                     "%s.\");\n",
                     CTIitemName (arg_node));

            CTIwarn (EMPTY_LOC, "No free function defined for type `%s'. Freeing SACargs "
                     "containing data of such type will fail at runtime.",
                     CTIitemName (arg_node));
        } else {
            fprintf (INFO_FREEFILE (arg_info), "    %s( data);\n",
                     TYPEDEF_FREEFUN (unaliased_tdef));
        }
        fprintf (INFO_FREEFILE (arg_info), "    break;\n");
    } else {
        /*
         * internal inner type, so we use the SAC copy/free functions
         */
        fprintf (INFO_COPYFILE (arg_info),
                 "  case %d:\n"
                 "    result = SACARGcopyDataInternal( %d, size, data);\n"
                 "    break;\n",
                 btype, inner);

        fprintf (INFO_FREEFILE (arg_info),
                 "  case %d:\n"
                 "    SACARGfreeDataInternal( %d, data);\n"
                 "    break;\n",
                 btype, inner);
    }

    TYPEDEF_NEXT (arg_node) = TRAVopt(TYPEDEF_NEXT (arg_node), arg_info);

    DBUG_RETURN (arg_node);
}

/** <!--********************************************************************-->
 *
 * @fn node *GCFmodule(node *arg_node, info *arg_info)
 *
 * @brief Print the copy/free function type indepedent parts and handle
 *        files
 *
 *****************************************************************************/
node *
GCFmodule (node *arg_node, info *arg_info)
{
    DBUG_ENTER ();

    INFO_COPYFILE (arg_info) = FMGRwriteOpen ("%s/sacargcopy%s",
                                              global.tmp_dirname,
                                              global.config.ccp_cext);
    INFO_FREEFILE (arg_info) = FMGRwriteOpen ("%s/sacargfree%s",
                                              global.tmp_dirname,
                                              global.config.ccp_cext);

    PrintFileHeader (INFO_COPYFILE (arg_info));
    PrintFileHeader (INFO_FREEFILE (arg_info));

    /*
     * print the function heads
     */
    PrintCopyHead (INFO_COPYFILE (arg_info));
    PrintFreeHead (INFO_FREEFILE (arg_info));

    /*
     * fill in the cases
     */
    MODULE_TYPES (arg_node) = TRAVopt(MODULE_TYPES (arg_node), arg_info);

    /*
     * add the bottom
     */
    PrintCopyTail (INFO_COPYFILE (arg_info));
    PrintFreeTail (INFO_FREEFILE (arg_info));

    INFO_FREEFILE (arg_info) = FMGRclose (INFO_FREEFILE (arg_info));
    INFO_COPYFILE (arg_info) = FMGRclose (INFO_COPYFILE (arg_info));

    DBUG_RETURN (arg_node);
}

/** <!--********************************************************************-->
 * @}  <!-- Traversal functions -->
 *****************************************************************************/

/** <!--********************************************************************-->
 * @}  <!-- Traversal template -->
 *****************************************************************************/

#undef DBUG_PREFIX
