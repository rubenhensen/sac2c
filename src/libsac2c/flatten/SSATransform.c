/*
 * $Id$
 *
 */

/**
 *
 * @defgroup ssatransform SSATransform
 * @ingroup ssa
 *
 * @brief  SSATransform makes all LHS within a single function unique.
 *
 *******************************************************************************
 * <pre>
 *
 * description:
 *    1) Basics:
 *    ----------
 *    This module traverses the AST and transformes the code in SSA form.
 *    In ssa-form every identifier has exactly one defining assignment
 *    in the code. So redefinitions are not allowed and lead to new
 *    identifiers (here a renamed versions of the original variables extended
 *    by the postfix __SSA<x>_<y>  where <x> and <y> are integers >= 0.
 *
 *    NB: <x> indicates how many   SSA-UndoSSA  phases have been before.
 *        <y> is just a re-definition-counter specific to each var name.
 *
 *    Example:
 *      (usual form)   -->   (ssa form)
 *
 *      int f( int a)        int f( int a)
 *      {                    {
 *        a = a + 6;           a__SSA0_1 = a + 6;
 *        b = a;               b = a__SSA0_1;
 *        b = b + 1;           b__SSA0_1 = b + 1;
 *        a = a + 1;           a__SSA0_2 = a__SSA0_1 + 1;
 *        a = a + 1;           a__SSA0_3 = a__SSA0_2 + 1;
 *        return(a + b);       return(a__SSA0_3 + b__SSA0_1);
 *      }                    }
 *
 *    2) Conditionals:
 *    ----------------
 *    In principle, conditionals can be transformed in the same fashion.
 *    However, it has to be made sure, that
 *    I)  static binding is preserved in the else branch, e.g., the
 *        RHS of line ( 9) in fact is a__SSA0_1 rather than a__SSA0_2!
 *    II) the different renamings in both branches are joined together
 *        after the conditional by introducing a functional conditional
 *        (N_funcond) node.
 *
 *    NB: the latter in fact constitutes a functionally sound representation
 *        of the phi-functions that are usually found in SSA.
 *
 *    Example:
 *          (usual form)    -->  (ssa-form)
 *
 *    ( 1)   a = 6;                a = 6;
 *    ( 2)   a = a + 4;            a__SSA0_1 = a + 4;
 *    ( 3)   b = a + a;            b = a__SSA0_1 + a__SSA0_1;
 *    ( 4)   p = b < a;            p = b < a__SSA0_1;
 *    ( 5)   if( p) {              if( p) {
 *    ( 6)     a = 0;                a__SSA0_2 = 0;
 *    ( 7)     c = 1;                c = 1;
 *    ( 8)   } else {              } else {
 *    ( 9)     c = a;                c__SSA0_1 = a__SSA0_1;
 *    (10)   }                     }
 *    (11)                         a__SSA0_3 = cond( p, a__SSA0_2, a__SSA0_1);
 *    (12)                         c__SSA0_2 = cond( p, c, c__SSA0_1);
 *    (13)   print(a + b + c);     print( a__SSA0_3 + b + c__SSA0_2);
 *
 *
 *    2) With-Loops:
 *    --------------
 *    With-loop are now (2008-09-09) treated in the same way as
 *    any other variables. Later phases, such as code generation
 *    and wltransform assume different treatment, namely that
 *    all WL generators have the same names for their index
 *    variables and IDXS variables (Do these things have a proper name?).
 *
 *    However, in order to support AVIS_MINVAL and AVIS_MAXVAL, we
 *    must have distinct names for the index variables in each
 *    WL generator. Hence, we have a conflict between distinct vs.
 *    common names. The cleaner solution, adopted here, is to
 *    enforce strict SSA at this point, giving each generator
 *    index variable its own name. We will then go and deal with
 *    the downstream code and either bring each problem
 *    area case into conformance with the distinct names
 *    in the AST, or else rename the AST fields back into non-SSA
 *    form. As of this writing, the approach taken remains
 *    unresolved.
 *
 *
 *
 * implementation:
 *    In performing a top-down traversal the "C-style" controlflow
 *    is mimicked. Renaming takes place (more precisely: MAY take place)
 *    whenever variables on RHS or LHS of assignments are traversed.
 *    ( implemented by SSArightids and SSAleftids, repectively )
 *
 *    A renaming is initiated whenever a LHS id  is found that has been
 *    previously defined or has been given as argument. This is observed
 *    by finding the flag   AVIS_SSADEFINED   true.
 *    In case of renaming, a new vardec is created (SSANewVardec) and
 *    properly inserted. The new name is generated by extending it
 *    with "__SSA<x>_<y>", where <x> is given by a global variable
 *    and <y> is a name specific counter. This counter is held in
 *    a SSACNT node which is stored as attribute of the AVIS node.
 *    All SSACNT nodes are chained as attribute of the top block of the
 *    concerning function. The counter is used in sharing for all renamed
 *    instances of one original variable. So every additional renaming of
 *    a renamed identifier gets a fresh, unique name and it is still linked
 *    with the original name (which is also stored in SSACNT as BASID
 *    attribute).
 *    After the creation and insertion of the new vardec, the avis has to be
 *    made available to all subsequent RHS uasages of the variables!
 *    This is done by storing the new AVIS (that of the renamed variable)
 *    in the old AVIS node (using AVIS_SSASTACK_TOP). So the generated
 *    structure in fact looks like this:
 *
 *     |---------------------|
 *     | Avis of "a"         | -- AVIS_SSACNT -----> |---------------------|
 *     |---------------------|                  ^    | Ssacnt: 1   "a"     |
 *               |                              |    |---------------------|
 *               |                              |
 *        AVIS_SSASTACK_TOP                     |
 *               |                              |
 *               v                              |
 *     |---------------------|                  |
 *     | Avis of "a__SSA0_1" | -- AVIS_SSACNT --/
 *     |---------------------|
 *
 *
 *    The traversal of RHS ids eventually for each id replaces the pointer to
 *    the original avis (the un-renamed old one), e.g. that to AVIS "a", by
 *    that found in AVIS_SSASTACK_TOP of it, i.e. the new, re-named one
 *    (e.g. AVIS "a__SSA0_1").
 *
 *    Unfortunately, it does not suffice to provide a single field
 *    AVIS_SSASTACK_TOP.
 *    The reason for this is the fact that conditionals and (potentially nested)
 *    with loops require these to be "reset" whenever a block is finished!!!!!
 *    Therefore, the AVIS nodes do not have an attribute SSASTACK_TOP per se,
 *    but an entire chain of AVIS nodes implemented vi SSASTACK nodes.
 *    NB: In fact, AVIS_SSASTACK_TOP constitutes a compound macro.
 *
 *    < to be continued; any volunteers??? > (SBS Thu Aug  5 21:12:55 MEST 2004)
 *
 *
 *
 * Remarks:
 *    This module requires loops and conditionals in explicit functions.
 *    This transformation has to be done by lac2fun before calling
 *    SSATransform! SSATransform can be called again to preserve the ssa-form
 *    of the AST (e.g. after old code that cannot deal with the ssa-form).
 *    After using the ssa-form the code can be cleaned up by UndoSSATransform,
 *    that e.g. removes copy assignments and renamings of global objects.
 *    Furthermore, all SSACNT nodes and SSASTACK nodes are eliminated as well.
 *
 * </pre>
 * @{
 *****************************************************************************/

#include <limits.h>

#include "types.h"
#include "tree_basic.h"
#include "tree_compound.h"
#include "node_basic.h"
#include "str.h"
#include "memory.h"
#include "dbug.h"
#include "globals.h"
#include "traverse.h"
#include "free.h"
#include "DupTree.h"
#include "SSATransform.h"
#include "ctinfo.h"
#include "new_types.h"

#define TMP_STRING_LEN 16

/* helper functions for internal usage */
static node *CreateFuncondAssign (node *cond, node *id, node *assign);
static node *TreatIdsAsRhs (node *, info *);
static node *InitSSAT (node *avis);
static node *TearDownSSAT (node *avis);

/* special ssastack operations for ONE avis-node */
static node *DupTopSsastack (node *avis);
static node *PopSsastackThen (node *avis);
static node *PopSsastackElse (node *avis);

/**
 *
 * @name The local info structure
 *
 * <!--
 * node *MakeInfo()        : constructor function
 * node *FreeInfo( node *) : destructor function
 * -->
 *
 * The local info structure contains the following fields:
 *
 * SINGLEFUNDEF     : steers how much code is to be traversed; legal values
 *                    are defined below.
 * ALLOW_GOS        : flag indicating whether global objects are potentially
 *                    contained in the code to be reformed
 * GENERATE_FUNCOND : indicates funcond generation mode rather than
 *                    renaming mode (toggled by SSAreturn)
 *
 * FUNDEF        : ptr to the actual fundef
 * ASSIGN        : ptr to the actual assign; if modified during RHS traversal
 *                 the new ptr has to be inserted and traversed again!
 * CONDSTMT      : ptr to the cond node passed by if any
 * FUNCOND_FOUND : flag indicating presence of funcond node
 * RENAME        : Triggers whether SSAid uses
 *                 AVIS_SSASTACK_TOP, AVIS_SSATHEN, or AVIS_SSAELSE
 * WITHID        : ptr to actual withid node
 * FIRST_WITHID  : ptr to the first withid node of a mgWL
 * NESTLEVEL     : counter to keep track of the degree of With-loop nesting
 */
/*@{*/

struct INFO {
    int singlefundef;
    bool allow_gos;

    bool generate_funcond;

    node *fundef;
    node *fix;
    node *assign;
    node *condstmt;
    bool funcond_found;
    enum { RN_top, RN_then, RN_else } rename;
    node *withid;
    node *first_withid;
    int nestlevel;
};

/**
 * legal values for
 * INFO_SINGLEFUNDEF :
 */
#define SSA_TRAV_FUNDEFS 0
#define SSA_TRAV_SPECIALS 1
#define SSA_TRAV_NONE 2

/*
 * access macros:
 */
#define INFO_SINGLEFUNDEF(n) (n->singlefundef)
#define INFO_ALLOW_GOS(n) (n->allow_gos)

#define INFO_GENERATE_FUNCOND(n) (n->generate_funcond)

#define INFO_FUNDEF(n) (n->fundef)
#define INFO_ASSIGN(n) (n->assign)
#define INFO_CONDSTMT(n) (n->condstmt)
#define INFO_FUNCOND_FOUND(n) (n->funcond_found)
#define INFO_RENAME(n) (n->rename)
#define INFO_FIRST_WITHID(n) (n->first_withid)
#define INFO_NESTLEVEL(n) (n->nestlevel)

/*
 * INFO functions:
 */
static info *
MakeInfo ()
{
    info *result;

    DBUG_ENTER ("MakeInfo");

    result = MEMmalloc (sizeof (info));

    INFO_SINGLEFUNDEF (result) = 0;
    INFO_ALLOW_GOS (result) = FALSE;

    INFO_GENERATE_FUNCOND (result) = FALSE;

    INFO_FUNDEF (result) = NULL;
    INFO_ASSIGN (result) = NULL;
    INFO_CONDSTMT (result) = NULL;
    INFO_FUNCOND_FOUND (result) = FALSE;
    INFO_RENAME (result) = RN_top;
    INFO_FIRST_WITHID (result) = NULL;
    INFO_NESTLEVEL (result) = 0;

    DBUG_RETURN (result);
}

static info *
FreeInfo (info *info)
{
    DBUG_ENTER ("FreeInfo");

    info = MEMfree (info);

    DBUG_RETURN (info);
}

/*@}*/

/**
 * @name SSAT traversal counter
 */
/*@{*/

/**
 * This static variable counts the number of renamings that
 * have been performed. The value is used to increment the
 * global.ssa_phase counter only of there was a renaming in
 * a SSAT traversal. The variable is incremented by
 * SSATnewVardec and checked/resetted by the different
 * traversal start functions using CheckSSATCounter.
 */
static int ssat_renamings = 0;

/** <!-- ****************************************************************** -->
 * @fn void CheckSSATCounter()
 *
 * @brief Checks whether the global SSAT renaming counter is non zero
 *        and increases the ssa-phase counter in that case. This is done
 *        to ensure disjoint names for all renamings even across multiple
 *        traversals of SSA transform.
 ******************************************************************************/
static void
CheckSSATCounter ()
{
    DBUG_ENTER ("CheckSSATCounter");

    if (ssat_renamings != 0) {
        DBUG_ASSERT ((global.ssaform_phase < INT_MAX),
                     "global.ssaform_phase overflow detected!");

        global.ssaform_phase++;
        ssat_renamings = 0;
    }

    DBUG_VOID_RETURN;
}

/** <!-- ****************************************************************** -->
 * @fn void IncSSATCounter()
 *
 * @brief Increases the global SSAT renaming counter.
 ******************************************************************************/
static void
IncSSATCounter ()
{
    DBUG_ENTER ("IncSSATCounter");

    DBUG_ASSERT ((ssat_renamings < INT_MAX), "SSATCounter overflow!");
    ssat_renamings++;

    DBUG_VOID_RETURN;
}

/*@}*/

/**
 *
 * @name Stacking mechanism support
 *
 * <!--
 * FOR_ALL_AVIS( fun , fundef )          : higher order function; maps "fun"
 *                                         to all avis nodes in the args/
 *                                         vardecs of "fundef"
 * node *DupTopSsastack(node *avis)      : push a copy of the top elem
 * node *PopSsastackThen(node *avis)     : move top elem to AVIS_SSATHEN
 * node *PopSsastackElse(node *avis)     : move top elem to AVIS_SSAELSE
 * -->
 *
 */
/*@{*/

/**
 * Higher order function for modifying all N_avis nodes of a given fundef:
 */
#define FOR_ALL_AVIS(fun, fundef)                                                        \
    {                                                                                    \
        node *vardec;                                                                    \
        node *arg;                                                                       \
                                                                                         \
        vardec = FUNDEF_VARDEC (fundef);                                                 \
        while (vardec != NULL) {                                                         \
            VARDEC_AVIS (vardec) = fun (VARDEC_AVIS (vardec));                           \
            vardec = VARDEC_NEXT (vardec);                                               \
        }                                                                                \
        arg = FUNDEF_ARGS (fundef);                                                      \
        while (arg != NULL) {                                                            \
            ARG_AVIS (arg) = fun (ARG_AVIS (arg));                                       \
            arg = ARG_NEXT (arg);                                                        \
        }                                                                                \
    }

/** <!--********************************************************************-->
 *
 * @fn static node *RemoveOldSsaStackElements(node *avis, int nestlevel)
 *
 *   @brief Removes stack elements with NESTLEVEL greater than nestlevel
 *
 ******************************************************************************/
static node *
RemoveOldSsaStackElements (node *avis, int nestlevel)
{
    DBUG_ENTER ("RemoveOldSsaStackElements");

    while ((AVIS_SSASTACK (avis) != NULL)
           && (SSASTACK_NESTLEVEL (AVIS_SSASTACK (avis)) > nestlevel)) {
        AVIS_SSASTACK (avis) = FREEdoFreeNode (AVIS_SSASTACK (avis));
    }

    DBUG_RETURN (avis);
}

/** <!--********************************************************************-->
 *
 * @fn static node *RemoveSsaStackElementsGreaterZero(node *avis)
 *
 *   @brief Removes stack elements with NESTLEVEL greater than 0
 *
 ******************************************************************************/
static node *
RemoveSsaStackElementsGreaterZero (node *avis)
{
    DBUG_ENTER ("RemoveSsaStackElementsGreaterZero");

    while ((AVIS_SSASTACK (avis) != NULL)
           && (SSASTACK_NESTLEVEL (AVIS_SSASTACK (avis)) > 0)) {
        AVIS_SSASTACK (avis) = FREEdoFreeNode (AVIS_SSASTACK (avis));
    }

    DBUG_RETURN (avis);
}

/** <!--********************************************************************-->
 *
 * @fn static node *EnsureSsaStackElement(node *avis, int nestlevel)
 *
 *   @brief Ensures SSASTACK refers to an element with NESTLEVEL == nestlevel
 *
 ******************************************************************************/
static node *
EnsureSsaStackElement (node *avis, int nestlevel)
{
    DBUG_ENTER ("EnsureSsaStackElement");

    avis = RemoveOldSsaStackElements (avis, nestlevel);

    if (AVIS_SSASTACK (avis) == NULL) {
        avis = InitSSAT (avis);
        SSASTACK_NESTLEVEL (AVIS_SSASTACK (avis)) = nestlevel;
    } else if (SSASTACK_NESTLEVEL (AVIS_SSASTACK (avis)) < nestlevel) {
        avis = DupTopSsastack (avis);
        SSASTACK_NESTLEVEL (AVIS_SSASTACK (avis)) = nestlevel;
    }

    DBUG_RETURN (avis);
}

/** <!--********************************************************************-->
 *
 * @fn static  node *DupTopSsastack(node *avis)
 *
 *   @brief Duplicates value on top of stack.
 *
 ******************************************************************************/
static node *
DupTopSsastack (node *avis)
{
    node *ssastack;

    DBUG_ENTER ("DupTopSsastack");

    if (AVIS_SSASTACK_INUSE (avis)) {
        ssastack = AVIS_SSASTACK (avis);
        AVIS_SSASTACK (avis) = TBmakeSsastack (SSASTACK_AVIS (ssastack),
                                               SSASTACK_NESTLEVEL (ssastack), ssastack);
        AVIS_SSASTACK_INUSE (avis) = TRUE;
    }

    DBUG_RETURN (avis);
}

/** <!--********************************************************************-->
 *
 * @fn static  node *PopSsastackThen(node *avis)
 *
 *   @brief Moves Top-Value of stack to AVIS_SSATHEN
 *
 ******************************************************************************/
static node *
PopSsastackThen (node *avis)
{
    DBUG_ENTER ("PopSsastackThen");

    AVIS_SSATHEN (avis) = AVIS_SSASTACK_TOP (avis);
    AVIS_SSASTACK (avis) = FREEdoFreeNode (AVIS_SSASTACK (avis));

    DBUG_RETURN (avis);
}

/** <!--********************************************************************-->
 *
 * @fn static  node *PopSsastackElse(node *avis)
 *
 *   @brief Moves Top-Value of stack to AVIS_SSATHEN
 *
 ******************************************************************************/
static node *
PopSsastackElse (node *avis)
{
    DBUG_ENTER ("PopSsastackElse");

    AVIS_SSAELSE (avis) = AVIS_SSASTACK_TOP (avis);
    AVIS_SSASTACK (avis) = FREEdoFreeNode (AVIS_SSASTACK (avis));

    DBUG_RETURN (avis);
}
/*@}*/

/**
 *
 * @name global / local code transformation / generation functions:
 *
 * <!--
 * node *SSANewVardec(node *old_vardec_or_arg)
 * node *CreateFuncondAssign( node *cond, node *id, node *assign)
 * node* InitializeFungroup(node *arg_node, info* arg_info)
 * node *InitSSAT( node *avis)
 * node *TearDownSSAT( node *avis)
 * -->
 *
 */
/*@{*/
/** <!--********************************************************************-->
 *
 * @fn node *InitSSAT(node *avis)
 *
 *   @brief Initializes AVIS_SSASTACK with an empty stack
 *
 ******************************************************************************/
static node *
InitSSAT (node *avis)
{
    DBUG_ENTER ("InitSSAT");

    DBUG_PRINT ("SSA", ("Initialising stack for %s.", AVIS_NAME (avis)));

    AVIS_SSASTACK (avis) = TBmakeSsastack (NULL, 0, NULL);

    DBUG_RETURN (avis);
}

/** <!--********************************************************************-->
 *
 * @fn node *TearDownSSAT(node *avis)
 *
 *   @brief Removes the AVIS_SSASTACK and sets AVIS_SSACNT to NULL
 *
 ******************************************************************************/
static node *
TearDownSSAT (node *avis)
{
    DBUG_ENTER ("TearDownSSAT");

    AVIS_SSASTACK (avis) = FREEdoFreeTree (AVIS_SSASTACK (avis));
    AVIS_SSATHEN (avis) = NULL;
    AVIS_SSAELSE (avis) = NULL;
    AVIS_SSACOUNT (avis) = NULL;

    DBUG_RETURN (avis);
}

/** <!--********************************************************************-->
 *
 * @fn node *CreateFuncondAssign( node *cond, node *id, node *assign)
 *
 *   @brief create a funcond assignment of the form
 *             <id> = cond( <p>, <id>, <id>)
 *             where <id> is the identifier behind "id" and
 *                   <p> is the predicate variable behind cond
 *          and prepend it to "assign".
 *
 *          We do NOT need to deal with renaming here, as the traversal
 *          mechanism will be run on it anyways.
 *
 ******************************************************************************/
static node *
CreateFuncondAssign (node *cond, node *id, node *assign)
{
    node *funcond;
    node *new_assign;

    DBUG_ENTER ("CreateFuncondAssign");

    funcond = TBmakeFuncond (DUPdoDupTree (COND_COND (cond)), DUPdoDupTree (id),
                             DUPdoDupTree (id));

    new_assign
      = TBmakeAssign (TBmakeLet (TBmakeIds (ID_AVIS (id), NULL), funcond), assign);

    DBUG_RETURN (new_assign);
}

/*@}*/

/**
 *
 * @name Traversal functions:
 *
 */
/*@{*/
/** <!--********************************************************************-->
 *
 * @fn node *SSATfundef(node *arg_node, info *arg_info)
 *
 *   @brief traverses args and block of fundef in this order
 *
 ******************************************************************************/
node *
SSATfundef (node *arg_node, info *arg_info)
{
    DBUG_ENTER ("SSATfundef");

    /*
     * process only fundefs with body
     */

    INFO_CONDSTMT (arg_info) = NULL;
    INFO_FUNCOND_FOUND (arg_info) = FALSE;

    if (FUNDEF_BODY (arg_node) != NULL) {
        /* stores access points for later insertions in this fundef */
        INFO_FUNDEF (arg_info) = arg_node;

        /*
         * Attach SSAStacks to all AVIS nodes
         */
        FOR_ALL_AVIS (InitSSAT, arg_node);

        FUNDEF_ARGS (arg_node) = TRAVopt (FUNDEF_ARGS (arg_node), arg_info);
        FUNDEF_BODY (arg_node) = TRAVopt (FUNDEF_BODY (arg_node), arg_info);

        /*
         * Remove SSAStacks and set SSACnt to NULL
         */
        FOR_ALL_AVIS (TearDownSSAT, arg_node);

        /*
         * Remove all SSACNT nodes stored in the top-level block
         */
        if (BLOCK_SSACOUNTER (FUNDEF_BODY (arg_node)) != NULL) {
            BLOCK_SSACOUNTER (FUNDEF_BODY (arg_node))
              = FREEdoFreeTree (BLOCK_SSACOUNTER (FUNDEF_BODY (arg_node)));
        }
    }

    /* traverse next fundef */
    if (INFO_SINGLEFUNDEF (arg_info) == SSA_TRAV_FUNDEFS) {
        FUNDEF_NEXT (arg_node) = TRAVopt (FUNDEF_NEXT (arg_node), arg_info);
    }

    DBUG_RETURN (arg_node);
}

/** <!--********************************************************************-->
 *
 * @fn node *SSATblock(node *arg_node, info *arg_info)
 *
 *   @brief traverses vardecs and instructions in this order, subblocks do not
 *          have any vardecs.
 *
 ******************************************************************************/
node *
SSATblock (node *arg_node, info *arg_info)
{

    DBUG_ENTER ("SSATblock");

    if (BLOCK_VARDEC (arg_node) != NULL) {
        /* there are some vardecs */
        BLOCK_VARDEC (arg_node) = TRAVdo (BLOCK_VARDEC (arg_node), arg_info);
    }

    if (BLOCK_INSTR (arg_node) != NULL) {
        /* there are some instructions */
        BLOCK_INSTR (arg_node) = TRAVdo (BLOCK_INSTR (arg_node), arg_info);
    }

    DBUG_RETURN (arg_node);
}

/** <!--********************************************************************-->
 *
 * @fn node *SSATassign(node *arg_node, info *arg_info)
 *
 *   @brief traverses assign chain top down. While traversing the RHS,
 *          the actual assign node is made available in INFO_ASSIGN.
 *          If this is changed during traversal of the RHS, the new value
 *          is considered an intended REPLACEMENT! Therefore, it has to be
 *          traversed and to be inserted into the actual chain of assignments.
 *
 ******************************************************************************/
node *
SSATassign (node *arg_node, info *arg_info)
{
    node *old_assign;

    DBUG_ENTER ("SSATassign");

    /* preserve the old assignment link */
    old_assign = INFO_ASSIGN (arg_info);

    INFO_ASSIGN (arg_info) = arg_node;

    /* traverse expr */
    if (ASSIGN_INSTR (arg_node) != NULL) {
        ASSIGN_INSTR (arg_node) = TRAVdo (ASSIGN_INSTR (arg_node), arg_info);
    }

    /* check for potentially required insertions */
    if (INFO_ASSIGN (arg_info) != arg_node) {
        /* indirectly insert these here and traverse them again */
        arg_node = INFO_ASSIGN (arg_info);
        ASSIGN_INSTR (arg_node) = TRAVdo (ASSIGN_INSTR (arg_node), arg_info);
    }

    /* traverse next exprs */
    if (ASSIGN_NEXT (arg_node) != NULL) {
        ASSIGN_NEXT (arg_node) = TRAVdo (ASSIGN_NEXT (arg_node), arg_info);
    }

    /* restore old assignment link */
    INFO_ASSIGN (arg_info) = old_assign;

    DBUG_RETURN (arg_node);
}

/** <!--********************************************************************-->
 *
 * @fn node *SSATlet( node *arg_node, info *arg_info)
 *
 *   @brief traverses an expression and assigned ids.
 *
 ******************************************************************************/
node *
SSATlet (node *arg_node, info *arg_info)
{
    DBUG_ENTER ("SSATlet");

    DBUG_ASSERT ((LET_EXPR (arg_node) != NULL), "N_let with empty EXPR attribute.");
    LET_EXPR (arg_node) = TRAVdo (LET_EXPR (arg_node), arg_info);

    if (LET_IDS (arg_node) != NULL) {
        /* there are some ids not in a special ssa copy let */
        LET_IDS (arg_node) = TRAVdo (LET_IDS (arg_node), arg_info);
    }

    DBUG_RETURN (arg_node);
}

/** <!--********************************************************************-->
 *
 * @fn node *SSATarg(node *arg_node, info *arg_info)
 *
 *   @brief check for missing SSACOUNT attribute in AVIS node. installs and
 *          inits new ssa-counter if necessary (init with 0, means unrenamed
 *          argument)
 *
 *          Note here, that quite some portion of the code only is required as
 *          SSATransform may be called several times. Therefore, all attributes
 *          have to be reset properly and the AVIS_SSACOUNT may actually exist
 *          already!
 *
 ******************************************************************************/
node *
SSATarg (node *arg_node, info *arg_info)
{
    node *avis = ARG_AVIS (arg_node);

    DBUG_ENTER ("SSATarg");

    DBUG_PRINT ("SSA", ("working on arg %s", ARG_NAME (arg_node)));

    if (AVIS_SSACOUNT (avis) == NULL) {
        node *topblock = FUNDEF_BODY (INFO_FUNDEF (arg_info));
        BLOCK_SSACOUNTER (topblock)
          = TBmakeSsacnt (0, STRcpy (ARG_NAME (arg_node)), BLOCK_SSACOUNTER (topblock));
        AVIS_SSACOUNT (avis) = BLOCK_SSACOUNTER (topblock);
    }

    /* actual rename-to target on stack*/
    AVIS_SSASTACK_TOP (avis) = avis;
    AVIS_SSADEFINED (avis) = TRUE;

    /*
     * mark stack as active
     * (later added vardecs and stacks are ignored when stacking)
     */
    AVIS_SSASTACK_INUSE (avis) = TRUE;

    /* clear all traversal infos in avis node */
    AVIS_SSATHEN (avis) = NULL;
    AVIS_SSAELSE (avis) = NULL;

    /* no direct assignment available (yet) */
    AVIS_SSAASSIGN (avis) = NULL;

    /* traverse next arg */
    if (ARG_NEXT (arg_node) != NULL) {
        ARG_NEXT (arg_node) = TRAVdo (ARG_NEXT (arg_node), arg_info);
    }

    DBUG_RETURN (arg_node);
}

/** <!--********************************************************************-->
 *
 * @fn node *SSATvardec(node *arg_node, info *arg_info)
 *
 *   @brief check for missing SSACOUNT attribute in AVIS node.
 *          installs and inits new ssa-counter if necessary (init with undef)
 *
 *          Note here, that quite some portion of the code only is required as
 *          SSATransform may be called several times. Therefore, all attributes
 *          have to be reset properly and the AVIS_SSACOUNT may actually exist
 *          already!
 *
 ******************************************************************************/
node *
SSATvardec (node *arg_node, info *arg_info)
{
    node *avis = VARDEC_AVIS (arg_node);

    DBUG_ENTER ("SSATvardec");

    if (AVIS_SSACOUNT (avis) == NULL) {
        node *topblock = FUNDEF_BODY (INFO_FUNDEF (arg_info));
        BLOCK_SSACOUNTER (topblock) = TBmakeSsacnt (0, STRcpy (VARDEC_NAME (arg_node)),
                                                    BLOCK_SSACOUNTER (topblock));
        AVIS_SSACOUNT (avis) = BLOCK_SSACOUNTER (topblock);
    }

    /* jet undefined on stack */
    AVIS_SSASTACK_TOP (avis) = NULL;
    AVIS_SSADEFINED (avis) = FALSE;

    /*
     * mark stack as activ
     * (later added vardecs and stacks are ignored when stacking)
     */
    AVIS_SSASTACK_INUSE (avis) = TRUE;

    /* clear all traversal infos in avis node */
    AVIS_SSATHEN (avis) = NULL;
    AVIS_SSAELSE (avis) = NULL;

    /* traverse next vardec */
    if (VARDEC_NEXT (arg_node) != NULL) {
        VARDEC_NEXT (arg_node) = TRAVdo (VARDEC_NEXT (arg_node), arg_info);
    }

    DBUG_RETURN (arg_node);
}

/** <!--********************************************************************-->
 *
 * @fn node *SSATid( node *arg_node, info *arg_info)
 *
 *   @brief depending on INFO_GENERATE_FUNCOND either generate funconds
 *          and prepend them to INFO_ASSIGN     or
 *          trigger renaming by traversing into the RHS ids.
 *
 ******************************************************************************/
node *
SSATid (node *arg_node, info *arg_info)
{

    node *new_avis = NULL;
    DBUG_ENTER ("SSATid");

    ID_AVIS (arg_node)
      = RemoveOldSsaStackElements (ID_AVIS (arg_node), INFO_NESTLEVEL (arg_info));

    if (INFO_GENERATE_FUNCOND (arg_info)) {

        /*
         * check for different assignments in then and else part
         */
        if (AVIS_SSATHEN (ID_AVIS (arg_node)) != AVIS_SSAELSE (ID_AVIS (arg_node))) {
            INFO_ASSIGN (arg_info)
              = CreateFuncondAssign (INFO_CONDSTMT (arg_info), arg_node,
                                     INFO_ASSIGN (arg_info));
        }
    } else {

        switch (INFO_RENAME (arg_info)) {
        case RN_top:
            new_avis = AVIS_SSASTACK_TOP (ID_AVIS (arg_node));
            break;
        case RN_then:
            new_avis = AVIS_SSATHEN (ID_AVIS (arg_node));
            break;
        case RN_else:
            new_avis = AVIS_SSAELSE (ID_AVIS (arg_node));
            break;
        }

        /* do renaming to new ssa vardec */
        if (!AVIS_SSADEFINED (ID_AVIS (arg_node)) || (new_avis == NULL)) {
            /**
             * One may think, that it would suffice to check AVIS_SSADEFINED here.
             * However, it may happen that despite AVIS_SSADEFINED being set
             * AVIS_SSASTACK_TOP is NULL!! The reason for that is the stacking
             * mechanism for getting the scopes right.
             * If a variable is defined in one local scope and used in another one
             * which happens to be not within the first one, this situation occurs.
             *
             * Example:
             *
             *    int main()
             *    {
             *      res = with(. <= iv <.) {
             *              a=1;
             *            } genarray([20], a);
             *      res = with(. <= iv <.) {
             *            } genarray([20], a);
             *
             *      return(  0);
             *    }
             *
             * When the second occurance of a is traversed AVIS_SSADEFINED is true,
             * as there has been a definition before (remember: renaming is steered
             * without taking scopes into account!). However, wrt. the actual scope
             * there is NO valid definition. Hence AVIS_SSASTACK_TOP is NULL.
             */
            if (INFO_ALLOW_GOS (arg_info) == FALSE) {
                CTIerrorLine (global.linenum, "Variable %s used without definition",
                              ID_NAME (arg_node));
            }
        } else {
            ID_AVIS (arg_node) = new_avis;
        }

        /* restore all depended attributes with correct values */
        ID_DECL (arg_node) = AVIS_DECL (ID_AVIS (arg_node));
    }

    DBUG_RETURN (arg_node);
}

/** <!--********************************************************************-->
 *
 * @fn node *SSATap(node *arg_node, info *arg_info)
 *
 *   @brief traverses args and does a recursive call in case of special
 *          function applications.
 *
 ******************************************************************************/
node *
SSATap (node *arg_node, info *arg_info)
{
    info *new_arg_info;

    DBUG_ENTER ("SSATap");

    DBUG_ASSERT ((AP_FUNDEF (arg_node) != NULL), "missing fundef in ap-node");

    AP_ARGS (arg_node) = TRAVopt (AP_ARGS (arg_node), arg_info);

    /* traverse special fundef without recursion (only in single fundef mode) */
    if ((FUNDEF_ISLACFUN (AP_FUNDEF (arg_node)))
        && (INFO_SINGLEFUNDEF (arg_info) == SSA_TRAV_SPECIALS)
        && (AP_FUNDEF (arg_node) != INFO_FUNDEF (arg_info))) {
        DBUG_PRINT ("SSA", ("traverse in special fundef %s",
                            FUNDEF_NAME (AP_FUNDEF (arg_node))));

        /* stack arg_info frame for new fundef */
        new_arg_info = MakeInfo ();

        INFO_SINGLEFUNDEF (new_arg_info) = INFO_SINGLEFUNDEF (arg_info);

        /* start traversal of special fundef */
        AP_FUNDEF (arg_node) = TRAVdo (AP_FUNDEF (arg_node), new_arg_info);

        DBUG_PRINT ("SSA", ("traversal of special fundef %s finished\n",
                            FUNDEF_NAME (AP_FUNDEF (arg_node))));

        new_arg_info = FreeInfo (new_arg_info);
    } else {
        DBUG_PRINT ("SSA", ("do not traverse in normal fundef %s",
                            FUNDEF_NAME (AP_FUNDEF (arg_node))));
    }

    DBUG_RETURN (arg_node);
}

/** <!--********************************************************************-->
 *
 * @fn node *SSATwith(node *arg_node, info *arg_info)
 *
 *   @brief traverses with-op, partitions and code in this order
 *
 ******************************************************************************/
node *
SSATwith (node *arg_node, info *arg_info)
{
    DBUG_ENTER ("SSATwith");

    /* traverse in with-op */
    DBUG_ASSERT ((WITH_WITHOP (arg_node) != NULL), "Nwith without WITHOP node!");
    WITH_WITHOP (arg_node) = TRAVdo (WITH_WITHOP (arg_node), arg_info);

    /**
     * traverse partitions: this implicitly checks withid consistency between
     * several partitions!
     */
    DBUG_ASSERT ((WITH_PART (arg_node) != NULL), "Nwith without PART node!");
    WITH_PART (arg_node) = TRAVdo (WITH_PART (arg_node), arg_info);
    /**
     * reset FIRST_WITHID (being set in SSAwithid) for the next with loop
     * traversal
     */
    INFO_FIRST_WITHID (arg_info) = NULL;

    /**
     * traverse code: as we may have more than one code stacking is done
     * at the code nodes themselves!
     */
    DBUG_ASSERT ((WITH_CODE (arg_node) != NULL), "Nwith without CODE node!");
    WITH_CODE (arg_node) = TRAVdo (WITH_CODE (arg_node), arg_info);

    DBUG_RETURN (arg_node);
}

/** <!--********************************************************************-->
 *
 * @fn node *SSATwith2(node *arg_node, info *arg_info)
 *
 *   @brief traverses with-op, segs, withid and code in this order
 *
 ******************************************************************************/
node *
SSATwith2 (node *arg_node, info *arg_info)
{
    DBUG_ENTER ("SSATwith2");

    /* traverse in with-op */
    DBUG_ASSERT ((WITH2_WITHOP (arg_node) != NULL), "Nwith2 without WITHOP node!");
    WITH2_WITHOP (arg_node) = TRAVdo (WITH2_WITHOP (arg_node), arg_info);

    /* traverse segmented partitions */
    DBUG_ASSERT ((WITH2_SEGS (arg_node) != NULL), "Nwith2 without SEGS node!");
    WITH2_SEGS (arg_node) = TRAVdo (WITH2_SEGS (arg_node), arg_info);

    /* traverse withid */
    DBUG_ASSERT ((WITH2_WITHID (arg_node) != NULL), "Nwith2 without WITHID node!");
    WITH2_WITHID (arg_node) = TRAVdo (WITH2_WITHID (arg_node), arg_info);
    /**
     * reset FIRST_WITHID (being set in SSAwithid) for the next with loop
     * traversal
     */
    INFO_FIRST_WITHID (arg_info) = NULL;

    /**
     * traverse code: as we may have more than one code stacking is done
     * at the code nodes themselves!
     */
    DBUG_ASSERT ((WITH2_CODE (arg_node) != NULL), "Nwith2 without CODE node!");
    WITH2_CODE (arg_node) = TRAVdo (WITH2_CODE (arg_node), arg_info);

    DBUG_RETURN (arg_node);
}

/** <!--********************************************************************-->
 *
 * @fn node *SSATpart(node *arg_node, info *arg_info)
 *
 *   @brief as all generators have to be done BEFORE any of the withids (these
 *          are treated as LHS which should not be visible in the generators),
 *          we traverse the generators top down and the withids bottom up.
 *
 ******************************************************************************/
node *
SSATpart (node *arg_node, info *arg_info)
{
    DBUG_ENTER ("SSATpart");

    /* traverse generator */
    DBUG_ASSERT ((PART_GENERATOR (arg_node) != NULL), "Npart without Ngen node!");
    PART_GENERATOR (arg_node) = TRAVdo (PART_GENERATOR (arg_node), arg_info);

    PART_NEXT (arg_node) = TRAVopt (PART_NEXT (arg_node), arg_info);

    /* traverse withid on our way back up: */
    DBUG_ASSERT ((PART_WITHID (arg_node) != NULL), "Npart without Nwithid node!");

    INFO_NESTLEVEL (arg_info) += 1;
    PART_WITHID (arg_node) = TRAVdo (PART_WITHID (arg_node), arg_info);
    INFO_NESTLEVEL (arg_info) -= 1;

    DBUG_RETURN (arg_node);
}

/** <!--********************************************************************-->
 *
 * @fn node *SSATwithid(node *arg_node, info *arg_info)
 *
 *  @brief withids are treated as LHS, so introduce new variables
 *         just as any other ids. See notes at top of this
 *         file to see earlier treatment, now disabled.
 *
 *
 ******************************************************************************/
node *
SSATwithid (node *arg_node, info *arg_info)
{
    node *assign;
    node *first;

    DBUG_ENTER ("SSATwithid");

    /* Set current assign to NULL for these special ids! */
    assign = INFO_ASSIGN (arg_info);
    INFO_ASSIGN (arg_info) = NULL;

    if ((INFO_FIRST_WITHID (arg_info) == NULL)
        || (global.ssaiv && (global.compiler_phase <= PH_opt))) {

        /*
         * This is the first withid, or -ssaiv mode.
         * Therefore, we have to treat the withid as LHS.
         */
        INFO_FIRST_WITHID (arg_info) = arg_node;

        if (WITHID_VEC (arg_node) != NULL) {
            DBUG_PRINT ("SSA", ("renaming: WITHID_VEC: %s",
                                AVIS_NAME (IDS_AVIS (WITHID_VEC (arg_node)))));
            WITHID_VEC (arg_node) = TRAVdo (WITHID_VEC (arg_node), arg_info);
            DBUG_ASSERT ((NULL == AVIS_SSAASSIGN (IDS_AVIS WITHID_VEC (arg_node))),
                         "WITHID_VEC should not have AVIS_SSAASSIGN");
        }

        if (WITHID_IDS (arg_node) != NULL) {
            DBUG_PRINT ("SSA", ("renaming: WITHID_IDS: %s",
                                AVIS_NAME (IDS_AVIS (WITHID_IDS (arg_node)))));
            WITHID_IDS (arg_node) = TRAVdo (WITHID_IDS (arg_node), arg_info);
            /* SHould have DBUG_ASSERT here on SSA_ASSIGNs */
        }

        if (WITHID_IDXS (arg_node) != NULL) {
            DBUG_PRINT ("SSA", ("traversing: WITHID_IDXS: %s",
                                AVIS_NAME (IDS_AVIS (WITHID_IDXS (arg_node)))));
            WITHID_IDXS (arg_node) = TRAVdo (WITHID_IDXS (arg_node), arg_info);
            DBUG_ASSERT ((NULL == AVIS_SSAASSIGN (IDS_AVIS WITHID_IDXS (arg_node))),
                         "WITHID_IDXS should not have AVIS_SSAASSIGN");
        }

    } else {

        if (global.ssaiv && (global.compiler_phase == PH_opt)) {
            /* The following code should all be dead now, if we're in the
             * optimizer. */
            DBUG_PRINT ("SSA", ("RBE dead code walking"));
        }

        /**
         * There have been prior partitions in this WL. INFO_FIRST_WITHID
         * points to the topmost one (in renamed form). => treat as RHS!
         * First, we do the renaming, if necessary. Then, we check consistency with
         * INFO_FIRST_WITHID.
         */
        first = INFO_FIRST_WITHID (arg_info);
        if (WITHID_VEC (arg_node) != NULL) {
            WITHID_VEC (arg_node) = TreatIdsAsRhs (WITHID_VEC (arg_node), arg_info);
            DBUG_ASSERT (IDS_AVIS (WITHID_VEC (arg_node))
                           == IDS_AVIS (WITHID_VEC (first)),
                         "multigenerator withloop with inconsistent withvec");
        } else {
            DBUG_ASSERT (WITHID_VEC (first) == NULL,
                         "multigenerator withloop with inconsistent withvec");
        }

        if (WITHID_IDS (arg_node) != NULL) {
            WITHID_IDS (arg_node) = TreatIdsAsRhs (WITHID_IDS (arg_node), arg_info);
            DBUG_ASSERT (IDS_AVIS (WITHID_IDS (arg_node))
                           == IDS_AVIS (WITHID_IDS (first)),
                         "multigenerator withloop with inconsistent withids");
        } else {
            DBUG_ASSERT (WITHID_IDS (first) == NULL,
                         "multigenerator withloop with inconsistent withids");
        }

        if (WITHID_IDXS (arg_node) != NULL) {
            WITHID_IDXS (arg_node) = TreatIdsAsRhs (WITHID_IDXS (arg_node), arg_info);
            DBUG_ASSERT (IDS_AVIS (WITHID_IDXS (arg_node))
                           == IDS_AVIS (WITHID_IDXS (first)),
                         "multigenerator withloop with inconsistent withids");
        } else {
            DBUG_ASSERT (WITHID_IDXS (first) == NULL,
                         "multigenerator withloop with inconsistent withids");
        }
    }

    /* restore currect assign for further processing */
    INFO_ASSIGN (arg_info) = assign;

    DBUG_RETURN (arg_node);
}

/** <!--********************************************************************-->
 *
 * @fn node *SSATcode(node *arg_node, info *arg_info)
 *
 *   @brief traverses block and expr
 *          While doing so, create new scope by increasing NESTLEVEL
 *
 ******************************************************************************/
node *
SSATcode (node *arg_node, info *arg_info)
{
    DBUG_ENTER ("SSATcode");

    INFO_NESTLEVEL (arg_info) += 1;

    /* traverse block */
    CODE_CBLOCK (arg_node) = TRAVopt (CODE_CBLOCK (arg_node), arg_info);

    /* traverse expressions */
    CODE_CEXPRS (arg_node) = TRAVdo (CODE_CEXPRS (arg_node), arg_info);

    INFO_NESTLEVEL (arg_info) -= 1;

    /* traverse next part */
    CODE_NEXT (arg_node) = TRAVopt (CODE_NEXT (arg_node), arg_info);

    DBUG_RETURN (arg_node);
}

/** <!--********************************************************************-->
 *
 * @fn node *SSATcond(node *arg_node, info *arg_info)
 *
 *   @brief this top-level conditional requires stacking of renaming status.
 *          traverses conditional, then and else branch in this order.
 *          The final renaming stati are stored in AVIS_SSATHEN and
 *          AVIS_SSAELSE, respectively.
 *
 ******************************************************************************/
node *
SSATcond (node *arg_node, info *arg_info)
{
    DBUG_ENTER ("SSATcond");

    /* save this cond_node for later insertions of copy assignments */
    INFO_CONDSTMT (arg_info) = arg_node;

    /* traverse conditional */
    COND_COND (arg_node) = TRAVdo (COND_COND (arg_node), arg_info);

    /* remove all ssastack elements with NESTLEVEL greater than 0 */
    FOR_ALL_AVIS (RemoveSsaStackElementsGreaterZero, INFO_FUNDEF (arg_info));

    /* do stacking of current renaming status */
    FOR_ALL_AVIS (DupTopSsastack, INFO_FUNDEF (arg_info));

    /* traverse then */
    COND_THEN (arg_node) = TRAVdo (COND_THEN (arg_node), arg_info);

    /* save to then for later merging */
    FOR_ALL_AVIS (PopSsastackThen, INFO_FUNDEF (arg_info));

    /* do stacking of current renaming status */
    FOR_ALL_AVIS (DupTopSsastack, INFO_FUNDEF (arg_info));

    /* traverse else */
    COND_ELSE (arg_node) = TRAVdo (COND_ELSE (arg_node), arg_info);

    /* save to else for later merging */
    FOR_ALL_AVIS (PopSsastackElse, INFO_FUNDEF (arg_info));

    DBUG_RETURN (arg_node);
}

/** <!--********************************************************************-->
 *
 * @fn node *SSATfuncond(node *arg_node, info *arg_info)
 *
 *   @brief set INFO_FUNCOND_FOUND and traverse all sons
 *
 ******************************************************************************/
node *
SSATfuncond (node *arg_node, info *arg_info)
{
    DBUG_ENTER ("SSATfuncond");

    INFO_FUNCOND_FOUND (arg_info) = TRUE;

    FUNCOND_IF (arg_node) = TRAVdo (FUNCOND_IF (arg_node), arg_info);

    DBUG_ASSERT (INFO_CONDSTMT (arg_info) != NULL,
                 "Funcond without corresponding N_cond node found!");

    /*
     * Perform renaming according to the two branches
     */
    INFO_RENAME (arg_info) = RN_then;
    FUNCOND_THEN (arg_node) = TRAVdo (FUNCOND_THEN (arg_node), arg_info);

    INFO_RENAME (arg_info) = RN_else;
    FUNCOND_ELSE (arg_node) = TRAVdo (FUNCOND_ELSE (arg_node), arg_info);

    INFO_RENAME (arg_info) = RN_top;

    DBUG_RETURN (arg_node);
}

/** <!--********************************************************************-->
 *
 * @fn node *SSATreturn(node *arg_node, info *arg_info)
 *
 *   @brief inserts missing funcond nodes and traverses the return elements
 *
 ******************************************************************************/
node *
SSATreturn (node *arg_node, info *arg_info)
{
    DBUG_ENTER ("SSATreturn");

    /**
     * check whether this function contains a conditional but does not contain
     * funconds yet. If this is the case, switch the traversal mode to
     * "GENERATE_FUNCOND". This will insert new funcond assignments into
     * INFO_ASSIGN, but do no SSA conversion at all!
     * On return, SSAassign will notice these insertions, traverse them
     * (including this return node again!) for SSA construction, and finally
     * insert them into the actual chain.
     */
    if ((INFO_CONDSTMT (arg_info) != NULL) && !INFO_FUNCOND_FOUND (arg_info)) {

        INFO_GENERATE_FUNCOND (arg_info) = TRUE;
        /**
         * Though a rare case, we may not have to generate funconds at all.
         * e.g., in void functions or if the return values do not depend
         * at all on vars defined in the branches.
         * To avoid non-termination in these cases, we set FUNCOND_FOUND!
         */
        INFO_FUNCOND_FOUND (arg_info) = TRUE;
    }

    /* traverse exprs */
    RETURN_EXPRS (arg_node) = TRAVopt (RETURN_EXPRS (arg_node), arg_info);

    INFO_GENERATE_FUNCOND (arg_info) = FALSE;

    DBUG_RETURN (arg_node);
}

/*@}*/

/**
 *
 * @name IDS traversal functions:
 *
 * <!--
 * node *SSATids(node *arg_ids, info *arg_info)
 * node *TreatIdsAsRhs(node* arg_ids, info *arg_info)
 * -->
 *
 */
/*@{*/
/** <!--********************************************************************-->
 *
 * @fn node *SSATids(node *arg_node, info *arg_info)
 *
 *   @brief creates new (renamed) instance of defined variables.
 *
 ******************************************************************************/

node *
SSATids (node *arg_node, info *arg_info)
{
    node *avis;

    DBUG_ENTER ("SSATids");

    IDS_AVIS (arg_node)
      = EnsureSsaStackElement (IDS_AVIS (arg_node), INFO_NESTLEVEL (arg_info));

    avis = IDS_AVIS (arg_node);

    if (!AVIS_SSADEFINED (avis)) {
        /*
         * first definition of variable (no renaming)
         */
        AVIS_SSASTACK_TOP (avis) = avis;
        AVIS_SSADEFINED (avis) = TRUE;
        DBUG_PRINT ("SSA", ("first definition, no renaming: %s (" F_PTR ")",
                            AVIS_NAME (avis), avis));

    } else {
        /*
         * redefinition - create new unique variable/vardec
         */
        node *ssacnt;
        node *new_avis;
        char tmpstring[TMP_STRING_LEN];
        char *new_name;

        ssacnt = AVIS_SSACOUNT (avis);

        /* increment ssa renaming counter */
        SSACNT_COUNT (ssacnt) += 1;

        /* make new avis */
        new_avis = DUPdoDupNode (avis);
        AVIS_SSALPINV (avis) = FALSE;

        /* create new unique name */
        sprintf (tmpstring, "__SSA%d_%d", global.ssaform_phase, SSACNT_COUNT (ssacnt));
        new_name = STRcat (SSACNT_BASEID (ssacnt), tmpstring);

        AVIS_NAME (new_avis) = MEMfree (AVIS_NAME (new_avis));
        AVIS_NAME (new_avis) = new_name;

        if (AVIS_DIM (avis) != NULL) {
            AVIS_DIM (new_avis) = DUPdoDupNode (AVIS_DIM (avis));
        }

        if (AVIS_SHAPE (avis) != NULL) {
            AVIS_SHAPE (new_avis) = DUPdoDupNode (AVIS_SHAPE (avis));
        }

        if (global.compiler_phase <= PH_tc) {
            /**
             * we are running SSATransform prior or during TC! Therefore,
             * the type needs to be generalized to unknown[*]. This requires
             * insert_type_conv to be run prior to SSATransform!
             */
            AVIS_TYPE (new_avis) = TYfreeType (AVIS_TYPE (new_avis));
            AVIS_TYPE (new_avis) = TYmakeAUD (TYmakeSimpleType (T_unknown));
            /**
             * Stephan memorial line:  (please do not remove)
             *    DBUG_PRINT( "SBS", ("POOP"));
             */
        }

        FUNDEF_VARDEC (INFO_FUNDEF (arg_info))
          = TBmakeVardec (new_avis, FUNDEF_VARDEC (INFO_FUNDEF (arg_info)));

        DBUG_PRINT ("SSA", ("re-definition, renaming: %s (" F_PTR ") -> %s",
                            AVIS_NAME (avis), avis, AVIS_NAME (new_avis)));

        /* new rename-to target for old vardec */
        AVIS_SSASTACK_TOP (avis) = new_avis;

        /* rename this ids */
        IDS_AVIS (arg_node) = new_avis;

        /* Increase global renaming counter */
        IncSSATCounter ();
    }

    avis = IDS_AVIS (arg_node);

    AVIS_SSAASSIGN (avis) = INFO_ASSIGN (arg_info);

    AVIS_DIM (avis) = TRAVopt (AVIS_DIM (avis), arg_info);
    AVIS_SHAPE (avis) = TRAVopt (AVIS_SHAPE (avis), arg_info);

    /* traverese next ids */
    IDS_NEXT (arg_node) = TRAVopt (IDS_NEXT (arg_node), arg_info);

    DBUG_RETURN (arg_node);
}

/** <!--********************************************************************-->
 *
 * @fn node *TreatIdsAsRhs(ids *arg_node, info *arg_info)
 *
 *   @brief rename variable to actual ssa renaming counter.
 *          This function is only to used in the context of multiple WITHID
 *          node where only the first WITHID actually defines a variable.
 *
 ******************************************************************************/
static node *
TreatIdsAsRhs (node *arg_node, info *arg_info)
{
    node *new_avis;

    DBUG_ENTER ("TreatIdsAsRhs");

    IDS_AVIS (arg_node)
      = RemoveOldSsaStackElements (IDS_AVIS (arg_node), INFO_NESTLEVEL (arg_info));

    new_avis = AVIS_SSASTACK_TOP (IDS_AVIS (arg_node));

    /* do renaming to new ssa vardec */
    if ((!AVIS_SSADEFINED (IDS_AVIS (arg_node))) || (new_avis == NULL)) {
        /**
         * One may think, that it would suffice to check AVIS_SSADEFINED here.
         * However, it may happen that despite AVIS_SSADEFINED being set
         * AVIS_SSASTACK_TOP is NULL!! The reason for that is the stacking
         * mechanism for getting the scopes right.
         * If a variable is defined in one local scope and used in another one
         * which happens to be not within the first one, this situation occurs.
         *
         * Example:
         *
         *    int main()
         *    {
         *      res = with(. <= iv <.) {
         *              a=1;
         *            } genarray([20], a);
         *      res = with(. <= iv <.) {
         *            } genarray([20], a);
         *
         *      return(  0);
         *    }
         *
         * When the second occurance of a is traversed AVIS_SSADEFINED is true,
         * as there has been a definition before (remember: renaming is steered
         * without taking scopes into account!). However, wrt. the actual scope
         * there is NO valid definition. Hence AVIS_SSASTACK_TOP is NULL.
         */
        if (INFO_ALLOW_GOS (arg_info) == FALSE) {
            CTIerrorLine (global.linenum, "Variable %s used without definition",
                          IDS_NAME (arg_node));
        }
    } else {
        IDS_AVIS (arg_node) = new_avis;
    }

    /* traverese next ids */
    if (IDS_NEXT (arg_node) != NULL) {
        IDS_NEXT (arg_node) = TreatIdsAsRhs (IDS_NEXT (arg_node), arg_info);
    }

    DBUG_RETURN (arg_node);
}

/*@}*/

/**
 *
 * @name Start functions:
 *
 * <!--
 * node *SSATransform(node *ast)            : general traversal function
 * node *SSATransformAllowGOs(node *ast)    : ignore usages of non-defined vars
 * node *SSATransformOneFunction(node *ast) : one fundef + included LC funs
 * node *SSATransformOneFundef(node *ast)   : one fundef only
 *
 * -->
 *
 */
/*@{*/
/** <!--********************************************************************-->
 *
 * @fn node *SSATdoTransform(node *syntax_tree)
 *
 *   @brief Starts traversal of AST to transform code in SSA form. Every
 *          variable has exaclty one definition. This code transformtion relies
 *          on the lac2fun transformation! After all the valid_ssaform flag is
 *          set to TRUE. It may be called several times until eventually
 *          UndoSSATransform is called. This sets valid_ssaform to false
 *          and increases the ssaform_phase global counter to avoid naming
 *          conflicts with further SSA-UndoSSA transformations.
 *
 ******************************************************************************/
node *
SSATdoTransform (node *syntax_tree)
{
    info *arg_info;

    DBUG_ENTER ("SSATdoTransform");

    DBUG_ASSERT ((NODE_TYPE (syntax_tree) == N_module),
                 "SSATransform is used for module nodes only");

#ifndef DBUG_OFF
    if (global.compiler_phase == PH_opt) {
        DBUG_PRINT ("OPT", ("starting ssa transformation for ast"));
    }
#endif

    arg_info = MakeInfo ();
    INFO_SINGLEFUNDEF (arg_info) = SSA_TRAV_FUNDEFS;
    INFO_ALLOW_GOS (arg_info) = FALSE;

    TRAVpush (TR_ssat);
    syntax_tree = TRAVdo (syntax_tree, arg_info);
    TRAVpop ();

    arg_info = FreeInfo (arg_info);

    global.valid_ssaform = TRUE;
    CheckSSATCounter ();

    DBUG_RETURN (syntax_tree);
}

/** <!--********************************************************************-->
 *
 * @fn node *SSATdoTransformAllowGOs(node *syntax_tree)
 *
 *   @brief In principle, this is only a wrapper for SSATransform. The only
 *          difference is that it does not require all variables to be defined
 *          before used!!!
 *          This variant is required when the SSA form has to be built before
 *          introducing explicit data dependencies for GOs (global objects).
 *
 ******************************************************************************/
node *
SSATdoTransformAllowGOs (node *syntax_tree)
{
    info *arg_info;

    DBUG_ENTER ("SSATdoTransformAllowGOs");

    DBUG_ASSERT ((NODE_TYPE (syntax_tree) == N_module),
                 "SSATdoTransformAllowGos is used for module nodes only");

#ifndef DBUG_OFF
    if (global.compiler_phase == PH_opt) {
        DBUG_PRINT ("OPT", ("starting ssa transformation allowing GOs for ast"));
    }
#endif

    arg_info = MakeInfo ();
    INFO_SINGLEFUNDEF (arg_info) = SSA_TRAV_FUNDEFS;
    INFO_ALLOW_GOS (arg_info) = TRUE;

    TRAVpush (TR_ssat);
    syntax_tree = TRAVdo (syntax_tree, arg_info);
    TRAVpop ();

    arg_info = FreeInfo (arg_info);

    global.valid_ssaform = TRUE;
    CheckSSATCounter ();

    DBUG_RETURN (syntax_tree);
}

/** <!--********************************************************************-->
 *
 * @fn node *SSATdoTransformOneFunction(node *fundef)
 *
 *   @brief same as SSATransform, but traverses the given function only.
 *          Does not trverse through LC functions per se, but if a call
 *          to an LC function is found, it will be followed through.
 *
 ******************************************************************************/
node *
SSATdoTransformOneFunction (node *fundef)
{
    info *arg_info;

    DBUG_ENTER ("SSATdoTransformOneFunction");

    DBUG_ASSERT ((NODE_TYPE (fundef) == N_fundef),
                 "SSATransformOneFunction is used for fundef nodes only");

    if (!(FUNDEF_ISLACFUN (fundef))) {
#ifndef DBUG_OFF
        if (global.compiler_phase == PH_opt) {
            DBUG_PRINT ("OPT",
                        ("starting ssa transformation for %s", FUNDEF_NAME (fundef)));
        }
#endif

        arg_info = MakeInfo ();
        INFO_SINGLEFUNDEF (arg_info) = SSA_TRAV_SPECIALS;

        TRAVpush (TR_ssat);
        fundef = TRAVdo (fundef, arg_info);
        TRAVpop ();

        arg_info = FreeInfo (arg_info);
    }

    global.valid_ssaform = TRUE;

    CheckSSATCounter ();

    DBUG_RETURN (fundef);
}

/** <!--********************************************************************-->
 *
 * @fn node *SSATdoTransformOneFundef(node *fundef)
 *
 *   @brief same as SSATransform, but traverses the given fundef only.
 *          Any LC functions will not be followed through!
 *
 ******************************************************************************/
node *
SSATdoTransformOneFundef (node *fundef)
{
    info *arg_info;

    DBUG_ENTER ("SSATdoTransformOneFundef");

    DBUG_ASSERT ((NODE_TYPE (fundef) == N_fundef),
                 "SSATdoTransformOneFundef is applicable to fundef nodes only");

#ifndef DBUG_OFF
    if (global.compiler_phase == PH_opt) {
        DBUG_PRINT ("OPT", ("starting ssa transformation for %s", FUNDEF_NAME (fundef)));
    }
#endif

    arg_info = MakeInfo ();
    INFO_SINGLEFUNDEF (arg_info) = SSA_TRAV_NONE;

    TRAVpush (TR_ssat);
    fundef = TRAVdo (fundef, arg_info);
    TRAVpop ();

    arg_info = FreeInfo (arg_info);

    global.valid_ssaform = TRUE;

    CheckSSATCounter ();

    DBUG_RETURN (fundef);
}
/*@}*/

/*@}*/ /* defgroup ssatransform */
