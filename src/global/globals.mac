
/*
 *
 * $Log$
 * Revision 1.1  2004/11/21 20:46:36  cg
 * Initial revision
 *
 */

/*
 * File : globals.mac
 *
 * This file should contain the definitions of all global variables
 * used in the implementation of the sac2c compiler which are not restricted
 * to the use within one particular file.
 *
 * However, the usage of global variables should be as limited as possible
 * since a functional programming style is preferred in the SAC project. The
 * major application of global variables therefore is the storage of such
 * global information as determined by the command line arguments of a sac2c
 * compiler call.
 *
 */

/*
 *  Version control
 */

NIF (const char *, version_id, "v1.00-alpha")
NIF (const char *, target_platform, OS "_" ARCH)

/*
 *  File handling
 */

NIF (FILE *, outfile, NULL)
/* stream to write result to */

NIF (char *, sacfilename[MAX_FILE_NAME], {})
/* name of file to be compiled */

NIF (char *, puresacfilename, NULL)
/* sacfilename without path specification */

NIF (char *, outfilename[MAX_FILE_NAME], {})
/* name of executable    */

NIF (char *, modulename[MAX_FILE_NAME], {})
/* name of module/class which is compiled    */

NIF (char *, cfilename[MAX_FILE_NAME], {})
/* name of C source code file       */

NIF (char *, targetdir[MAX_FILE_NAME], {})
/* name of C source code file       */

NIF (char *, commandline[MAX_PATH_LEN], {})
/* command line, used for diagnostic output (status report)  */

NIF (file_type, filetype, F_prog)
/* kind of file: F_PROG, F_MODIMP or F_CLASSIMP */

NIF (char *, tmp_dirname, NULL)
/* directory for storing files generated by sac2c until      */
/* the final compilation steps are completed.                */

/*
 * Target architecture description
 */

NIF (char *, target_name, "default")
/* name of target architecture, information taken from sac2crc file  */

/*
 * Dynamic-sized arrays option
 */

NIF (bool, dynamic_shapes, FALSE)
/* Dynamic shapes are disabled by default */

/*
 * Multi-thread options
 */

NIF (mtmode_t, mtmode, MT_none)

/*
 *  will be set to according to -mt and -mtmode compiler flags
 */

NIF (int, num_threads, 1)

/*
 * number of threads to be generated.
 *  0  : dynamic number of threads, specified as first command line argument
 *       on application program startup.
 *  1  : sequential program
 *  >1 : exact number of threads to be started
 */

NIF (int, max_sync_fold, -1)

/*
 * maximum number of fold operations in a single synchronisation block.
 *   -1 => value of infered needed_sync_fold will be used
 *    0 => no fold-with-loops, will be executed concurrently,
 *         because no fold are allowed to be contained in a spmd/sync-block.
 *   >0 => as much folds will be contained in one sync-block as maximum.
 */

NIF (int, needed_sync_fold, 0)

/*
 * maximum number of fold operations in a single synchronisation block,
 * will be infered mechanically.
 */

NIF (int, max_threads, 32)

/*
 * maximum number of threads if exact number is determined dynamically.
 */

NIF (int, min_parallel_size, 250)

/*
 * minimum generator size for parallel execution of with-loops.
 */

NIF (int, max_replication_size, 250)

/*
 *  maximum size of array for replication, otherwise the calculation will be
 *  executed single-threaded.
 */

NIF (int, max_schedulers, 0)
/*
 *  This variable is used to collect the maximum number of schedulers in a
 *  single SPMD block/function in order to generate an appropriate number
 *  of local data structure sets for the scheduler implementations.
 */

NIF (int, min_parallel_size_per_thread, 8)
/*
 * minimum generator size per thread for parallel execution of with-loops
 * e.g., max_threads = 4, min_parallel_size_per_thread=8
 *       => generator size must be >= 32 to be executed parallel
 */

NIF (bool, executionmodes_available, FALSE)
/*
 * flag showing if the sourcecode is tagged with executionmodes or not
 * this information is important for printing it
 */

/*
 * Preprocessor options
 *
 *  refer to -D, -cppI command line options:
 */

NIF (char *, cppvars[MAX_CPP_VARS], {})
/* pointer to respective argv field */

NIF (int, num_cpp_vars, 0)
/* number of preprocessor -D options */

NIF (char *, cppincs[MAX_CPP_INCS], {})
/* pointer to respective argv field */

NIF (int, num_cpp_incs, 0)
/* number of preprocessor -cppI options */

/*
 * C compiler options
 */

NIF (bool, cc_debug, FALSE)
/* Enable/disable inclusion of debug code into object files. */

#ifdef PRODUCTION
NIF (int, cc_optimize, 3)
#else  /* PRODUCTION */
NIF (int, cc_optimize, 0)
#endif /* PRODUCTION */
/* C compiler level of optimization */

/*
 * Command line options for triggering optimizations
 */

NIF (optimize_t, optimize, InitOptimize ())

/*
 * flag indicating whether ast is in valid ssa form
 */
NIF (bool, valid_ssaform, FALSE)

/*
 * counter indicating how often the ssa form has been created FROM
 * SCRATCH(!), i.e., how often UndoSSATransform has been called.
 */
NIF (int, ssaform_phase, 0)

/*
 * Reuse inference in emm is default behaviour   ->  should be moved to optimize
 */
NIF (bool, reuse, TRUE)

/*
 * per default do not use aggressive WLS
 * except the inner WL has <= wls_bound elems
 */
NIF (bool, wls_aggressive, FALSE)
NIF (int, maxwls, 1)

/*
 * per default do not treat floats as defined in IEEE-754 standard
 */

NIF (bool, enforce_ieee, FALSE)

/*
 * Command line options for specifying particular side conditions
 * for the (new) type inference.
 */

NIF (int, max_overload, 20)
NIF (spec_mode_t, spec_mode, SS_aks)
NIF (char, spec_mode_str[][4], {"aks", "akd", "aud"})

/*
 * Command line options for specifying particular side conditions
 * for some optimizations.
 */

NIF (int, optvar, 50)
NIF (int, inlnum, 1)
NIF (int, unrnum, 2)
NIF (int, wlunrnum, 9)
NIF (int, minarray, 4)
NIF (int, max_optcycles, 10)
NIF (int, max_newgens, 100)
NIF (bool, no_fold_fusion, FALSE)

NIF (int, initial_master_heapsize, 1024)
NIF (int, initial_worker_heapsize, 64)
NIF (int, initial_unified_heapsize, 0)
/*
 * Why is the default initial top arena size 0?
 *
 * Unfortunately, it turned out that pthread_key_create() allocates
 * some amount of memory, actually one page, without using malloc()
 * but by direct manipulation of the process' break value via sbrk().
 * Since in multi-threaded execution malloc() is always called upon
 * program startup, early intitialization of the heap manager's internal
 * data structures is enforced.
 * Subsequent manipulation of the break value, however, leads to memory
 * fragmentation as the initial top arena cannot be extended smoothly
 * due to the missing page on top of the initially requested heap memory.
 *
 * As long as there is no elegant solution to this problem, there should
 * be no initialization of the top arena, except when an upper boundary
 * for the total memory consumption is known and used for initialization.
 */

/*
 * Display options
 *
 * These options modify the way print functions behave.
 */

NIF (bool, show_idx, FALSE)

/*
 * Runtime options
 *
 * These options insert special code sections into the target C code
 * in order to do additional checks, profiling, etc., or to use intrinsic
 * implementations of some array operations.
 */

NIF (int, print_after_break, TRUE)
NIF (unsigned int, traceflag, TRACE_NONE)
NIF (unsigned int, profileflag, PROFILE_NONE)
NIF (unsigned int, runtimecheck, RUNTIMECHECK_NONE)
NIF (unsigned int, intrinsics, INTRINSIC_NONE)
NIF (unsigned int, cachesim, CACHESIM_NO | CACHESIM_PIPE)
NIF (char, cachesim_host[MAX_FILE_NAME], "")
NIF (char, cachesim_file[MAX_FILE_NAME], "")
NIF (char, cachesim_dir[MAX_FILE_NAME], "")

/*
 * Profiling information storage facilities
 */

NIF (int, PFfuncntr, 0)
NIF (char *, PFfunnme[PF_MAXFUN], {"main"})
NIF (int, PFfunapcntr[PF_MAXFUN], {})
NIF (int, PFfunapline[PF_MAXFUN][PF_MAXFUNAP], {})
NIF (int, PFfunapmax, 1)

/*
 * Compile time options
 *
 * These options specify the way sac2c behaves.
 */

NIF (bool, use_efence, FALSE)
/* link executable with ElectricFence (Malloc Debugger) */

NIF (bool, cleanup, TRUE)
/* Don't remove temporary files and directory when compiling
   module/class implementations. */

NIF (int, linkstyle, 2)
/* Specify linkage style for module/class implementations */

NIF (bool, libstat, FALSE)
/* Don't actually compile, but display library information. */

NIF (int, makedeps, 0)
/* Don't actually compile, but infer module dependencies. */

NIF (bool, gen_cccall, FALSE)
/* Generate shell script '.sac2c' in current directory
   that contains the C compiler call produced by sac2c. */

NIF (bool, show_syscall, FALSE)
/* Show system calls during compilation. */

NIF (compiler_phase_t, break_after, PH_final)
/* Stop compilation process after given phase. */

NIF (int, break_cycle_specifier, -1)
/* Additional break specifier that allows a designated break within
   a particular (optimization) loop. */

NIF (char, break_specifier[MAX_BREAK_SPECIFIER], "")
/* Additional break specifier to allow breaking within a particular
   compiler phase at any position. */

NIF (unsigned int, generatelibrary, GENERATELIBRARY_NOTHING)
/* Specify interfaces to generate from SAC modules.
   Init: nothing, but changed to default standard SAC library
         if commandline switch is not used. */

NIF (int, padding_overhead_limit, 10)
/* Limit for additional resource allocation due to array padding in
   percentage. Can be modified via -aplimit option. */

NIF (bool, apdiag, FALSE)
/* Diagnostics of array padding may be written into a file.
   Per default no information is written. Use -apdiag to enable
   output to "modulename.ap". */

NIF (int, apdiag_limit, 20000)
/* Limit for size of diagnostic output given in approximate number of lines.
   This avoids the creation of extremely huge diagnostic output files. */

/*
 *  Definitions of some global variables necessary for the
 *  glorious SAC2C compile time information system
 */

NIF (int, errors_cnt, 0)   /* counter for number of errors   */
NIF (int, warnings_cnt, 0) /* counter for number of warnings */

NIF (te_info, *act_info_chn, NULL) /* info chain for extended error messages during TC */

#ifdef PRODUCTION
NIF (int, verbose_level, 1) /* controls compile time output   */
#else                       /* PRODUCTION */
NIF (int, verbose_level, 3)
#endif                      /* PRODUCTION */

/* counter for compilation phases */
NIF (compiler_phase_t, compiler_phase, PH_setup)

NIF (int, message_indent, 0)       /* used for formatting compile time output */
NIF (int, last_indent, 0)          /* used for formatting compile time output */
NIF (int, current_line_length, 80) /* used for formatting compile time output */

/* buffer for generating formatted message */
NIF (char, error_message_buffer[MAX_ERROR_MESSAGE_LENGTH], {})

NIF (int, linenum, 1) /* current line number */

NIF (char *, filename, NULL) /* current file name */

NIF (char *, compiler_phase_name[PH_final + 1],
     {
#define PH_SELtext(it_text) it_text
#include "phase_info.mac"
#undef PH_SELtext
     })

/*
 * DBUG options
 */

NIF (compiler_phase_t, my_dbug_from, PH_initial)
NIF (compiler_phase_t, my_dbug_to, PH_final)
NIF (int, my_dbug, 0)
NIF (int, my_dbug_active, 0)
NIF (char *, my_dbug_str, NULL)

#ifdef SHOW_MALLOC
NIF (int, malloc_align_step)
NIF (unsigned int, current_allocated_mem, 0)
NIF (unsigned int, max_allocated_mem, 0)
#endif

/*
 * lac2fun, fun2lac conversion
 */

NIF (int, do_lac2fun[PH_final + 1],
     {
#define PH_SELlac2fun(it_lac2fun) it_lac2fun
#include "phase_info.mac"
#undef PH_SELlac2fun
     })

/* (do_lac2fun[i] > 0): do lac2fun conversion before phase i */

NIF (int, do_fun2lac[PH_final + 1],
     {
#define PH_SELfun2lac(it_fun2lac) it_fun2lac
#include "phase_info.mac"
#undef PH_SELfun2lac
     })

/* (do_fun2lac[i] > 0): do fun2lac conversion after phase i */

/*
 * for arg tags
 */

NIF (bool, ATG_has_shp[],
     {
#define SELECTshp(it_shp) it_shp
#include "argtag_info.mac"
#undef SELECTshp
     })

NIF (bool, ATG_has_rc[],
     {
#define SELECTrc(it_rc) it_rc
#include "argtag_info.mac"
#undef SELECTrc
     })

NIF (bool, ATG_has_desc[],
     {
#define SELECTdesc(it_desc) it_desc
#include "argtag_info.mac"
#undef SELECTdesc
     })

NIF (bool, ATG_is_in[],
     {
#define SELECTin(it_in) it_in
#include "argtag_info.mac"
#undef SELECTin
     })

NIF (bool, ATG_is_out[],
     {
#define SELECTout(it_out) it_out
#include "argtag_info.mac"
#undef SELECTout
     })

NIF (bool, ATG_is_inout[],
     {
#define SELECTinout(it_inout) it_inout
#include "argtag_info.mac"
#undef SELECTinout
     })

NIF (char, *ATG_string[],
     {
#define SELECTtext(it_text) it_text
#include "argtag_info.mac"
#undef SELECTtext
     })

/*
 * Special purpose global variables
 */

NIF (bool, print_objdef_for_header_file, FALSE)
/*
 *  This global variable serves a very special purpose.
 *  When generating separate C-files for functions and global variables,
 *  a header file is required which contains declarations of them all.
 *  In this case the ICM ND_KS_DECL_GLOBAL_ARRAY must be written
 *  differently. This global variable triggers the respective print
 *  function defined in icm2c.c. It is set by PrintModul.
 */

NIF (int, function_counter, 1)
/*
 *  This global variable is used whenever the functions of a module or
 *  class are written to separate files.
 */

NIF (int, object_counter, 0)
/*
 *  This global variable is used whenever the objectinitflags of a module
 *  are written to separate files.
 */

NIF (int, indent, 0)
/*
 *  This global variable is used for indenting while printing SAC-code.
 *  It has to be made global since printing is not only done in the printing-
 *  directory but from within icm2c_xxx.c as well!
 */

/*
 * The following array of integers keeps the lengths of all simpletypes.
 * It at least is used in compile.c, tile_size_inference.c, and constants.c!
 */
NIF (int, basetype_size[],
     {
#define TYP_IFsize(sz) sz
#include "type_info.mac"
#undef TYP_IFsize
     })

NIF (char *, prf_string[],
     {
#define PRF_IF(a, b, c, d, e, f, g, h) c
#include "prf_node_info.mac"
#undef PRF_IF
     })

NIF (int, min_array_rep, MIN_ARRAY_REP_SCL_AKS)
/*
 * This global variable can be used to restrict the set of
 * array representations used by the backend
 */
