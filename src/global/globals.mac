
/*
 *
 * $Log$
 * Revision 1.4  2004/11/23 11:36:42  cg
 * Switched mac-file based declaration of global variables.
 *
 * Revision 1.3  2004/11/23 09:54:26  cg
 * undefs inserted.
 *
 * Revision 1.2  2004/11/22 16:26:43  cg
 * First complete revision.
 *
 * Revision 1.1  2004/11/22 11:21:25  cg
 * Initial revision.
 *
 */

/*
 * File : globals.mac
 *
 * This file should contain the definitions of all global variables
 * used in the implementation of the sac2c compiler which are not restricted
 * to the use within one particular file.
 *
 * However, the usage of global variables should be as limited as possible
 * since a functional programming style is preferred in the SAC project. The
 * major application of global variables therefore is the storage of such
 * global information as determined by the command line arguments of a sac2c
 * compiler call.
 *
 */

#ifndef GLOBALtype
#define GLOBALtype(type)
#endif

#ifndef GLOBALid
#define GLOBALid(id)
#endif

#ifndef GLOBALinit
#define GLOBALinit(init)
#endif

#ifndef GLOBALdelim
#define GLOBALdelim
#endif

#define GLOBAL(type, id, init)                                                           \
    GLOBALtype (type) GLOBALid (id) GLOBALinit (init) GLOBALdelim

/*
 *  Version control
 */

GLOBAL (const char *, version_id, "v1.00-alpha")
/*
 * version string
 */

GLOBAL (const char *, target_platform, OS "_" ARCH)
/*
 * operating system platform string
 */

/*
 *  File handling
 */

GLOBAL (FILE *, outfile, NULL)
/*
 * stream to write result to
 */

GLOBAL (char, sacfilename[MAX_FILE_NAME], {})
/*
 * name of file to be compiled
 */

GLOBAL (char, puresacfilename, NULL)
/*
 * sacfilename without path specification
 */

GLOBAL (char, outfilename[MAX_FILE_NAME], {})
/*
 * name of executable
 */

GLOBAL (char, modulename[MAX_FILE_NAME], {})
/*
 * name of module/class which is compiled
 */

GLOBAL (char, cfilename[MAX_FILE_NAME], {})
/*
 * name of C source code file
 */

GLOBAL (char, targetdir[MAX_FILE_NAME], {})
/*
 * name of C source code file
 */

GLOBAL (char, commandline[MAX_PATH_LEN], {})
/*
 * command line, used for diagnostic output (status report)
 */

GLOBAL (file_type, filetype, F_prog)
/*
 * kind of file: F_PROG, F_MODIMP or F_CLASSIMP
 */

GLOBAL (char *, tmp_dirname, NULL)
/*
 * directory for storing temporary files
 */

/*
 * Target architecture description
 */

GLOBAL (char *, target_name, "default")
/*
 * name of target architecture selected by -target option
 */

/*
 * Dynamic-sized arrays option
 */

GLOBAL (bool, dynamic_shapes, FALSE)
/*
 * Dynamic shapes are disabled by default
 */

/*
 * Multi-thread options
 */

GLOBAL (mtmode_t, mtmode, MT_none)
/*
 * Multi-thread mode set according to -mt and -mtmode compiler flags
 */

GLOBAL (int, num_threads, 1)
/*
 * Number of threads to be generated.
 *  0  : dynamic number of threads, specified as first command line argument
 *       on application program startup.
 *  1  : sequential program
 *  >1 : exact number of threads to be started
 */

GLOBAL (int, max_sync_fold, -1)
/*
 * Maximum number of fold operations in a single synchronisation block.
 *   -1 => value of infered needed_sync_fold will be used
 *    0 => no fold-with-loops, will be executed concurrently,
 *         because no fold are allowed to be contained in a spmd/sync-block.
 *   >0 => as much folds will be contained in one sync-block as maximum.
 */

GLOBAL (int, needed_sync_fold, 0)
/*
 * Maximum number of fold operations in a single synchronisation block,
 * will be infered mechanically.
 */

GLOBAL (int, max_threads, 32)
/*
 * Maximum number of threads if exact number is determined dynamically.
 */

GLOBAL (int, min_parallel_size, 250)
/*
 * Minimum generator size for parallel execution of with-loops.
 */

GLOBAL (int, max_replication_size, 250)
/*
 * Maximum size of array for replication, otherwise the calculation will be
 * executed single-threaded.
 */

GLOBAL (int, max_schedulers, 0)
/*
 * This variable is used to collect the maximum number of schedulers in a
 * single SPMD block/function in order to generate an appropriate number
 * of local data structure sets for the scheduler implementations.
 */

GLOBAL (int, min_parallel_size_per_thread, 8)
/*
 * Minimum generator size per thread for parallel execution of with-loops
 * e.g., max_threads = 4, min_parallel_size_per_thread=8
 *       => generator size must be >= 32 to be executed parallel
 */

GLOBAL (bool, executionmodes_available, FALSE)
/*
 * Flag showing if the sourcecode is tagged with executionmodes or not
 * this information is important for printing it
 */

/*
 * Preprocessor options
 *
 *  refer to -D, -cppI command line options:
 */

GLOBAL (char *, cppvars[MAX_CPP_VARS], {})
/* pointer to respective argv field */

GLOBAL (int, num_cpp_vars, 0)
/* number of preprocessor -D options */

GLOBAL (char *, cppincs[MAX_CPP_INCS], {})
/* pointer to respective argv field */

GLOBAL (int, num_cpp_incs, 0)
/* number of preprocessor -cppI options */

/*
 * C compiler options
 */

GLOBAL (bool, cc_debug, FALSE)
/* Enable/disable inclusion of debug code into object files. */

#ifdef PRODUCTION
GLOBAL (int, cc_optimize, 3)
#else  /* PRODUCTION */
GLOBAL (int, cc_optimize, 0)
#endif /* PRODUCTION */
/* C compiler level of optimization */

/*
 * Command line options for triggering optimizations
 */

GLOBAL (optimize_t, optimize, optimize_init)
/*
 * Set of flags maintaining the activation states of individual optimizations
 */

GLOBAL (bool, valid_ssaform, FALSE)
/*
 * Flag indicating whether ast is in valid ssa form
 */

GLOBAL (int, ssaform_phase, 0)
/*
 * Counter indicating how often the ssa form has been created FROM
 * SCRATCH(!), i.e., how often UndoSSATransform has been called.
 */

GLOBAL (bool, wls_aggressive, FALSE)
/*
 * Per default do not use aggressive WLS
 * except the inner WL has <= wls_bound elems
 */

GLOBAL (int, maxwls, 1)
/*
 * Apply aggressive withloop scalarization regardless of wls_aggressive
 * as long as the size of the inner withloop does not exceed maxwls.
 */

GLOBAL (bool, enforce_ieee, FALSE)
/*
 * Restrict symbolic optimizations on floating point numbers according to
 * IEEE-754 standard
 */

GLOBAL (int, max_overload, 20)
GLOBAL (spec_mode_t, spec_mode, SS_aks)
/*
 * Command line options for specifying particular side conditions
 * for the (new) type inference.
 */

GLOBAL (int, optvar, 50)
GLOBAL (int, inlnum, 1)
GLOBAL (int, unrnum, 2)
GLOBAL (int, wlunrnum, 9)
GLOBAL (int, minarray, 4)
GLOBAL (int, max_optcycles, 10)
GLOBAL (int, max_newgens, 100)
GLOBAL (bool, no_fold_fusion, FALSE)
/*
 * Command line options for specifying particular side conditions
 * for some optimizations.
 */

GLOBAL (int, initial_master_heapsize, 1024)
GLOBAL (int, initial_worker_heapsize, 64)
GLOBAL (int, initial_unified_heapsize, 0)
/*
 * Command line options for specifying particular side conditions
 * of the private heap manager.
 *
 * Why is the default initial top arena size 0?
 *
 * Unfortunately, it turned out that pthread_key_create() allocates
 * some amount of memory, actually one page, without using malloc()
 * but by direct manipulation of the process' break value via sbrk().
 * Since in multi-threaded execution malloc() is always called upon
 * program startup, early intitialization of the heap manager's internal
 * data structures is enforced.
 * Subsequent manipulation of the break value, however, leads to memory
 * fragmentation as the initial top arena cannot be extended smoothly
 * due to the missing page on top of the initially requested heap memory.
 *
 * As long as there is no elegant solution to this problem, there should
 * be no initialization of the top arena, except when an upper boundary
 * for the total memory consumption is known and used for initialization.
 */

/*
 * Print options
 */

GLOBAL (bool, show_idx, FALSE)
/*
 * Show index vector elimination information during printing.
 */

/*
 * Runtime options
 */

GLOBAL (int, print_after_break, TRUE)
GLOBAL (unsigned int, traceflag, TRACE_NONE)
GLOBAL (unsigned int, profileflag, PROFILE_NONE)
GLOBAL (unsigned int, runtimecheck, RUNTIMECHECK_NONE)
GLOBAL (unsigned int, intrinsics, INTRINSIC_NONE)
GLOBAL (unsigned int, cachesim, CACHESIM_NO | CACHESIM_PIPE)
GLOBAL (char, cachesim_host[MAX_FILE_NAME], "")
GLOBAL (char, cachesim_file[MAX_FILE_NAME], "")
GLOBAL (char, cachesim_dir[MAX_FILE_NAME], "")
/*
 * These options insert special code sections into the target C code
 * in order to do additional checks, profiling, etc., or to use intrinsic
 * implementations of some array operations.
 */

/*
 * Profiling information storage facilities
 */

GLOBAL (int, PFfuncntr, 0)
GLOBAL (char *, PFfunnme[PF_MAXFUN], {"main"})
GLOBAL (int, PFfunapcntr[PF_MAXFUN], {})
GLOBAL (int, PFfunapline[PF_MAXFUN][PF_MAXFUNAP], {})
GLOBAL (int, PFfunapmax, 1)

/*
 * Compile time options
 */

GLOBAL (bool, use_efence, FALSE)
/*
 * link executable with ElectricFence (Malloc Debugger)
 */

GLOBAL (bool, cleanup, TRUE)
/*
 * Don't remove temporary files and directory when compiling
 * module/class implementations.
 */

GLOBAL (bool, libstat, FALSE)
/*
 * Don't actually compile, but display library information.
 */

GLOBAL (int, makedeps, 0)
/*
 * Don't actually compile, but infer module dependencies.
 */

GLOBAL (bool, gen_cccall, FALSE)
/*
 * Generate shell script '.sac2c' in current directory
 * that contains the C compiler call produced by sac2c.
 */

GLOBAL (bool, show_syscall, FALSE)
/*
 * Show system calls during compilation.
 */

GLOBAL (compiler_phase_t, break_after, PH_final)
/*
 * Stop compilation process after given phase.
 */

GLOBAL (int, break_cycle_specifier, -1)
/*
 * Additional break specifier that allows a designated break within
 * a particular (optimization) loop.
 */

GLOBAL (char, break_specifier[MAX_BREAK_SPECIFIER], "")
/*
 * Additional break specifier to allow breaking within a particular
 * compiler phase at any position.
 */

GLOBAL (unsigned int, generatelibrary, GENERATELIBRARY_NOTHING)
/*
 * Specify interfaces to generate from SAC modules.
 * Init: nothing, but changed to default standard SAC library
 *       if commandline switch is not used.
 */

GLOBAL (int, padding_overhead_limit, 10)
/*
 * Limit for additional resource allocation due to array padding in
 * percentage. Can be modified via -aplimit option.
 */

GLOBAL (bool, apdiag, FALSE)
/*
 * Diagnostics of array padding may be written into a file.
 * Per default no information is written. Use -apdiag to enable
 * output to "modulename.ap".
 */

GLOBAL (int, apdiag_limit, 20000)
/*
 * Limit for size of diagnostic output given in approximate number of lines.
 * This avoids the creation of extremely huge diagnostic output files.
 */

/*
 *  Compile time information system parameters
 */

GLOBAL (int, errors_cnt, 0)
/*
 * Counter for number of errors
 */
GLOBAL (int, warnings_cnt, 0)
/*
 * Counter for number of warnings
 */

GLOBAL (te_info, *act_info_chn, NULL)
/*
 * Info chain for extended error messages during TC
 */

#ifdef PRODUCTION
GLOBAL (int, verbose_level, 1)
#else  /* PRODUCTION */
GLOBAL (int, verbose_level, 3)
#endif /* PRODUCTION */
/*
 * Verbosity of compile time output
 */

GLOBAL (compiler_phase_t, compiler_phase, PH_setup)
/*
 * Counter for compilation phases
 */

GLOBAL (int, message_indent, 0)
/*
 * used for formatting compile time output
 */

GLOBAL (int, last_indent, 0)
/*
 * used for formatting compile time output
 */

GLOBAL (int, current_line_length, 80)
/*
 * used for formatting compile time output
 */

GLOBAL (char, error_message_buffer[MAX_ERROR_MESSAGE_LENGTH], {})
/*
 * Buffer for generating formatted message
 */

GLOBAL (int, linenum, 1)
/*
 * Current line number
 */

GLOBAL (char *, filename, NULL)
/*
 * Current file name
 */

GLOBAL (char **, compiler_phase_name, compiler_phase_name_init)
/*
 * Names of compiler phases
 */

/*
 * DBUG options
 */

GLOBAL (compiler_phase_t, my_dbug_from, PH_initial)
GLOBAL (compiler_phase_t, my_dbug_to, PH_final)
GLOBAL (int, my_dbug, 0)
GLOBAL (int, my_dbug_active, 0)
GLOBAL (char *, my_dbug_str, NULL)

#ifdef SHOW_MALLOC
GLOBAL (int, malloc_align_step, 0)
GLOBAL (unsigned int, current_allocated_mem, 0)
GLOBAL (unsigned int, max_allocated_mem, 0)
#endif

/*
 * lac2fun, fun2lac conversion
 */

GLOBAL (int *, do_lac2fun, do_lac2fun_init)
/*
 * do_lac2fun[i] > 0: do lac2fun conversion before phase i
 */

GLOBAL (int *, do_fun2lac, do_fun2lac_init)
/*
 * do_fun2lac[i] > 0: do fun2lac conversion after phase i
 */

/*
 * for arg tags
 */

GLOBAL (bool *, ATG_has_shp, ATG_has_shp_init)
GLOBAL (bool *, ATG_has_rc, ATG_has_rc_init)
GLOBAL (bool *, ATG_has_desc, ATG_has_desc_init)
GLOBAL (bool *, ATG_is_in, ATG_is_in_init)
GLOBAL (bool *, ATG_is_out, ATG_is_out_init)
GLOBAL (bool *, ATG_is_inout, ATG_is_inout_init)
GLOBAL (char *, ATG_string, ATG_string_init)

/*
 * Special purpose global variables
 */

GLOBAL (bool, print_objdef_for_header_file, FALSE)
/*
 *  This global variable serves a very special purpose.
 *  When generating separate C-files for functions and global variables,
 *  a header file is required which contains declarations of them all.
 *  In this case the ICM ND_KS_DECL_GLOBAL_ARRAY must be written
 *  differently. This global variable triggers the respective print
 *  function defined in icm2c.c. It is set by PrintModul.
 */

GLOBAL (int, function_counter, 1)
/*
 *  This global variable is used whenever the functions of a module or
 *  class are written to separate files.
 */

GLOBAL (int, object_counter, 0)
/*
 *  This global variable is used whenever the objectinitflags of a module
 *  are written to separate files.
 */

GLOBAL (int, indent, 0)
/*
 *  This global variable is used for indenting while printing SAC-code.
 *  It has to be made global since printing is not only done in the printing-
 *  directory but from within icm2c_xxx.c as well!
 */

GLOBAL (const int *, basetype_size, basetype_size_init)
/*
 * This array of integers keeps the lengths of all simpletypes.
 * It at least is used in compile.c, tile_size_inference.c, and constants.c!
 */

GLOBAL (const char **, prf_string, prf_string_init)
/*
 * This array maintains debug print names of primitive functions.
 */

GLOBAL (int, min_array_rep, MIN_ARRAY_REP_SCL_AKS)
/*
 * This global variable can be used to restrict the set of
 * array representations used by the backend
 */

/*
 * Name tuples
 */

GLOBAL (char **, nt_shape_string, nt_shape_string_init)
GLOBAL (char **, nt_hidden_string, nt_hidden_string_init)
GLOBAL (char **, nt_unique_string, nt_unique_string_init)
/*
 * These character arrays are the macro-name-parts used to select
 * array class and array uniqueness properties.
 */

/*
 * Unknown, new typecheck
 */

GLOBAL (const ct_funptr *, NTCPRF_funtab, NTCPRF_funtab_info)
GLOBAL (const void **, NTCPRF_cffuntab, NTCPRF_cffuntab_info)

/*
 * Primitive zip function tables, previously defined in zipcv.c
 */

GLOBAL (const zipcvfunptr *, zipcv_plus, zipcv_plus_init)
GLOBAL (const zipcvfunptr *, zipcv_minus, zipcv_minus_init)
GLOBAL (const zipcvfunptr *, zipcv_mul, zipcv_mul_init)
GLOBAL (const zipcvfunptr *, zipcv_div, zipcv_divinit)
GLOBAL (const zipcvfunptr *, zipcv_mod, zipcv_mod_init)
GLOBAL (const zipcvfunptr *, zipcv_min, zipcv_min_init)
GLOBAL (const zipcvfunptr *, zipcv_max, zipcv_max_init)
GLOBAL (const zipcvfunptr *, zipcv_and, zipcv_and_init)
GLOBAL (const zipcvfunptr *, zipcv_or, zipcv_or_init)
GLOBAL (const zipcvfunptr *, zipcv_eq, zipcv_eqinit)
GLOBAL (const zipcvfunptr *, zipcv_neq, zipcv_neq_init)
GLOBAL (const zipcvfunptr *, zipcv_le, zipcv_le_init)
GLOBAL (const zipcvfunptr *, zipcv_lt, zipcv_lt_init)
GLOBAL (const zipcvfunptr *, zipcv_gt, zipcv_gt_init)
GLOBAL (const zipcvfunptr *, zipcv_ge, zipcv_ge_init)
GLOBAL (const zipcvfunptr *, zipcv_not, zipcv_not_init)
GLOBAL (const zipcvfunptr *, zipcv_toi, zipcv_toi_init)
GLOBAL (const zipcvfunptr *, zipcv_tof, zipcv_tof_init)
GLOBAL (const zipcvfunptr *, zipcv_tod, zipcv_tod_init)
GLOBAL (const zipcvfunptr *, zipcv_abs, zipcv_abs_init)
GLOBAL (const zipcvfunptr *, zipcv_neg, zipcv_neg_init)

/*
 * Primitive base function tables, previously defined in basecv.c
 */

GLOBAL (const basecvfunptr *, basecv_zero, basecv_zero_init)
GLOBAL (const basecvfunptr *, basecv_one, basecv_one_init)

/*
 * Constant vector copying function table, previously defined in cv2cv.c
 */

GLOBAL (const cv2cvfunptr *, cv2cv, cv2cvinit)

/*
 * Constant vector to scalar conversion function table, previously defined in cv2scalar.c
 */

GLOBAL (const cv2scalarfunptr *, cv2scalar, cv2scalar_init)

/*
 * Constant vector to string conversion function table, previously defined in cv2str.c
 */

GLOBAL (const cv2strfunptr *, cv2str, cv2str_init)

/*
 * Debug string tables
 */

GLOBAL (const char **, mdb_nodetype, mdb_nodetype_init)
GLOBAL (const char **, mdb_prf, mdb_prf_init)
GLOBAL (const char **, mdb_type, mdb_type_init)
GLOBAL (const char **, mdb_statustype, mdb_statustype_init)

/*
 * Resource / configuration management
 */

GLOBAL (target_list_t *, target_list, NULL)
/*
 * When the configuration files are parsed, a dynamic tree like structure
 * is generated and its root is stored in target_list. This dynamic structure
 * is afterwards processed, the relevant information is stored in the static
 * structure config, and the target_list is finally released.
 */

GLOBAL (configuration_t, config, )
/*
 * This global variable permanently stores the desired configuration
 * which is read from the sac2crc file.
 */

#undef GLOBALtype
#undef GLOBALid
#undef GLOBALinit
#undef GLOBAL
