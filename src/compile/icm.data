/*
 *
 * $Log$
 * Revision 3.9  2001/03/14 10:03:37  ben
 * BlockVar Scheduling implemented
 *
 * Revision 3.8  2001/02/06 01:44:03  dkr
 * WL_NOOP_... replaced by WL_ADJUST_OFFSET
 *
 * Revision 3.7  2001/01/30 12:22:22  dkr
 * signature of ICMs WL_NOOP, WL_NOOP__OFFSET modified
 *
 * Revision 3.6  2001/01/24 23:38:28  dkr
 * type of arguments of ICMs MT_SCHEDULER_..._BEGIN, MT_SCHEDULER_..._END
 * changed from int* to char**
 *
 * Revision 3.5  2001/01/22 13:45:21  dkr
 * signature of ICMCompileMT_ADJUST_SCHEDULER modified
 *
 * Revision 3.4  2001/01/19 11:53:48  dkr
 * some with-loop ICMs renamed
 *
 * Revision 3.2  2001/01/10 18:33:07  dkr
 * icm WL_ADJUST_OFFSET renamed into WL_SET_OFFSET
 *
 * Revision 3.1  2000/11/20 18:01:13  sacbase
 * new release made
 *
 * Revision 2.12  2000/08/18 23:02:06  dkr
 * signature of ND_FUN_RET changed
 *
 * Revision 2.11  2000/07/28 11:43:37  cg
 * Added new ICM WL_ASSIGN_NOOP for efficient handling of dummy
 * iteration space segments introduced through array padding.
 *
 * Revision 2.10  2000/07/24 15:06:44  dkr
 * redundant parameter 'line' removed from ICMs for array-prfs
 *
 * Revision 2.9  2000/06/23 16:03:17  dkr
 * ICMs for old with-loop removed
 *
 * Revision 2.8  2000/01/17 16:25:58  cg
 * Removed static and dynamic versions of the ICMs
 * MT_SPMD_[STATIC|DYNAMIC]_MODE_[BEGIN|ALTSEQ|END].
 * General version now is identical with the former dynamic
 * version.
 *
 * Revision 2.7  1999/07/20 16:54:11  jhs
 * Added barrier_id to signature of MT_SYNC_FOLD.
 *
 * Revision 2.6  1999/06/30 16:00:11  jhs
 * Expanded backend, so compilation of fold-with-loops is now possible
 * during SPMD-Blocks containing more than one SYNC-Block.
 *
 * Revision 2.5  1999/06/25 14:52:25  rob
 * Introduce definitions and utility infrastructure for tagged array support.
 *
 * Revision 2.4  1999/06/16 17:10:15  rob
 * add new C macros for TAGGED_ARRAYS.
 *
 * Revision 2.3  1999/06/03 13:19:00  jhs
 * Changed parameters for MT_CONTINUE.
 *
 * ... [eliminated] ...
 *
 * Revision 1.1  1995/03/10  17:26:51  sbs
 * Initial revision
 *
 */


/*
 * ATTENTION!! same variable names within different ICM-argument
 *   specifications should be of the same type even if they are in
 *   different ICM-specifications!!!!
 *   The reason for this restriction lies in the usage of
 *   static variables for them in icm2c.c and BEtest.c
 *   which has to be made in order to spare a second traversal
 *   of icm.data (-> icm2c.c!).
 * 
 * The following ICM's have extra arguments in the argument list
 * specified as second argument of ICM_END :
 *  - ND_FUN_RET : arg_info !
 */

#if defined(ND_FUN_DEC) || defined(ICM_ALL)
ICM_DEF( ND_FUN_DEC, TRACE_NONE)
  ICM_STR(name)
  ICM_STR(rettype)
  ICM_INT(narg)
  ICM_VAR((3*narg), tyarg)
ICM_END( ND_FUN_DEC, (name, rettype, narg, tyarg))
#endif

#if defined(ND_FUN_AP) || defined(ICM_ALL)
ICM_DEF( ND_FUN_AP, TRACE_FUN)
  ICM_STR(name)
  ICM_STR(retname)
  ICM_INT(narg)
  ICM_VAR((2*narg), arg)
ICM_END( ND_FUN_AP, (name, retname, narg, arg))
#endif

#if defined(ND_FUN_RET) || defined(ICM_ALL)
ICM_DEF( ND_FUN_RET, TRACE_FUN)
  ICM_STR(retname)
  ICM_INT(narg)
  ICM_VAR((3*narg), arg)
ICM_END( ND_FUN_RET, (retname, narg, arg, arg_info))
#endif

#if defined(ND_CREATE_CONST_ARRAY_S) || defined(ICM_ALL)
ICM_DEF( ND_CREATE_CONST_ARRAY_S, TRACE_NONE)
  ICM_STR(name)
  ICM_INT(dim)
  ICM_VAR(dim, s)
ICM_END( ND_CREATE_CONST_ARRAY_S, (name, dim, s))
#endif

#if defined(ND_CREATE_CONST_ARRAY_H) || defined(ICM_ALL)
ICM_DEF( ND_CREATE_CONST_ARRAY_H, TRACE_NONE)
  ICM_STR(name)
  ICM_STR(copyfun)
  ICM_INT(dim)
  ICM_VAR(dim, A)
ICM_END( ND_CREATE_CONST_ARRAY_H, (name, copyfun, dim, A))
#endif

#if defined(ND_CREATE_CONST_ARRAY_A) || defined(ICM_ALL)
ICM_DEF( ND_CREATE_CONST_ARRAY_A, TRACE_NONE)
  ICM_STR(name)
  ICM_INT(length)
  ICM_INT(dim)
  ICM_VAR( dim, A)
ICM_END( ND_CREATE_CONST_ARRAY_A, (name, length, dim, A))
#endif

#ifdef TAGGED_ARRAYS 
#if defined(ND_DECL_AKS) || defined(ICM_ALL)
ICM_DEF( ND_DECL_AKS, TRACE_NONE)
  ICM_STR(type)
  ICM_STR(nt)
  ICM_INT(dim)
  ICM_VAR( dim, s)
ICM_END( ND_DECL_AKS, (type, nt, dim, s))
#endif


#else  /* TAGGED_ARRAYS */

#if defined(ND_KS_DECL_ARRAY) || defined(ICM_ALL)
ICM_DEF( ND_KS_DECL_ARRAY, TRACE_NONE)
  ICM_STR(type)
  ICM_STR(name)
  ICM_INT(dim)
  ICM_VAR( dim, s)
ICM_END( ND_KS_DECL_ARRAY, (type, name, dim, s))
#endif

#endif /* TAGGED_ARRAYS */

#if defined(ND_KS_DECL_GLOBAL_ARRAY) || defined(ICM_ALL)
ICM_DEF( ND_KS_DECL_GLOBAL_ARRAY, TRACE_NONE)
  ICM_STR(type)
  ICM_STR(name)
  ICM_INT(dim)
  ICM_VAR( dim, s)
ICM_END( ND_KS_DECL_GLOBAL_ARRAY, (type, name, dim, s))
#endif

#if defined(ND_KD_DECL_EXTERN_ARRAY) || defined(ICM_ALL)
ICM_DEF( ND_KD_DECL_EXTERN_ARRAY, TRACE_NONE)
  ICM_STR(type)
  ICM_STR(name)
  ICM_INT(dim)
ICM_END( ND_KD_DECL_EXTERN_ARRAY, (type, name, dim))
#endif

#if defined(ND_KS_DECL_ARRAY_ARG) || defined(ICM_ALL)
ICM_DEF( ND_KS_DECL_ARRAY_ARG, TRACE_NONE)
  ICM_STR(name)
  ICM_INT(dim)
  ICM_VAR( dim, s)
ICM_END( ND_KS_DECL_ARRAY_ARG, (name, dim, s))
#endif

#if defined(ND_KD_SET_SHAPE) || defined(ICM_ALL)
ICM_DEF( ND_KD_SET_SHAPE, TRACE_NONE)
  ICM_STR(name)
  ICM_INT(dim)
  ICM_VAR( dim, s)
ICM_END( ND_KD_SET_SHAPE, (name, dim, s))
#endif

#if defined(ND_KD_PSI_CxA_S) || defined(ICM_ALL)
ICM_DEF( ND_KD_PSI_CxA_S, TRACE_PRF)
  ICM_STR(a)
  ICM_STR(res)
  ICM_INT(dim)
  ICM_VAR( dim, vi)
ICM_END( ND_KD_PSI_CxA_S, (a, res, dim, vi))
#endif

#if defined(ND_KD_PSI_VxA_S) || defined(ICM_ALL)
ICM_DEF( ND_KD_PSI_VxA_S, TRACE_PRF)
  ICM_STR(a)
  ICM_STR(res)
  ICM_INT(dim)
  ICM_STR( v)
ICM_END( ND_KD_PSI_VxA_S, (a, res, dim, v))
#endif

#if defined(ND_KD_PSI_CxA_A) || defined(ICM_ALL)
ICM_DEF( ND_KD_PSI_CxA_A, TRACE_PRF)
  ICM_INT(dima)
  ICM_STR(a)
  ICM_STR(res)
  ICM_INT(dimv)
  ICM_VAR( dimv, vi)
ICM_END( ND_KD_PSI_CxA_A, (dima, a, res, dimv, vi))
#endif

#if defined(ND_KD_PSI_VxA_A) || defined(ICM_ALL)
ICM_DEF( ND_KD_PSI_VxA_A, TRACE_PRF)
  ICM_INT(dima)
  ICM_STR(a)
  ICM_STR(res)
  ICM_INT(dimv)
  ICM_STR( v)
ICM_END( ND_KD_PSI_VxA_A, (dima, a, res, dimv, v))
#endif

#if defined(ND_KD_TAKE_CxA_A) || defined(ICM_ALL)
ICM_DEF( ND_KD_TAKE_CxA_A, TRACE_PRF)
  ICM_INT(dima)
  ICM_STR(a)
  ICM_STR(res)
  ICM_INT(dimv)
  ICM_VAR( dimv, vi)
ICM_END( ND_KD_TAKE_CxA_A, (dima, a, res, dimv, vi))
#endif

#if defined(ND_KD_DROP_CxA_A) || defined(ICM_ALL)
ICM_DEF( ND_KD_DROP_CxA_A, TRACE_PRF)
  ICM_INT(dima)
  ICM_STR(a)
  ICM_STR(res)
  ICM_INT(dimv)
  ICM_VAR( dimv, vi)
ICM_END( ND_KD_DROP_CxA_A, (dima, a, res, dimv, vi))
#endif

#if defined(ND_KD_CAT_SxAxA_A) || defined(ICM_ALL)
ICM_DEF( ND_KD_CAT_SxAxA_A, TRACE_PRF)
  ICM_INT(dima)
  ICM_VAR( 2,ar)
  ICM_STR(res)
  ICM_INT(catdim)
ICM_END( ND_KD_CAT_SxAxA_A, (dima, ar, res, catdim))
#endif

#if defined(ND_KD_ROT_CxSxA_A) || defined(ICM_ALL)
ICM_DEF( ND_KD_ROT_CxSxA_A, TRACE_PRF)
  ICM_INT( rotdim)
  ICM_VAR( 1, numstr)
  ICM_INT(dima)
  ICM_STR(a)
  ICM_STR(res)
ICM_END( ND_KD_ROT_CxSxA_A, (rotdim, numstr, dima, a, res))
#endif

#if defined(ND_PRF_MODARRAY_AxCxS_CHECK_REUSE) || defined(ICM_ALL)
ICM_DEF( ND_PRF_MODARRAY_AxCxS_CHECK_REUSE, TRACE_PRF)
  ICM_STR(res_type)
  ICM_INT(dimres)
  ICM_STR(res)
  ICM_STR(old)
  ICM_VAR( 1, value)
  ICM_INT(dimv)
  ICM_VAR( dimv, vi)
ICM_END( ND_PRF_MODARRAY_AxCxS_CHECK_REUSE, (res_type, dimres, res, old, value, dimv, vi))
#endif

#if defined(ND_PRF_MODARRAY_AxCxS) || defined(ICM_ALL)
ICM_DEF( ND_PRF_MODARRAY_AxCxS, TRACE_PRF)
  ICM_STR(res_type)
  ICM_INT(dimres)
  ICM_STR(res)
  ICM_STR(old)
  ICM_VAR( 1, value)
  ICM_INT(dimv)
  ICM_VAR( dimv, vi)
ICM_END( ND_PRF_MODARRAY_AxCxS, (res_type, dimres, res, old, value, dimv, vi))
#endif

#if defined(ND_PRF_MODARRAY_AxVxS_CHECK_REUSE) || defined(ICM_ALL)
ICM_DEF( ND_PRF_MODARRAY_AxVxS_CHECK_REUSE, TRACE_PRF)
  ICM_STR(res_type)
  ICM_INT(dimres)
  ICM_STR(res)
  ICM_STR(old)
  ICM_VAR( 1, value)
  ICM_INT(dim)
  ICM_STR(v)
ICM_END( ND_PRF_MODARRAY_AxVxS_CHECK_REUSE, (res_type,dimres,res,old,value,dim,v))
#endif

#if defined(ND_PRF_MODARRAY_AxVxS) || defined(ICM_ALL)
ICM_DEF( ND_PRF_MODARRAY_AxVxS, TRACE_PRF)
  ICM_STR(res_type)
  ICM_INT(dimres)
  ICM_STR(res)
  ICM_STR(old)
  ICM_VAR( 1, value)
  ICM_INT(dim)
  ICM_STR(v)
ICM_END( ND_PRF_MODARRAY_AxVxS, (res_type,dimres,res,old,value,dim,v))
#endif

#if defined(ND_PRF_MODARRAY_AxCxA_CHECK_REUSE) || defined(ICM_ALL)
ICM_DEF( ND_PRF_MODARRAY_AxCxA_CHECK_REUSE, TRACE_PRF)
  ICM_STR(res_type)
  ICM_INT(dimres)
  ICM_STR(res)
  ICM_STR(old)
  ICM_STR( val)
  ICM_INT(dimv)
  ICM_VAR( dimv, vi)
ICM_END( ND_PRF_MODARRAY_AxCxA_CHECK_REUSE, (res_type,dimres,res,old,val,dimv,vi))
#endif

#if defined(ND_PRF_MODARRAY_AxCxA) || defined(ICM_ALL)
ICM_DEF( ND_PRF_MODARRAY_AxCxA, TRACE_PRF)
  ICM_STR(res_type)
  ICM_INT(dimres)
  ICM_STR(res)
  ICM_STR(old)
  ICM_STR(val)
  ICM_INT(dimv)
  ICM_VAR( dimv, vi)
ICM_END( ND_PRF_MODARRAY_AxCxA, (res_type,dimres,res,old,val,dimv,vi))
#endif

#if defined(ND_PRF_MODARRAY_AxVxA_CHECK_REUSE) || defined(ICM_ALL)
ICM_DEF( ND_PRF_MODARRAY_AxVxA_CHECK_REUSE, TRACE_PRF)
  ICM_STR(res_type)
  ICM_INT(dimres)
  ICM_STR(res)
  ICM_STR(old)
  ICM_STR( val)
  ICM_INT(dim)
  ICM_STR( v)
ICM_END( ND_PRF_MODARRAY_AxVxA_CHECK_REUSE, (res_type,dimres,res,old,val,dim,v))
#endif
 
#if defined(ND_PRF_MODARRAY_AxVxA) || defined(ICM_ALL)
ICM_DEF( ND_PRF_MODARRAY_AxVxA, TRACE_PRF)
  ICM_STR(res_type)
  ICM_INT(dimres)
  ICM_STR(res)
  ICM_STR(old)
  ICM_STR(val)
  ICM_INT(dim)
  ICM_STR( v)
ICM_END( ND_PRF_MODARRAY_AxVxA, (res_type,dimres,res,old,val,dim,v))
#endif

#if defined(ND_KS_VECT2OFFSET) || defined(ICM_ALL)
ICM_DEF( ND_KS_VECT2OFFSET, TRACE_PRF)
  ICM_STR( off_name)
  ICM_STR( arr_name)
  ICM_INT( dim)
  ICM_INT( dims)
  ICM_VAR( dims, s)
ICM_END( ND_KS_VECT2OFFSET, (off_name, arr_name, dim, dims, s))
#endif


/*
 * ICMs for compilation of new with-loop
 */

#if defined(WL_BEGIN__OFFSET) || defined(ICM_ALL)
ICM_DEF( WL_BEGIN__OFFSET, TRACE_NONE)
  ICM_STR(target)
  ICM_STR(idx_vec)
  ICM_INT(dims)
ICM_END( WL_BEGIN__OFFSET, (target, idx_vec, dims))
#endif

#if defined(WL_BEGIN) || defined(ICM_ALL)
ICM_DEF( WL_BEGIN, TRACE_NONE)
  ICM_STR(target)
  ICM_STR(idx_vec)
  ICM_INT(dims)
ICM_END( WL_BEGIN, (target, idx_vec, dims))
#endif

#if defined(WL_END__OFFSET) || defined(ICM_ALL)
ICM_DEF( WL_END__OFFSET, TRACE_NONE)
  ICM_STR(target)
  ICM_STR(idx_vec)
  ICM_INT(dims)
ICM_END( WL_END__OFFSET, (target, idx_vec, dims))
#endif

#if defined(WL_END) || defined(ICM_ALL)
ICM_DEF( WL_END, TRACE_NONE)
  ICM_STR(target)
  ICM_STR(idx_vec)
  ICM_INT(dims)
ICM_END( WL_END, (target, idx_vec, dims))
#endif

#if defined(WL_INIT_OFFSET) || defined(ICM_ALL)
ICM_DEF( WL_INIT_OFFSET, TRACE_NONE)
  ICM_INT(dims_target)
  ICM_STR(target)
  ICM_STR(idx_vec)
  ICM_INT(dims)
ICM_END( WL_INIT_OFFSET, (dims_target, target, idx_vec, dims))
#endif

#if defined(WL_ASSIGN) || defined(ICM_ALL)
ICM_DEF( WL_ASSIGN, TRACE_NONE)
  ICM_INT(dims_expr)
  ICM_STR(expr)
  ICM_INT(dims_target)
  ICM_STR(target)
  ICM_STR(idx_vec)
  ICM_INT(dims)
  ICM_VAR(dims, idx_scalars)
ICM_END( WL_ASSIGN, (dims_expr, expr, dims_target, target, idx_vec, dims, idx_scalars))
#endif

#if defined(WL_ASSIGN__INIT) || defined(ICM_ALL)
ICM_DEF( WL_ASSIGN__INIT, TRACE_NONE)
  ICM_INT(dims_target)
  ICM_STR(target)
  ICM_STR(idx_vec)
  ICM_INT(dims)
  ICM_VAR(dims, idx_scalars)
ICM_END( WL_ASSIGN__INIT, (dims_target, target, idx_vec, dims, idx_scalars))
#endif

#if defined(WL_ASSIGN__COPY) || defined(ICM_ALL)
ICM_DEF( WL_ASSIGN__COPY, TRACE_NONE)
  ICM_STR(source)
  ICM_INT(dims_target)
  ICM_STR(target)
  ICM_STR(idx_vec)
  ICM_INT(dims)
  ICM_VAR(dims, idx_scalars)
ICM_END( WL_ASSIGN__COPY, (source, dims_target, target, idx_vec, dims, idx_scalars))
#endif

#if defined(WL_FOLD__OFFSET) || defined(ICM_ALL)
ICM_DEF( WL_FOLD__OFFSET, TRACE_NONE)
  ICM_INT(dims_target)
  ICM_STR(target)
  ICM_STR(idx_vec)
  ICM_INT(dims)
  ICM_VAR(dims, idx_scalars)
ICM_END( WL_FOLD__OFFSET, (dims_target, target, idx_vec, dims, idx_scalars))
#endif

#if defined(WL_FOLD) || defined(ICM_ALL)
ICM_DEF( WL_FOLD, TRACE_NONE)
  ICM_INT(dims_target)
  ICM_STR(target)
  ICM_STR(idx_vec)
  ICM_INT(dims)
  ICM_VAR(dims, idx_scalars)
ICM_END( WL_FOLD, (dims_target, target, idx_vec, dims, idx_scalars))
#endif

#if defined(WL_ADJUST_OFFSET) || defined(ICM_ALL)
ICM_DEF( WL_ADJUST_OFFSET, TRACE_NONE)
  ICM_INT(dim)
  ICM_INT(dims_target)
  ICM_STR(target)
  ICM_STR(idx_vec)
  ICM_INT(dims)
  ICM_VAR(dims, idx_scalars)
ICM_END( WL_ADJUST_OFFSET, (dim, dims_target, target, idx_vec, dims, idx_scalars))
#endif

#if defined(WL_SET_OFFSET) || defined(ICM_ALL)
ICM_DEF( WL_SET_OFFSET, TRACE_NONE)
  ICM_INT(dim)
  ICM_INT(first_block_dim)
  ICM_INT(dims_target)
  ICM_STR(target)
  ICM_STR(idx_vec)
  ICM_INT(dims)
  ICM_VAR(dims, idx_scalars)
ICM_END( WL_SET_OFFSET, (dim, first_block_dim,
                         dims_target, target, idx_vec, dims, idx_scalars))
#endif



/*
 * ICMs for compilation of multi-threaded applications
 */

#if defined(MT_SPMD_FUN_DEC) || defined(ICM_ALL)
ICM_DEF( MT_SPMD_FUN_DEC, TRACE_NONE)
  ICM_STR(name)
  ICM_STR(from)
  ICM_INT(narg)
  ICM_VAR((3*narg), vararg)
ICM_END( MT_SPMD_FUN_DEC, (name, from, narg, vararg))
#endif

#if defined(MT_SPMD_FUN_RET) || defined(ICM_ALL)
ICM_DEF( MT_SPMD_FUN_RET, TRACE_NONE)
  ICM_INT(barrier_id)
  ICM_INT(narg)
  ICM_VAR((2*narg), vararg)
ICM_END( MT_SPMD_FUN_RET, (barrier_id, narg, vararg))
#endif

#if defined(MT_START_SYNCBLOCK) || defined(ICM_ALL)
ICM_DEF( MT_START_SYNCBLOCK, TRACE_NONE)
  ICM_INT(barrier_id)
  ICM_INT(narg)
  ICM_VAR((3*narg), vararg)
ICM_END( MT_START_SYNCBLOCK, (barrier_id, narg, vararg))
#endif

#if defined(MT_SYNC_NONFOLD) || defined(ICM_ALL)
ICM_DEF( MT_SYNC_NONFOLD, TRACE_NONE)
  ICM_INT(barrier_id)
ICM_END( MT_SYNC_NONFOLD, (barrier_id))
#endif

#if defined(MT_SYNC_FOLD) || defined(ICM_ALL)
ICM_DEF( MT_SYNC_FOLD, TRACE_NONE)
  ICM_INT(barrier_id)
  ICM_INT(narg)
  ICM_VAR((4*narg), vararg)
ICM_END( MT_SYNC_FOLD, (barrier_id, narg, vararg))
#endif

#if defined(MT_SYNC_ONEFOLD) || defined(ICM_ALL)
ICM_DEF( MT_SYNC_ONEFOLD, TRACE_NONE)
  ICM_INT(barrier_id)
  ICM_STR(foldtype)
  ICM_STR(accu_var)
  ICM_STR(tmp_var)
  ICM_STR(foldop)
ICM_END( MT_SYNC_ONEFOLD, (barrier_id, foldtype, accu_var, tmp_var, foldop))
#endif

#if defined(MT_SYNC_ONEFOLD_NONFOLD) || defined(ICM_ALL)
ICM_DEF( MT_SYNC_ONEFOLD_NONFOLD, TRACE_NONE)
  ICM_STR(foldtype)
  ICM_STR(accu_var)
  ICM_STR(tmp_var)
  ICM_STR(foldop)
ICM_END( MT_SYNC_ONEFOLD_NONFOLD, (foldtype, accu_var, tmp_var, foldop))
#endif

#if defined(MT_SYNC_FOLD_NONFOLD) || defined(ICM_ALL)
ICM_DEF( MT_SYNC_FOLD_NONFOLD, TRACE_NONE)
  ICM_INT(narg)
  ICM_VAR((4*narg), vararg)
ICM_END( MT_SYNC_FOLD_NONFOLD, (narg, vararg))
#endif

#if defined(MT_MASTER_SEND_FOLDRESULTS) || defined(ICM_ALL)
ICM_DEF( MT_MASTER_SEND_FOLDRESULTS, TRACE_NONE)
  ICM_INT(nfoldargs)
  ICM_VAR((2*nfoldargs), foldargs)
ICM_END( MT_MASTER_SEND_FOLDRESULTS, (nfoldargs, foldargs))
#endif

#if defined(MT_MASTER_RECEIVE_FOLDRESULTS) || defined(ICM_ALL)
ICM_DEF( MT_MASTER_RECEIVE_FOLDRESULTS, TRACE_NONE)
  ICM_INT(nfoldargs)
  ICM_VAR((2*nfoldargs), foldargs)
ICM_END( MT_MASTER_RECEIVE_FOLDRESULTS, (nfoldargs, foldargs))
#endif

#if defined(MT_MASTER_SEND_SYNCARGS) || defined(ICM_ALL)
ICM_DEF( MT_MASTER_SEND_SYNCARGS, TRACE_NONE)
  ICM_INT(nsyncargs)
  ICM_VAR(nsyncargs, syncargs)
ICM_END( MT_MASTER_SEND_SYNCARGS, (nsyncargs, syncargs))
#endif

#if defined(MT_MASTER_RECEIVE_SYNCARGS) || defined(ICM_ALL)
ICM_DEF( MT_MASTER_RECEIVE_SYNCARGS, TRACE_NONE)
  ICM_INT(nsyncargs)
  ICM_VAR(nsyncargs, syncargs)
ICM_END( MT_MASTER_RECEIVE_SYNCARGS, (nsyncargs, syncargs))
#endif

#if defined(MT_CONTINUE) || defined(ICM_ALL)
ICM_DEF( MT_CONTINUE, TRACE_NONE)
  ICM_INT(nfoldargs)
  ICM_VAR((2*nfoldargs), vararg)
  ICM_INT(nsyncargs)
  ICM_VAR((nsyncargs), syncargs)
ICM_END( MT_CONTINUE, (nfoldargs, vararg, nsyncargs, syncargs))
#endif

#if defined(MT_SPMD_BEGIN) || defined(ICM_ALL)
ICM_DEF( MT_SPMD_BEGIN, TRACE_NONE)
  ICM_STR(name)
ICM_END( MT_SPMD_BEGIN, (name))
#endif

#if defined(MT_SPMD_ALTSEQ) || defined(ICM_ALL)
ICM_DEF( MT_SPMD_ALTSEQ, TRACE_NONE)
  ICM_STR(name)
ICM_END( MT_SPMD_ALTSEQ, (name))
#endif

#if defined(MT_SPMD_STATIC_MODE_END) || defined(ICM_ALL)
ICM_DEF( MT_SPMD_END, TRACE_NONE)
  ICM_STR(name)
ICM_END( MT_SPMD_END, (name))
#endif


#if defined(MT_SPMD_SETUP) || defined(ICM_ALL)
ICM_DEF( MT_SPMD_SETUP, TRACE_NONE)
  ICM_STR(name)
  ICM_INT(narg)
  ICM_VAR((3*narg), vararg)
ICM_END( MT_SPMD_SETUP, (name, narg, vararg))
#endif

#if defined(MT_SPMD_PRESET) || defined(ICM_ALL)
ICM_DEF( MT_SPMD_PRESET, TRACE_NONE)
  ICM_STR(name)
  ICM_INT(narg)
  ICM_VAR((2*narg), vararg)
ICM_END( MT_SPMD_PRESET, (name, narg, vararg))
#endif

#if defined(MT_ADJUST_SCHEDULER) || defined(ICM_ALL)
ICM_DEF( MT_ADJUST_SCHEDULER, TRACE_NONE)
  ICM_INT(current_dim)
  ICM_INT(array_dim)
  ICM_INT(lower)
  ICM_INT(upper)
  ICM_INT(unrolling)
  ICM_STR(array)
  ICM_INT(adjust_offset)
ICM_END( MT_ADJUST_SCHEDULER, (current_dim, array_dim, lower, upper, unrolling, array, adjust_offset))
#endif



/*
 * ICMs for implementing scheduling strategies
 */

#if defined(MT_SCHEDULER_BEGIN) || defined(ICM_ALL)
ICM_DEF( MT_SCHEDULER_BEGIN, TRACE_NONE)
  ICM_INT(dim)
  ICM_VAR((2*dim), vararg)
ICM_END( MT_SCHEDULER_BEGIN, (dim, vararg))
#endif

#if defined(MT_SCHEDULER_END) || defined(ICM_ALL)
ICM_DEF( MT_SCHEDULER_END, TRACE_NONE)
  ICM_INT(dim)
  ICM_VAR((2*dim), vararg)
ICM_END( MT_SCHEDULER_END, (dim, vararg))
#endif


#if defined(MT_SCHEDULER_Block_BEGIN) || defined(ICM_ALL)
ICM_DEF( MT_SCHEDULER_Block_BEGIN, TRACE_NONE)
  ICM_INT(dim)
  ICM_VAR((4*dim), vararg)
ICM_END( MT_SCHEDULER_Block_BEGIN, (dim, vararg))
#endif

#if defined(MT_SCHEDULER_Block_END) || defined(ICM_ALL)
ICM_DEF( MT_SCHEDULER_Block_END, TRACE_NONE)
  ICM_INT(dim)
  ICM_VAR((4*dim), vararg)
ICM_END( MT_SCHEDULER_Block_END, (dim, vararg))
#endif


#if defined(MT_SCHEDULER_BlockVar_BEGIN) || defined(ICM_ALL)
ICM_DEF( MT_SCHEDULER_BlockVar_BEGIN, TRACE_NONE)
  ICM_INT(dim)
  ICM_VAR((4*dim), vararg)
ICM_END( MT_SCHEDULER_BlockVar_BEGIN, (dim, vararg))
#endif

#if defined(MT_SCHEDULER_BlockVar_END) || defined(ICM_ALL)
ICM_DEF( MT_SCHEDULER_BlockVar_END, TRACE_NONE)
  ICM_INT(dim)
  ICM_VAR((4*dim), vararg)
ICM_END( MT_SCHEDULER_BlockVar_END, (dim, vararg))
#endif
