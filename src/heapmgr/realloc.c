/*
 *
 * $Log$
 * Revision 1.2  2000/01/17 16:25:58  cg
 * Conventional heap management functions now have their
 * original prototypes using size_t.
 *
 * Revision 1.1  2000/01/03 17:33:17  cg
 * Initial revision
 *
 *
 */

/*
 * Revision 1.3  1999/09/17 14:33:34  cg
 * New version of SAC heap manager:
 *  - no special API functions for top arena.
 *  - coalascing is always done deferred.
 *  - no doubly linked free lists any more.
 *
 * Revision 1.2  1999/07/16 09:41:16  cg
 * Added facilities for heap management diagnostics.
 *
 * Revision 1.1  1999/07/08 12:28:56  cg
 * Initial revision
 *
 *
 */

/*****************************************************************************
 *
 * file:   realloc.c
 *
 * prefix: none
 *
 * description:
 *
 *   This file provides a SAC heap manager specific implementations of the
 *   function realloc().
 *
 *   Although programs generated by sac2c will never use this function,
 *   it is nevertheless mandatory because functions from external module
 *   or class implementation might rely on it.
 *
 *****************************************************************************/

#include <string.h>

#include "heapmgr.h"

/******************************************************************************
 *
 * function:
 *   void *realloc(void *ptr, size_t size)
 *
 * description:
 *
 *   SAC heap manager specific implementation of realloc().
 *
 *
 *
 ******************************************************************************/

void *
realloc (void *ptr, size_t size)
{
    void *mem;
    SAC_HM_size_unit_t old_size_units;
    SAC_HM_arena_t *arena;

    DIAG_INC_LOCK (SAC_HM_call_realloc);

    if (ptr == NULL) {
        DIAG_DEC_LOCK (SAC_HM_call_malloc);
        return (malloc (size));
    }

    if (size == 0) {
        free (ptr);
        return (NULL);
    }

    arena = SAC_HM_ADDR_ARENA (ptr);

    if (arena->num < SAC_HM_NUM_SMALLCHUNK_ARENAS) {
        old_size_units = arena->min_chunk_size;
        if (size <= old_size_units) {
            /*
             * The given memory location is in a small chunk arena and the requested
             * new memory size is less than the old one.
             *  -> do nothing
             */
            return (ptr);
        }
    } else {
        old_size_units = SAC_HM_LARGECHUNK_SIZE (((SAC_HM_header_t *)ptr) - 2);
    }

    DIAG_DEC_LOCK (SAC_HM_call_malloc);
    mem = malloc (size);

    mem = memcpy (mem, ptr, SAC_MIN (old_size_units * SAC_HM_UNIT_SIZE, size));

    free (ptr);

    return (mem);
}
