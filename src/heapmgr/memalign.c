/*
 *
 * $Log$
 * Revision 1.2  2000/01/17 16:25:58  cg
 * Conventional heap management functions now have their
 * original prototypes using size_t.
 *
 * Revision 1.1  2000/01/03 17:33:17  cg
 * Initial revision
 *
 *
 */

/*
 * Revision 1.3  1999/09/17 14:33:34  cg
 * New version of SAC heap manager:
 *  - no special API functions for top arena.
 *  - coalascing is always done deferred.
 *  - no doubly linked free lists any more.
 *
 * Revision 1.2  1999/07/16 09:41:16  cg
 * Added facilities for heap management diagnostics.
 *
 * Revision 1.1  1999/07/08 12:28:56  cg
 * Initial revision
 *
 *
 */

/*****************************************************************************
 *
 * file:   memalign.c
 *
 * prefix: none
 *
 * description:
 *
 *   This file provides SAC heap manager specific implementations of the
 *   functions memalign() and valloc(); these guarantee the allocation of
 *   memory chunks with particular alignments.
 *
 *   Although programs generated by sac2c will never use these functions,
 *   they are nevertheless mandatory because functions from external module
 *   or class implementation might rely on them.
 *
 *****************************************************************************/

#include <unistd.h>

#include "heapmgr.h"

/******************************************************************************
 *
 * function:
 *   void *memalign(size_t alignment, size_t size)
 *
 * description:
 *
 *   SAC heap manager specific implementation of memalign().
 *
 ******************************************************************************/

void *
memalign (size_t alignment, size_t size)
{
    void *mem;
    size_t misalign, size_needed;
    SAC_HM_header_t *freep, *prefixp;
    SAC_HM_arena_t *arena;
    SAC_HM_size_unit_t offset_units;

    DIAG_INC_LOCK (SAC_HM_call_memalign);

    if (alignment <= SAC_HM_UNIT_SIZE) {
        /* automatic alignment */
        DIAG_DEC_LOCK (SAC_HM_call_malloc);
        return (malloc (size));
    }

    /* worst case allocation for a posteriori alignment */
    size_needed = SAC_MAX (size + alignment + (SAC_HM_UNIT_SIZE + SAC_HM_UNIT_SIZE),
                           SAC_HM_ARENA_5_MINCS * SAC_HM_UNIT_SIZE);

    DIAG_DEC_LOCK (SAC_HM_call_malloc);
    mem = malloc (size_needed);

    misalign = ((size_t)mem) % alignment;

    if (misalign == 0) {
        /* Memory is already correctly aligned. */
        return (mem);
    }

    offset_units = (alignment - misalign) / SAC_HM_UNIT_SIZE;

    if (offset_units < 2) {
        /*
         * Offset is too small to host administration info for free prefix.
         */
        offset_units += alignment / SAC_HM_UNIT_SIZE;
    }

    prefixp = ((SAC_HM_header_t *)mem) - 2;
    arena = SAC_HM_LARGECHUNK_ARENA (prefixp);
    freep = prefixp + offset_units;

    /*
     * Setup memory location to be returned.
     */

    SAC_HM_LARGECHUNK_SIZE (freep) = SAC_HM_LARGECHUNK_SIZE (prefixp) - offset_units;
    SAC_HM_LARGECHUNK_ARENA (freep) = arena;
    SAC_HM_LARGECHUNK_PREVSIZE (freep) = offset_units;

    /*
     * Setup memory location returned by malloc();
     * this will now be de-allocated again using free().
     */

    SAC_HM_LARGECHUNK_SIZE (prefixp) = offset_units;

    free (prefixp + 2);

    return ((void *)(freep + 2));
}

/******************************************************************************
 *
 * function:
 *   void *valloc(size_t size)
 *
 * description:
 *
 *   SAC heap manager specific implementation of valloc().
 *
 *
 *
 ******************************************************************************/

void *
valloc (size_t size)
{
    DIAG_INC_LOCK (SAC_HM_call_valloc);
    DIAG_DEC_LOCK (SAC_HM_call_memalign);

    return (memalign (getpagesize (), size));
}
