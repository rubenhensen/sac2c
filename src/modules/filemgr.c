/*
 *
 * $Log$
 * Revision 1.11  1997/03/19 13:48:03  cg
 * new function AbsolutePathname() added.
 * Converted  to single tmp directory tmp_dirname instaed of build_dirname
 * and store_dirname
 *
 * Revision 1.10  1997/03/11  16:25:33  cg
 * Improved function AbsolutePathname: Now, minimal absolute pathnames
 * are constructed from relative path names, removing leading ../../
 *
 * Revision 1.9  1996/09/11  06:22:51  cg
 * Modified construction of paths.
 * Now: 1. paths added by command line option, 2. cwd, 3.shell variable
 *
 * Revision 1.8  1996/01/22  17:31:38  cg
 * modified InitPaths
 *
 * Revision 1.7  1996/01/07  16:58:23  cg
 * handling of temporary directories modified.
 * cccall.c now only needs 2 of these
 *
 * Revision 1.6  1996/01/05  12:36:29  cg
 * added global variables tmp_dirname, store_dirname, build_dirname
 * and functions WriteOpen, CreateTmpDirectories, RemoveDirectory
 *
 * Revision 1.5  1995/04/10  11:08:02  sbs
 * some DBUG_PRINTs inserted
 * FindFile only looks for the explicit name if preceeded by "/"
 * i.e. an absolute path is given
 *
 * Revision 1.4  1995/04/07  09:36:35  sbs
 * bug resulting from change FILE * => char * eliminated
 *
 * Revision 1.3  1995/04/05  17:24:16  sbs
 * GenLinkList inserted
 *
 * Revision 1.2  1995/02/22  14:14:36  hw
 * changed FindFile (now look first for name and later have a look at path )
 *
 * Revision 1.1  1994/12/11  17:33:27  sbs
 * Initial revision
 *
 *
 */

#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>

#include "dbug.h"
#include "internal_lib.h"
#include "Error.h"

#include "filemgr.h"

static char path_bufs[3][MAX_PATH_LEN];
static int bufsize[3];

char *tmp_dirname = NULL;
/* directory for storing files generated by sac2c until      */
/* the final compilation steps are completed.                */

/*
 *
 *  functionname  : FindFile
 *  arguments     :
 *  description   :
 *  global vars   : ---
 *  internal funs : ---
 *  external funs : ---
 *  macros        : ---
 *
 *  remarks       :
 *
 */

char *
FindFile (pathkind p, char *name)
{
    FILE *file = NULL;
    static char buffer[MAX_FILE_NAME];
    static char buffer2[MAX_PATH_LEN];
    char *path;
    char *result = NULL;

    DBUG_ENTER ("FindFile");

    if (name[0] == '/') { /* absolute path specified! */
        strcpy (buffer, name);
        file = fopen (buffer, "r");
    } else {
        strcpy (buffer2, path_bufs[p]);
        path = strtok (buffer2, ":");
        while ((file == NULL) && (path != NULL)) {
            strcpy (buffer, path);
            strcat (buffer, "/");
            strcat (buffer, name);
            DBUG_PRINT ("FILE", ("trying file %s\n", buffer));
            file = fopen (buffer, "r");
            if (file == NULL) {
                path = strtok (NULL, ":");
            }
        }
    }
    if (file) {
        fclose (file);
        result = buffer;
    }

    DBUG_RETURN (result);
}

/*
 *
 *  functionname  : InitPaths
 *  arguments     :
 *  description   :
 *  global vars   : ---
 *  internal funs : ---
 *  external funs : strcpy
 *  macros        : ---
 *
 *  remarks       :
 *
 */

void
InitPaths ()
{
    int i;

    DBUG_ENTER ("InitPaths");

    for (i = 0; i < 3; i++) {
        bufsize[i] = 1;
        strcpy (path_bufs[i], ".");
    }

    DBUG_VOID_RETURN;
}

/*
 *
 *  functionname  : AppendPath
 *  arguments     : pathkind, path to be appended
 *  description   :
 *  global vars   : ---
 *  internal funs : ---
 *  external funs : ---
 *  macros        : ---
 *
 *  remarks       :
 *
 */

int
AppendPath (pathkind p, char *path)
{
    int v, len;

    DBUG_ENTER ("AppendPath");

    len = (strlen (path) + 1);
    if (len + bufsize[p] >= MAX_PATH_LEN)
        v = 0;
    else {
        strcat (path_bufs[p], ":");
        strcat (path_bufs[p], path);
        DBUG_PRINT ("FILE", ("appending \":%s\" to path %d", path, p));
        bufsize[p] += len;
        v = 1;
    }

    DBUG_RETURN (v);
}

/*
 *
 *  functionname  : RearrangePaths
 *  arguments     : ---
 *  description   : If additional search paths are provided as command line
 *                  parameters, then these have a higher priority than the
 *                  standard search path (current directory+shell variables).
 *                  This function modifies the internal path representation
 *                  if necessary after scanning the command line.
 *  global vars   :
 *  internal funs :
 *  external funs :
 *  macros        :
 *
 *  remarks       :
 *
 */

void
RearrangePaths ()
{
    int i;
    char buffer[MAX_PATH_LEN];

    DBUG_ENTER ("RearrangePaths");

    for (i = 0; i <= 2; i++) {
        if (strlen (path_bufs[i]) > 1) {
            strcpy (buffer, path_bufs[i] + 2);
            strcat (buffer, ":.");
            strcpy (path_bufs[i], buffer);
        }
    }

    DBUG_VOID_RETURN;
}

/*
 *
 *  functionname  : AppendEnvVar
 *  arguments     : pathkind, path to be appended
 *  description   :
 *  global vars   : ---
 *  internal funs : ---
 *  external funs : ---
 *  macros        : ---
 *
 *  remarks       :
 *
 */

int
AppendEnvVar (pathkind p, char *var)
{
    int v = 1, len;
    char *buffer;

    DBUG_ENTER ("AppendEnvVar");

    buffer = getenv (var);
    if (buffer != NULL) {
        len = (strlen (buffer) + 1);
        if (len + bufsize[p] >= MAX_PATH_LEN)
            v = 0;
        else {
            strcat (path_bufs[p], ":");
            strcat (path_bufs[p], buffer);
            DBUG_PRINT ("FILE", ("appending \":%s\" to path %d", buffer, p));
            bufsize[p] += len;
        }
    }
    DBUG_RETURN (v);
}

/*
 *
 *  functionname  : AbsolutePathname
 *  arguments     : 1) path name
 *  description   : turns relative path names into absolute path names
 *  global vars   : ---
 *  internal funs : ---
 *  external funs : strcpy, strncmp, getcwd, strrchr, strcat
 *  macros        : MAX_PATH_LEN
 *
 *  remarks       :
 *
 */

char *
AbsolutePathname (char *path)
{
    char *tmp;
    static char buffer[MAX_PATH_LEN];

    DBUG_ENTER ("AbsolutePathname");

    if (path[0] == '/') {
        strcpy (buffer, path);
    } else {
        getcwd (buffer, MAX_PATH_LEN);

        while (0 == strncmp ("../", path, 3)) {
            path += 3;
            tmp = strrchr (buffer, '/');
            *tmp = 0;
        }

        if (0 == strncmp ("./", path, 2)) {
            path += 2;
        }

        strcat (buffer, "/");
        strcat (buffer, path);
    }

    DBUG_RETURN (buffer);
}

/*
 *
 *  functionname  : WriteOpen
 *  arguments     : 1) format string like that of printf
 *                  2) variable argument list for 1)
 *  description   : opens the given file for writing. If this fails,
 *                  an error message
 *                  occurs and compilation is aborted.
 *  global vars   : ---
 *  internal funs : ---
 *  external funs : vsprintf, va_start, va_end, fopen
 *  macros        : vararg macros, ERROR
 *
 *  remarks       :
 *
 */

FILE *
WriteOpen (char *format, ...)
{
    va_list arg_p;
    static char buffer[MAX_PATH_LEN];
    FILE *file;

    DBUG_ENTER ("WriteOpen");

    va_start (arg_p, format);
    vsprintf (buffer, format, arg_p);
    va_end (arg_p);

    file = fopen (buffer, "w");

    if (file == NULL) {
        SYSABORT (("Unable to write file \"%s\"", buffer));
    }

    DBUG_RETURN (file);
}

/*
 *
 *  functionname  : RemoveDirectory
 *  arguments     : 1) directory name
 *  description   : If the given directory exists, it is removed with its
 *                  entire contents.
 *  global vars   : ---
 *  internal funs : ---
 *  external funs : SystemTest, SystemCall
 *  macros        :
 *
 *  remarks       :
 *
 */

void
RemoveDirectory (char *name)
{
    DBUG_ENTER ("RemoveDirectory");

    if (SystemTest ("-d %s", name)) {
        SystemCall ("rm -f %s/*", name);
        SystemCall ("rmdir %s", name);
    }

    DBUG_VOID_RETURN;
}

/*
 *
 *  functionname  : CreateTmpDirectories
 *  arguments     : ---
 *  description   : creates temporary directories
 *  global vars   : tmp_dirname
 *  internal funs : ---
 *  external funs : tempnam, SystemCall
 *  macros        :
 *
 *  remarks       :
 *
 */

void
CreateTmpDirectories ()
{
    DBUG_ENTER ("CreateTmpDirectories");

    tmp_dirname = tempnam (NULL, "SAC_");

    SystemCall ("mkdir %s", tmp_dirname);

    DBUG_PRINT ("FILE", ("tmp_dirname is %s", tmp_dirname));

    DBUG_VOID_RETURN;
}

/*
 *
 *  functionname  :
 *  arguments     :
 *  description   :
 *  global vars   :
 *  internal funs :
 *  external funs :
 *  macros        :
 *
 *  remarks       :
 *
 */
