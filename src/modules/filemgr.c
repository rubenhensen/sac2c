/*
 *
 * $Log$
 * Revision 1.6  1996/01/05 12:36:29  cg
 * added global variables tmp_dirname, store_dirname, build_dirname
 * and functions WriteOpen, CreateTmpDirectories, RemoveDirectory
 *
 * Revision 1.5  1995/04/10  11:08:02  sbs
 * some DBUG_PRINTs inserted
 * FindFile only looks for the explicit name if preceeded by "/"
 * i.e. an absolute path is given
 *
 * Revision 1.4  1995/04/07  09:36:35  sbs
 * bug resulting from change FILE * => char * eliminated
 *
 * Revision 1.3  1995/04/05  17:24:16  sbs
 * GenLinkList inserted
 *
 * Revision 1.2  1995/02/22  14:14:36  hw
 * changed FindFile (now look first for name and later have a look at path )
 *
 * Revision 1.1  1994/12/11  17:33:27  sbs
 * Initial revision
 *
 *
 */

#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

#include "dbug.h"
#include "internal_lib.h"
#include "Error.h"

#include "filemgr.h"

static char path_bufs[3][MAX_PATH_LEN];
static int bufsize[3];

char *tmp_dirname;
/* directory for temporarily evacuating object files         */
/* from current directory                                    */

char *store_dirname;
/* directory for storing files generated by sac2c until      */
/* the final compilation steps                               */

char *build_dirname;
/* directory where the files needed to create a new library  */
/* file are assembled.                                       */

/*
 *
 *  functionname  : FindFile
 *  arguments     :
 *  description   :
 *  global vars   : ---
 *  internal funs : ---
 *  external funs : ---
 *  macros        : ---
 *
 *  remarks       :
 *
 */

char *
FindFile (pathkind p, char *name)
{
    FILE *file = NULL;
    static char buffer[MAX_FILE_NAME];
    static char buffer2[MAX_PATH_LEN];
    char *path;
    char *result = NULL;

    DBUG_ENTER ("FindFile");

    if (name[0] == '/') { /* absolut path specified! */
        strcpy (buffer, name);
        file = fopen (buffer, "r");
    } else {
        strcpy (buffer2, path_bufs[p]);
        path = strtok (buffer2, ":");
        while ((file == NULL) && (path != NULL)) {
            strcpy (buffer, path);
            strcat (buffer, "/");
            strcat (buffer, name);
            DBUG_PRINT ("FILE", ("trying file %s\n", buffer));
            file = fopen (buffer, "r");
            if (file == NULL) {
                path = strtok (NULL, ":");
            }
        }
    }
    if (file) {
        fclose (file);
        result = buffer;
    }

    DBUG_RETURN (result);
}

/*
 *
 *  functionname  : InitPaths
 *  arguments     :
 *  description   :
 *  global vars   : ---
 *  internal funs : ---
 *  external funs : ---
 *  macros        : ---
 *
 *  remarks       :
 *
 */

void
InitPaths ()
{
    int i;

    DBUG_ENTER ("InitPaths");
    for (i = 0; i < 3; i++) {
        bufsize[i] = 1;
        strcat (path_bufs[i], ".");
    }
    DBUG_VOID_RETURN;
}

/*
 *
 *  functionname  : AppendPath
 *  arguments     : pathkind, path to be appended
 *  description   :
 *  global vars   : ---
 *  internal funs : ---
 *  external funs : ---
 *  macros        : ---
 *
 *  remarks       :
 *
 */

int
AppendPath (pathkind p, char *path)
{
    int v, len;

    DBUG_ENTER ("AppendPath");
    len = (strlen (path) + 1);
    if (len + bufsize[p] >= MAX_PATH_LEN)
        v = 0;
    else {
        strcat (path_bufs[p], ":");
        strcat (path_bufs[p], path);
        DBUG_PRINT ("FILE", ("appending \":%s\" to path %d", path, p));
        bufsize[p] += len;
        v = 1;
    }
    DBUG_RETURN (v);
}

/*
 *
 *  functionname  : AppendEnvVar
 *  arguments     : pathkind, path to be appended
 *  description   :
 *  global vars   : ---
 *  internal funs : ---
 *  external funs : ---
 *  macros        : ---
 *
 *  remarks       :
 *
 */

int
AppendEnvVar (pathkind p, char *var)
{
    int v = 1, len;
    char *buffer;

    DBUG_ENTER ("AppendEnvVar");

    buffer = getenv (var);
    if (buffer != NULL) {
        len = (strlen (buffer) + 1);
        if (len + bufsize[p] >= MAX_PATH_LEN)
            v = 0;
        else {
            strcat (path_bufs[p], ":");
            strcat (path_bufs[p], buffer);
            DBUG_PRINT ("FILE", ("appending \":%s\" to path %d", buffer, p));
            bufsize[p] += len;
        }
    }
    DBUG_RETURN (v);
}

/*
 *
 *  functionname  : WriteOpen
 *  arguments     : 1) format string like that of printf
 *                  2) variable argument list for 1)
 *  description   : opens the given file for writing. If this fails,
 *                  an error message
 *                  occurs and compilation is aborted.
 *  global vars   : ---
 *  internal funs : ---
 *  external funs : vsprintf, va_start, va_end, fopen
 *  macros        : vararg macros, ERROR
 *
 *  remarks       :
 *
 */

FILE *
WriteOpen (char *format, ...)
{
    va_list arg_p;
    static char buffer[MAX_PATH_LEN];
    FILE *file;

    DBUG_ENTER ("WriteOpen");

    va_start (arg_p, format);
    vsprintf (buffer, format, arg_p);
    va_end (arg_p);

    file = fopen (buffer, "w");

    if (file == NULL) {
        SYSABORT (("Unable to write file \"%s\"", buffer));
    }

    DBUG_RETURN (file);
}

#if 0
/*
 *
 *  functionname  : CreateDirectory
 *  arguments     : 
 *  description   : 
 *  global vars   : 
 *  internal funs : 
 *  external funs : 
 *  macros        : 
 *
 *  remarks       : 
 *
 */

void CreateDirectory(char *name)
{
  DBUG_ENTER("CreateDirectory");
  
  if (SystemTest("-f %s", name))
  {
    SYSWARN(("File \"%s\" detected, renamed to \"%s.sacbak\"", name, name));
    SystemCall("mv %s %s.sacbak", name, name);
  }
  
  if (systemTest("-d %s", name))
  {
    SYSWARN(("Directory \"%s\" from previous compiler run detected,\n"
             "files will be removed", name));
    SystemCall("rm -f %s/*", name);
  }
  else
  {
    SystemCall("mkdir %s", name);
  }
  
  DBUG_VOID_RETURN;
}
#endif

/*
 *
 *  functionname  : RemoveDirectory
 *  arguments     :
 *  description   :
 *  global vars   :
 *  internal funs :
 *  external funs :
 *  macros        :
 *
 *  remarks       :
 *
 */

void
RemoveDirectory (char *name)
{
    DBUG_ENTER ("RemoveDirectory");

    if (SystemTest ("-d %s", name)) {
        SystemCall ("rm -f %s/*", name);
        SystemCall ("rmdir %s", name);
    }

    DBUG_VOID_RETURN;
}

/*
 *
 *  functionname  : CreateTmpDirectories
 *  arguments     : ---
 *  description   : creates temporary directories
 *  global vars   : tmp_dirname, store_dirname, build_dirname
 *  internal funs : ---
 *  external funs : StringCopy, tmpnam, SystemCall
 *  macros        :
 *
 *  remarks       :
 *
 */

void
CreateTmpDirectories ()
{
    DBUG_ENTER ("CreateTmpDirectories");

    tmp_dirname = StringCopy (tmpnam (NULL));
    DBUG_PRINT ("FILE", ("tmp_dirname is %s", tmp_dirname));

    store_dirname = StringCopy (tmpnam (NULL));
    DBUG_PRINT ("FILE", ("store_dirname is %s", store_dirname));

    build_dirname = StringCopy (tmpnam (NULL));
    DBUG_PRINT ("FILE", ("build_dirname is %s", build_dirname));

    SystemCall ("mkdir %s", tmp_dirname);
    SystemCall ("mkdir %s", store_dirname);
    SystemCall ("mkdir %s", build_dirname);

    strcat (tmp_dirname, "/");
    strcat (store_dirname, "/");
    strcat (build_dirname, "/");

    DBUG_VOID_RETURN;
}

/*
 *
 *  functionname  :
 *  arguments     :
 *  description   :
 *  global vars   :
 *  internal funs :
 *  external funs :
 *  macros        :
 *
 *  remarks       :
 *
 */

/*
 *
 *  functionname  :
 *  arguments     :
 *  description   :
 *  global vars   :
 *  internal funs :
 *  external funs :
 *  macros        :
 *
 *  remarks       :
 *
 */

/*
 *
 *  functionname  :
 *  arguments     :
 *  description   :
 *  global vars   :
 *  internal funs :
 *  external funs :
 *  macros        :
 *
 *  remarks       :
 *
 */
