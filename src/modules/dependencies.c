/*
 *
 * $Log$
 * Revision 1.9  2005/08/09 10:06:52  sah
 * using CTIterminateCompilation instead of exit
 * to make sure the tmpdir is removed and all
 * the cleanup is done correctly
 *
 * Revision 1.8  2005/07/15 15:57:02  sah
 * introduced namespaces
 *
 * Revision 1.7  2005/06/18 18:06:00  sah
 * moved entire dependency handling to dependencies.c
 * the dependency table is now created shortly prior
 * to c code generation
 *
 * Revision 1.6  2005/06/04 11:50:00  sbs
 * output of -M changed. Now, dependencies to .sac files are provided if no .so
 * is found but the source is found.
 *
 * Revision 1.5  2005/06/02 17:02:34  sbs
 * added an empty alldeps rule for -Mlib in case there are no
 * dependencies at all.
 *
 * Revision 1.4  2005/06/02 15:02:37  sah
 * added -Mlib option and corresponding implementation
 *
 * Revision 1.3  2005/06/01 18:01:24  sah
 * finished printing of dependencies
 *
 * Revision 1.2  2004/11/25 21:19:24  sah
 * COMPILES
 *
 * Revision 1.1  2004/11/08 19:04:54  sah
 * Initial revision
 *
 *
 *
 */

#include "dependencies.h"

#include <string.h>
#include <libgen.h>
#include "stringset.h"
#include "tree_basic.h"
#include "modulemanager.h"
#include "filemgr.h"
#include "internal_lib.h"
#include "namespaces.h"
#include "ctinfo.h"
#include "dbug.h"

/*
 * functions for generating the dependency table c file
 */
static void
GenerateDependencyTableHead (FILE *file)
{
    DBUG_ENTER ("GenerateDependencyTableHead");

    fprintf (file, "/* generated by sac2c %s */\n\n", global.version_id);
    fprintf (file, "#include \"sac_serialize.h\"\n\n");
    fprintf (file, "void *__%s__DEPTAB() {\n", global.modulename);
    fprintf (file, "void *result = (void *) 0;\n");

    DBUG_VOID_RETURN;
}

static void
GenerateDependencyTableTail (FILE *file)
{
    DBUG_ENTER ("GenerateDependencyTableTail");

    fprintf (file, "return(result);\n}\n");

    DBUG_VOID_RETURN;
}

static void *
TableEntriesFoldFun (const char *val, strstype_t kind, void *rest)
{
    str_buf *result = (str_buf *)rest;

    DBUG_ENTER ("TableEntriesFoldFun");

    switch (kind) {
    case STRS_saclib:
    case STRS_extlib:
        result = ILIBstrBufPrintf ((str_buf *)rest,
                                   "result = STRSadd( \"%s\", %d, result);\n", val, kind);
        break;
    default:
        break;
    }

    DBUG_RETURN (result);
}

static void
GenerateDependencyTableEntries (stringset_t *deps, FILE *file)
{
    str_buf *buffer;
    char *string;

    DBUG_ENTER ("GenerateDependencyTableEntries");

    buffer = ILIBstrBufCreate (4096);

    buffer = STRSfold (&TableEntriesFoldFun, deps, buffer);

    string = ILIBstrBuf2String (buffer);

    fprintf (file, string);

    string = ILIBfree (string);
    buffer = ILIBstrBufFree (buffer);

    DBUG_VOID_RETURN;
}

void
DEPgenerateDependencyTable (stringset_t *deps)
{
    FILE *file;

    DBUG_ENTER ("DEPgenerateDependencyTable");

    file = FMGRwriteOpen ("%s/dependencytable.c", global.tmp_dirname);

    GenerateDependencyTableHead (file);

    GenerateDependencyTableEntries (deps, file);

    GenerateDependencyTableTail (file);

    fclose (file);

    DBUG_VOID_RETURN;
}

/*
 * functions for printing dependency information
 */
static void *
BuildDepClosFoldFun (const char *entry, strstype_t kind, void *rest)
{
    stringset_t *result = NULL;
    module_t *module;

    DBUG_ENTER ("BuildDepClosFoldFun");

    if (kind == STRS_saclib) {
        module = MODMloadModule (entry);
        result = MODMgetDependencyTable (module);
        module = MODMunLoadModule (module);
    }

    result = STRSjoin ((stringset_t *)rest, result);

    DBUG_RETURN ((void *)result);
}

stringset_t *
DEPbuildDependencyClosure (stringset_t *deps)
{
    stringset_t *result;

    DBUG_ENTER ("DEPbuildDependencyClosure");

    result = STRSfold (&BuildDepClosFoldFun, deps, NULL);

    result = STRSjoin (result, deps);

    DBUG_RETURN (result);
}

static void *
PrintLibDepFoldFun (const char *entry, strstype_t kind, void *modname)
{
    DBUG_ENTER ("PrintLibDepFoldFun");

    /*
     * if the dependency is a sac library, we print a make
     * rule for the given library
     */
    if (kind == STRS_saclib) {
        char *libname;
        char *libfile;

        libname = ILIBmalloc (sizeof (char) * (strlen (entry) + 5));
        sprintf (libname, "%s.sac", entry);

        libfile = ILIBstringCopy (FMGRfindFile (PK_imp_path, libname));
        libname = ILIBfree (libname);

        if (libfile != NULL) {
            char *libdir = dirname (libfile);

            printf ("alldeps_%s: \\\n  %s\n\n", (char *)modname, entry);

            printf (".PHONY: \\\n  %s\n\n", entry);

            /**
             *
             * The space before the colon is essential here!
             * This allows us to easily distinguish this case from the
             * alldeps rules, in particular, the empty rule in
             * doPrintLibDependencies
             */
            printf ("%s :\n\t( cd %s; $(MAKE) lib%s.so)\n\n", entry, libdir, entry);
        }

        libfile = ILIBfree (libfile);
    }

    DBUG_RETURN (modname);
}

static void
doPrintLibDependencies (node *tree)
{
    DBUG_ENTER ("doPrintLibDependencies");

#ifndef DBUG_OFF
    printf ("#\n# extended dependencies for file %s\n#\n\n", global.filename);
#endif

    /**
     * First, we give an empty rule. This is required iff there
     * are no dependencies!
     * The non-space before the colon is essential here!
     * Cf. PrintLibDepFoldFun!
     */
    printf ("alldeps_%s:\n", NSgetName (MODULE_NAMESPACE (tree)));

    STRSfold (&PrintLibDepFoldFun, MODULE_DEPENDENCIES (tree),
              (void *)NSgetName (MODULE_NAMESPACE (tree)));

    DBUG_VOID_RETURN;
}

static void
PrintSACLib (const char *name)
{
    char *filename;
    char *result;

    DBUG_ENTER ("PrintSACLib");

    /*
     * first try to find the .so file
     */

    filename = ILIBmalloc (sizeof (char) * (strlen (name) + 7));
    sprintf (filename, "lib%s.so", name);

    result = ILIBstringCopy (FMGRfindFile (PK_lib_path, filename));

    filename = ILIBfree (filename);

    if (result == NULL) {
        /*
         * now try to find the .sac file
         */

        filename = ILIBmalloc (sizeof (char) * (strlen (name) + 5));
        sprintf (filename, "%s.sac", name);

        result = ILIBstringCopy (FMGRfindFile (PK_imp_path, filename));

        filename = ILIBfree (filename);
    }

    if (result == NULL) {
        /*
         * otherwise use the pure filename
         */

        result = ILIBmalloc (sizeof (char) * (strlen (name) + 7));
        sprintf (result, "lib%s.so", name);
    }

    printf (" \\\n  %s", result);

    result = ILIBfree (result);

    DBUG_VOID_RETURN;
}

static void
PrintObjFile (const char *name)
{
    DBUG_ENTER ("PrintObjFile");

    printf (" \\\n  %s", name);

    DBUG_VOID_RETURN;
}

static void *
PrintDepFoldFun (const char *entry, strstype_t kind, void *rest)
{
    DBUG_ENTER ("PrintDepFoldFun");

    switch (kind) {
    case STRS_saclib:
        PrintSACLib (entry);
        break;
    case STRS_objfile:
        PrintObjFile (entry);
        break;
    default:
        break;
    }

    DBUG_RETURN ((void *)NULL);
}

static void
PrintTargetName (node *tree)
{
    DBUG_ENTER ("PrintTargetName");

    switch (MODULE_FILETYPE (tree)) {
    case F_prog:
        printf ("%s:", global.outfilename);
        break;
    case F_modimp:
    case F_classimp:
        printf ("%slib%s.so %slib%s.a:", global.targetdir,
                NSgetName (MODULE_NAMESPACE (tree)), global.targetdir,
                NSgetName (MODULE_NAMESPACE (tree)));
        break;
    default:
        DBUG_ASSERT (0, ("unknown file type found!"));
        break;
    }

    DBUG_VOID_RETURN;
}

node *
DEPdoPrintDependencies (node *syntax_tree)
{
    DBUG_ENTER ("DEPdoPrintDependencies");

#ifndef DBUG_OFF
    printf ("#\n# dependencies for file %s\n#\n\n", global.filename);
#endif

    /*
     * first, print how the output will be named
     */
    PrintTargetName (syntax_tree);

    /*
     * now add the dependencies
     */
    STRSfold (&PrintDepFoldFun, MODULE_DEPENDENCIES (syntax_tree), NULL);

    /*
     * and finally two newline to make it look nicer
     */
    printf ("\n\n");

    /*
     * if we are in special Mlib (aka sbs) mode, we have to print
     * some more dependencies, handeled by doPrintLibDependencies
     */
    if (global.makelibdeps) {
        doPrintLibDependencies (syntax_tree);
    }

    CTIterminateCompilation (PH_final, NULL, syntax_tree);

    DBUG_RETURN (syntax_tree);
}
