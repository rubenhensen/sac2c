
/**
 * @file traverse_helper.c
 *
 * Defines the helper function needed by the traversal system
 *
 * THIS FILE HAS BEEN GENERATED USING
 * $Id$.
 * DO NOT EDIT THIS FILE. EDIT THE AST SPEC IN ast.xml INSTEAD!
 *
 * ALL CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN!
 *
 */

#include "traverse_helper.h"
#include "dbug.h"
#include "tree_basic.h"
#include "traverse.h"

#define TRAV(son, info)                                                                  \
    if (son != NULL) {                                                                   \
        son = TRAVdo (son, info);                                                        \
    }

node *
TRAVNone (node *arg_node, info *arg_info)
{
    DBUG_ENTER ("TRAV");
    DBUG_RETURN (arg_node);
}

node *
TRAVError (node *arg_node, info *arg_info)
{
    DBUG_ENTER ("TRAVError");

    DBUG_ASSERT ((FALSE), "Illegal node type found.");

    DBUG_RETURN (arg_node);
}

node *
TRAVsons (node *arg_node, info *arg_info)
{
    DBUG_ENTER ("TRAVsons");

    switch (NODE_TYPE (arg_node)) {
    case N_module:
        TRAV (MODULE_IMPORTS (arg_node), arg_info);
        TRAV (MODULE_TYPES (arg_node), arg_info);
        TRAV (MODULE_OBJS (arg_node), arg_info);
        TRAV (MODULE_FUNS (arg_node), arg_info);
        TRAV (MODULE_FUNDECS (arg_node), arg_info);
        TRAV (MODULE_CWRAPPER (arg_node), arg_info);
        break;
    case N_typedef:
        TRAV (TYPEDEF_NEXT (arg_node), arg_info);
        break;
    case N_objdef:
        TRAV (OBJDEF_EXPR (arg_node), arg_info);
        TRAV (OBJDEF_NEXT (arg_node), arg_info);
        break;
    case N_fundef:
        TRAV (FUNDEF_RETS (arg_node), arg_info);
        TRAV (FUNDEF_ARGS (arg_node), arg_info);
        TRAV (FUNDEF_BODY (arg_node), arg_info);
        TRAV (FUNDEF_NEXT (arg_node), arg_info);
        TRAV (FUNDEF_OBJECTS (arg_node), arg_info);
        break;
    case N_arg:
        TRAV (ARG_AVIS (arg_node), arg_info);
        TRAV (ARG_NEXT (arg_node), arg_info);
        break;
    case N_block:
        TRAV (BLOCK_INSTR (arg_node), arg_info);
        TRAV (BLOCK_VARDEC (arg_node), arg_info);
        break;
    case N_vardec:
        TRAV (VARDEC_AVIS (arg_node), arg_info);
        TRAV (VARDEC_NEXT (arg_node), arg_info);
        break;
    case N_assign:
        TRAV (ASSIGN_INSTR (arg_node), arg_info);
        TRAV (ASSIGN_NEXT (arg_node), arg_info);
        break;
    case N_let:
        TRAV (LET_IDS (arg_node), arg_info);
        TRAV (LET_EXPR (arg_node), arg_info);
        break;
    case N_cast:
        TRAV (CAST_EXPR (arg_node), arg_info);
        break;
    case N_return:
        TRAV (RETURN_EXPRS (arg_node), arg_info);
        break;
    case N_cond:
        TRAV (COND_COND (arg_node), arg_info);
        TRAV (COND_THEN (arg_node), arg_info);
        TRAV (COND_ELSE (arg_node), arg_info);
        break;
    case N_do:
        TRAV (DO_COND (arg_node), arg_info);
        TRAV (DO_BODY (arg_node), arg_info);
        TRAV (DO_SKIP (arg_node), arg_info);
        break;
    case N_while:
        TRAV (WHILE_COND (arg_node), arg_info);
        TRAV (WHILE_BODY (arg_node), arg_info);
        break;
    case N_annotate:
        break;
    case N_ap:
        TRAV (AP_ARGS (arg_node), arg_info);
        break;
    case N_mop:
        TRAV (MOP_OPS (arg_node), arg_info);
        TRAV (MOP_EXPRS (arg_node), arg_info);
        break;
    case N_exprs:
        TRAV (EXPRS_EXPR (arg_node), arg_info);
        TRAV (EXPRS_NEXT (arg_node), arg_info);
        break;
    case N_funcond:
        TRAV (FUNCOND_IF (arg_node), arg_info);
        TRAV (FUNCOND_THEN (arg_node), arg_info);
        TRAV (FUNCOND_ELSE (arg_node), arg_info);
        break;
    case N_array:
        TRAV (ARRAY_AELEMS (arg_node), arg_info);
        break;
    case N_vinfo:
        TRAV (VINFO_NEXT (arg_node), arg_info);
        break;
    case N_id:
        break;
    case N_num:
        break;
    case N_char:
        break;
    case N_float:
        break;
    case N_double:
        break;
    case N_bool:
        break;
    case N_str:
        break;
    case N_prf:
        TRAV (PRF_ARGS (arg_node), arg_info);
        break;
    case N_dot:
        break;
    case N_setwl:
        TRAV (SETWL_IDS (arg_node), arg_info);
        TRAV (SETWL_EXPR (arg_node), arg_info);
        break;
    case N_empty:
        break;
    case N_icm:
        TRAV (ICM_ARGS (arg_node), arg_info);
        break;
    case N_pragma:
        TRAV (PRAGMA_READONLY (arg_node), arg_info);
        TRAV (PRAGMA_REFCOUNTING (arg_node), arg_info);
        TRAV (PRAGMA_EFFECT (arg_node), arg_info);
        TRAV (PRAGMA_TOUCH (arg_node), arg_info);
        TRAV (PRAGMA_LINKSIGN (arg_node), arg_info);
        break;
    case N_cseinfo:
        TRAV (CSEINFO_NEXT (arg_node), arg_info);
        break;
    case N_ssacnt:
        TRAV (SSACNT_NEXT (arg_node), arg_info);
        break;
    case N_ssastack:
        TRAV (SSASTACK_NEXT (arg_node), arg_info);
        break;
    case N_avis:
        break;
    case N_spmd:
        TRAV (SPMD_REGION (arg_node), arg_info);
        break;
    case N_sync:
        TRAV (SYNC_REGION (arg_node), arg_info);
        break;
    case N_mt:
        TRAV (MT_REGION (arg_node), arg_info);
        break;
    case N_ex:
        TRAV (EX_REGION (arg_node), arg_info);
        break;
    case N_st:
        TRAV (ST_REGION (arg_node), arg_info);
        break;
    case N_with:
        TRAV (WITH_PART (arg_node), arg_info);
        TRAV (WITH_CODE (arg_node), arg_info);
        TRAV (WITH_WITHOP (arg_node), arg_info);
        break;
    case N_part:
        TRAV (PART_WITHID (arg_node), arg_info);
        TRAV (PART_GENERATOR (arg_node), arg_info);
        TRAV (PART_NEXT (arg_node), arg_info);
        break;
    case N_withid:
        TRAV (WITHID_VEC (arg_node), arg_info);
        TRAV (WITHID_IDS (arg_node), arg_info);
        break;
    case N_generator:
        TRAV (GENERATOR_BOUND1 (arg_node), arg_info);
        TRAV (GENERATOR_BOUND2 (arg_node), arg_info);
        TRAV (GENERATOR_STEP (arg_node), arg_info);
        TRAV (GENERATOR_WIDTH (arg_node), arg_info);
        break;
    case N_code:
        TRAV (CODE_CBLOCK (arg_node), arg_info);
        TRAV (CODE_CEXPRS (arg_node), arg_info);
        TRAV (CODE_NEXT (arg_node), arg_info);
        break;
    case N_with2:
        TRAV (WITH2_WITHID (arg_node), arg_info);
        TRAV (WITH2_SEGS (arg_node), arg_info);
        TRAV (WITH2_CODE (arg_node), arg_info);
        TRAV (WITH2_WITHOP (arg_node), arg_info);
        break;
    case N_genarray:
        TRAV (GENARRAY_SHAPE (arg_node), arg_info);
        TRAV (GENARRAY_DEFAULT (arg_node), arg_info);
        TRAV (GENARRAY_MEM (arg_node), arg_info);
        TRAV (GENARRAY_NEXT (arg_node), arg_info);
        break;
    case N_modarray:
        TRAV (MODARRAY_ARRAY (arg_node), arg_info);
        TRAV (MODARRAY_MEM (arg_node), arg_info);
        TRAV (MODARRAY_NEXT (arg_node), arg_info);
        break;
    case N_fold:
        TRAV (FOLD_NEUTRAL (arg_node), arg_info);
        TRAV (FOLD_NEXT (arg_node), arg_info);
        break;
    case N_wlseg:
        TRAV (WLSEG_CONTENTS (arg_node), arg_info);
        TRAV (WLSEG_NEXT (arg_node), arg_info);
        break;
    case N_wlsegvar:
        TRAV (WLSEGVAR_CONTENTS (arg_node), arg_info);
        TRAV (WLSEGVAR_NEXT (arg_node), arg_info);
        break;
    case N_wlblock:
        TRAV (WLBLOCK_NEXTDIM (arg_node), arg_info);
        TRAV (WLBLOCK_CONTENTS (arg_node), arg_info);
        TRAV (WLBLOCK_NEXT (arg_node), arg_info);
        break;
    case N_wlublock:
        TRAV (WLUBLOCK_NEXTDIM (arg_node), arg_info);
        TRAV (WLUBLOCK_CONTENTS (arg_node), arg_info);
        TRAV (WLUBLOCK_NEXT (arg_node), arg_info);
        break;
    case N_wlstride:
        TRAV (WLSTRIDE_CONTENTS (arg_node), arg_info);
        TRAV (WLSTRIDE_NEXT (arg_node), arg_info);
        break;
    case N_wlstridevar:
        TRAV (WLSTRIDEVAR_BOUND1 (arg_node), arg_info);
        TRAV (WLSTRIDEVAR_BOUND2 (arg_node), arg_info);
        TRAV (WLSTRIDEVAR_STEP (arg_node), arg_info);
        TRAV (WLSTRIDEVAR_CONTENTS (arg_node), arg_info);
        TRAV (WLSTRIDEVAR_NEXT (arg_node), arg_info);
        break;
    case N_wlgrid:
        TRAV (WLGRID_NEXTDIM (arg_node), arg_info);
        TRAV (WLGRID_NEXT (arg_node), arg_info);
        break;
    case N_wlgridvar:
        TRAV (WLGRIDVAR_BOUND1 (arg_node), arg_info);
        TRAV (WLGRIDVAR_BOUND2 (arg_node), arg_info);
        TRAV (WLGRIDVAR_NEXTDIM (arg_node), arg_info);
        TRAV (WLGRIDVAR_NEXT (arg_node), arg_info);
        break;
    case N_cwrapper:
        TRAV (CWRAPPER_NEXT (arg_node), arg_info);
        break;
    case N_dataflownode:
        break;
    case N_dataflowgraph:
        break;
    case N_import:
        TRAV (IMPORT_NEXT (arg_node), arg_info);
        TRAV (IMPORT_SYMBOL (arg_node), arg_info);
        break;
    case N_export:
        TRAV (EXPORT_NEXT (arg_node), arg_info);
        TRAV (EXPORT_SYMBOL (arg_node), arg_info);
        break;
    case N_use:
        TRAV (USE_NEXT (arg_node), arg_info);
        TRAV (USE_SYMBOL (arg_node), arg_info);
        break;
    case N_provide:
        TRAV (PROVIDE_NEXT (arg_node), arg_info);
        TRAV (PROVIDE_SYMBOL (arg_node), arg_info);
        break;
    case N_symbol:
        TRAV (SYMBOL_NEXT (arg_node), arg_info);
        break;
    case N_linklist:
        TRAV (LINKLIST_NEXT (arg_node), arg_info);
        break;
    case N_ret:
        TRAV (RET_NEXT (arg_node), arg_info);
        break;
    case N_ids:
        TRAV (IDS_NEXT (arg_node), arg_info);
        break;
    case N_nums:
        TRAV (NUMS_NEXT (arg_node), arg_info);
        break;
    case N_globobj:
        break;
    default:
        DBUG_ASSERT ((FALSE), "Illegal nodetype found!");
        break;
    }

    DBUG_RETURN (arg_node);
}

int
TRAVnumSons (node *node)
{
    int result = 0;

    DBUG_ENTER ("TRAVnumSons");

    switch (NODE_TYPE (node)) {
    case N_module:
        result = 6;
        break;
    case N_typedef:
        result = 1;
        break;
    case N_objdef:
        result = 2;
        break;
    case N_fundef:
        result = 5;
        break;
    case N_arg:
        result = 2;
        break;
    case N_block:
        result = 2;
        break;
    case N_vardec:
        result = 2;
        break;
    case N_assign:
        result = 2;
        break;
    case N_let:
        result = 2;
        break;
    case N_cast:
        result = 1;
        break;
    case N_return:
        result = 1;
        break;
    case N_cond:
        result = 3;
        break;
    case N_do:
        result = 3;
        break;
    case N_while:
        result = 2;
        break;
    case N_annotate:
        result = 0;
        break;
    case N_ap:
        result = 1;
        break;
    case N_mop:
        result = 2;
        break;
    case N_exprs:
        result = 2;
        break;
    case N_funcond:
        result = 3;
        break;
    case N_array:
        result = 1;
        break;
    case N_vinfo:
        result = 1;
        break;
    case N_id:
        result = 0;
        break;
    case N_num:
        result = 0;
        break;
    case N_char:
        result = 0;
        break;
    case N_float:
        result = 0;
        break;
    case N_double:
        result = 0;
        break;
    case N_bool:
        result = 0;
        break;
    case N_str:
        result = 0;
        break;
    case N_prf:
        result = 1;
        break;
    case N_dot:
        result = 0;
        break;
    case N_setwl:
        result = 2;
        break;
    case N_empty:
        result = 0;
        break;
    case N_icm:
        result = 1;
        break;
    case N_pragma:
        result = 5;
        break;
    case N_cseinfo:
        result = 1;
        break;
    case N_ssacnt:
        result = 1;
        break;
    case N_ssastack:
        result = 1;
        break;
    case N_avis:
        result = 0;
        break;
    case N_spmd:
        result = 1;
        break;
    case N_sync:
        result = 1;
        break;
    case N_mt:
        result = 1;
        break;
    case N_ex:
        result = 1;
        break;
    case N_st:
        result = 1;
        break;
    case N_with:
        result = 3;
        break;
    case N_part:
        result = 3;
        break;
    case N_withid:
        result = 2;
        break;
    case N_generator:
        result = 4;
        break;
    case N_code:
        result = 3;
        break;
    case N_with2:
        result = 4;
        break;
    case N_genarray:
        result = 4;
        break;
    case N_modarray:
        result = 3;
        break;
    case N_fold:
        result = 2;
        break;
    case N_wlseg:
        result = 2;
        break;
    case N_wlsegvar:
        result = 2;
        break;
    case N_wlblock:
        result = 3;
        break;
    case N_wlublock:
        result = 3;
        break;
    case N_wlstride:
        result = 2;
        break;
    case N_wlstridevar:
        result = 5;
        break;
    case N_wlgrid:
        result = 2;
        break;
    case N_wlgridvar:
        result = 4;
        break;
    case N_cwrapper:
        result = 1;
        break;
    case N_dataflownode:
        result = 0;
        break;
    case N_dataflowgraph:
        result = 0;
        break;
    case N_import:
        result = 2;
        break;
    case N_export:
        result = 2;
        break;
    case N_use:
        result = 2;
        break;
    case N_provide:
        result = 2;
        break;
    case N_symbol:
        result = 1;
        break;
    case N_linklist:
        result = 1;
        break;
    case N_ret:
        result = 1;
        break;
    case N_ids:
        result = 1;
        break;
    case N_nums:
        result = 1;
        break;
    case N_globobj:
        result = 0;
        break;
    default:
        DBUG_ASSERT ((FALSE), "Illegal nodetype found!");
        break;
    }

    DBUG_RETURN (result);
}

node *
TRAVgetSon (int no, node *parent)
{
    node *result;

    DBUG_ENTER ("TRAVgetSon");

    switch (NODE_TYPE (parent)) {
    case N_module:
        switch (no) {
        case 0:
            result = MODULE_IMPORTS (parent);
            break;
        case 1:
            result = MODULE_TYPES (parent);
            break;
        case 2:
            result = MODULE_OBJS (parent);
            break;
        case 3:
            result = MODULE_FUNS (parent);
            break;
        case 4:
            result = MODULE_FUNDECS (parent);
            break;
        case 5:
            result = MODULE_CWRAPPER (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_typedef:
        switch (no) {
        case 0:
            result = TYPEDEF_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_objdef:
        switch (no) {
        case 0:
            result = OBJDEF_EXPR (parent);
            break;
        case 1:
            result = OBJDEF_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_fundef:
        switch (no) {
        case 0:
            result = FUNDEF_RETS (parent);
            break;
        case 1:
            result = FUNDEF_ARGS (parent);
            break;
        case 2:
            result = FUNDEF_BODY (parent);
            break;
        case 3:
            result = FUNDEF_NEXT (parent);
            break;
        case 4:
            result = FUNDEF_OBJECTS (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_arg:
        switch (no) {
        case 0:
            result = ARG_AVIS (parent);
            break;
        case 1:
            result = ARG_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_block:
        switch (no) {
        case 0:
            result = BLOCK_INSTR (parent);
            break;
        case 1:
            result = BLOCK_VARDEC (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_vardec:
        switch (no) {
        case 0:
            result = VARDEC_AVIS (parent);
            break;
        case 1:
            result = VARDEC_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_assign:
        switch (no) {
        case 0:
            result = ASSIGN_INSTR (parent);
            break;
        case 1:
            result = ASSIGN_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_let:
        switch (no) {
        case 0:
            result = LET_IDS (parent);
            break;
        case 1:
            result = LET_EXPR (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_cast:
        switch (no) {
        case 0:
            result = CAST_EXPR (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_return:
        switch (no) {
        case 0:
            result = RETURN_EXPRS (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_cond:
        switch (no) {
        case 0:
            result = COND_COND (parent);
            break;
        case 1:
            result = COND_THEN (parent);
            break;
        case 2:
            result = COND_ELSE (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_do:
        switch (no) {
        case 0:
            result = DO_COND (parent);
            break;
        case 1:
            result = DO_BODY (parent);
            break;
        case 2:
            result = DO_SKIP (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_while:
        switch (no) {
        case 0:
            result = WHILE_COND (parent);
            break;
        case 1:
            result = WHILE_BODY (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_annotate:
        switch (no) {
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_ap:
        switch (no) {
        case 0:
            result = AP_ARGS (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_mop:
        switch (no) {
        case 0:
            result = MOP_OPS (parent);
            break;
        case 1:
            result = MOP_EXPRS (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_exprs:
        switch (no) {
        case 0:
            result = EXPRS_EXPR (parent);
            break;
        case 1:
            result = EXPRS_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_funcond:
        switch (no) {
        case 0:
            result = FUNCOND_IF (parent);
            break;
        case 1:
            result = FUNCOND_THEN (parent);
            break;
        case 2:
            result = FUNCOND_ELSE (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_array:
        switch (no) {
        case 0:
            result = ARRAY_AELEMS (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_vinfo:
        switch (no) {
        case 0:
            result = VINFO_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_id:
        switch (no) {
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_num:
        switch (no) {
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_char:
        switch (no) {
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_float:
        switch (no) {
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_double:
        switch (no) {
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_bool:
        switch (no) {
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_str:
        switch (no) {
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_prf:
        switch (no) {
        case 0:
            result = PRF_ARGS (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_dot:
        switch (no) {
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_setwl:
        switch (no) {
        case 0:
            result = SETWL_IDS (parent);
            break;
        case 1:
            result = SETWL_EXPR (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_empty:
        switch (no) {
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_icm:
        switch (no) {
        case 0:
            result = ICM_ARGS (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_pragma:
        switch (no) {
        case 0:
            result = PRAGMA_READONLY (parent);
            break;
        case 1:
            result = PRAGMA_REFCOUNTING (parent);
            break;
        case 2:
            result = PRAGMA_EFFECT (parent);
            break;
        case 3:
            result = PRAGMA_TOUCH (parent);
            break;
        case 4:
            result = PRAGMA_LINKSIGN (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_cseinfo:
        switch (no) {
        case 0:
            result = CSEINFO_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_ssacnt:
        switch (no) {
        case 0:
            result = SSACNT_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_ssastack:
        switch (no) {
        case 0:
            result = SSASTACK_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_avis:
        switch (no) {
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_spmd:
        switch (no) {
        case 0:
            result = SPMD_REGION (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_sync:
        switch (no) {
        case 0:
            result = SYNC_REGION (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_mt:
        switch (no) {
        case 0:
            result = MT_REGION (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_ex:
        switch (no) {
        case 0:
            result = EX_REGION (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_st:
        switch (no) {
        case 0:
            result = ST_REGION (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_with:
        switch (no) {
        case 0:
            result = WITH_PART (parent);
            break;
        case 1:
            result = WITH_CODE (parent);
            break;
        case 2:
            result = WITH_WITHOP (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_part:
        switch (no) {
        case 0:
            result = PART_WITHID (parent);
            break;
        case 1:
            result = PART_GENERATOR (parent);
            break;
        case 2:
            result = PART_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_withid:
        switch (no) {
        case 0:
            result = WITHID_VEC (parent);
            break;
        case 1:
            result = WITHID_IDS (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_generator:
        switch (no) {
        case 0:
            result = GENERATOR_BOUND1 (parent);
            break;
        case 1:
            result = GENERATOR_BOUND2 (parent);
            break;
        case 2:
            result = GENERATOR_STEP (parent);
            break;
        case 3:
            result = GENERATOR_WIDTH (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_code:
        switch (no) {
        case 0:
            result = CODE_CBLOCK (parent);
            break;
        case 1:
            result = CODE_CEXPRS (parent);
            break;
        case 2:
            result = CODE_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_with2:
        switch (no) {
        case 0:
            result = WITH2_WITHID (parent);
            break;
        case 1:
            result = WITH2_SEGS (parent);
            break;
        case 2:
            result = WITH2_CODE (parent);
            break;
        case 3:
            result = WITH2_WITHOP (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_genarray:
        switch (no) {
        case 0:
            result = GENARRAY_SHAPE (parent);
            break;
        case 1:
            result = GENARRAY_DEFAULT (parent);
            break;
        case 2:
            result = GENARRAY_MEM (parent);
            break;
        case 3:
            result = GENARRAY_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_modarray:
        switch (no) {
        case 0:
            result = MODARRAY_ARRAY (parent);
            break;
        case 1:
            result = MODARRAY_MEM (parent);
            break;
        case 2:
            result = MODARRAY_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_fold:
        switch (no) {
        case 0:
            result = FOLD_NEUTRAL (parent);
            break;
        case 1:
            result = FOLD_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_wlseg:
        switch (no) {
        case 0:
            result = WLSEG_CONTENTS (parent);
            break;
        case 1:
            result = WLSEG_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_wlsegvar:
        switch (no) {
        case 0:
            result = WLSEGVAR_CONTENTS (parent);
            break;
        case 1:
            result = WLSEGVAR_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_wlblock:
        switch (no) {
        case 0:
            result = WLBLOCK_NEXTDIM (parent);
            break;
        case 1:
            result = WLBLOCK_CONTENTS (parent);
            break;
        case 2:
            result = WLBLOCK_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_wlublock:
        switch (no) {
        case 0:
            result = WLUBLOCK_NEXTDIM (parent);
            break;
        case 1:
            result = WLUBLOCK_CONTENTS (parent);
            break;
        case 2:
            result = WLUBLOCK_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_wlstride:
        switch (no) {
        case 0:
            result = WLSTRIDE_CONTENTS (parent);
            break;
        case 1:
            result = WLSTRIDE_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_wlstridevar:
        switch (no) {
        case 0:
            result = WLSTRIDEVAR_BOUND1 (parent);
            break;
        case 1:
            result = WLSTRIDEVAR_BOUND2 (parent);
            break;
        case 2:
            result = WLSTRIDEVAR_STEP (parent);
            break;
        case 3:
            result = WLSTRIDEVAR_CONTENTS (parent);
            break;
        case 4:
            result = WLSTRIDEVAR_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_wlgrid:
        switch (no) {
        case 0:
            result = WLGRID_NEXTDIM (parent);
            break;
        case 1:
            result = WLGRID_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_wlgridvar:
        switch (no) {
        case 0:
            result = WLGRIDVAR_BOUND1 (parent);
            break;
        case 1:
            result = WLGRIDVAR_BOUND2 (parent);
            break;
        case 2:
            result = WLGRIDVAR_NEXTDIM (parent);
            break;
        case 3:
            result = WLGRIDVAR_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_cwrapper:
        switch (no) {
        case 0:
            result = CWRAPPER_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_dataflownode:
        switch (no) {
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_dataflowgraph:
        switch (no) {
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_import:
        switch (no) {
        case 0:
            result = IMPORT_NEXT (parent);
            break;
        case 1:
            result = IMPORT_SYMBOL (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_export:
        switch (no) {
        case 0:
            result = EXPORT_NEXT (parent);
            break;
        case 1:
            result = EXPORT_SYMBOL (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_use:
        switch (no) {
        case 0:
            result = USE_NEXT (parent);
            break;
        case 1:
            result = USE_SYMBOL (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_provide:
        switch (no) {
        case 0:
            result = PROVIDE_NEXT (parent);
            break;
        case 1:
            result = PROVIDE_SYMBOL (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_symbol:
        switch (no) {
        case 0:
            result = SYMBOL_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_linklist:
        switch (no) {
        case 0:
            result = LINKLIST_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_ret:
        switch (no) {
        case 0:
            result = RET_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_ids:
        switch (no) {
        case 0:
            result = IDS_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_nums:
        switch (no) {
        case 0:
            result = NUMS_NEXT (parent);
            break;
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    case N_globobj:
        switch (no) {
        default:
            DBUG_ASSERT ((FALSE), "index out of range!");
            break;
        }
        break;
    default:
        DBUG_ASSERT ((FALSE), "Illegal nodetype found!");
        break;
    }

    DBUG_RETURN (result);
}
