module sacprelude;

provide {sel, zero, eq, adjustLacFunParams, adjustLacFunParamsReshape,
         SACarg, unwrapInt, unwrapBool, unwrapFloat, unwrapDouble,
         unwrapChar, isInt, isBool, isFloat, isDouble, isChar, isUdt, 
         wrap};

external typedef SACarg;
  #pragma freefun "SACARGfree"
  #pragma copyfun "SACARGcopy"

#define BUILT_IN( fun)    \
fun( int)                 \
fun( float)               \
fun( double)              \
fun( bool)                \
fun( char)


#define SEL_VxA( a)                                                      \
inline                                                                   \
a[*] sel( int[.] idx, a[*] array)                                        \
{                                                                        \
  new_shape = _drop_SxV_( _sel_VxA_( [0], _shape_A_(idx)), _shape_A_(array));\
  res = with {                                                           \
          ( . <= iv <= . )                                               \
          {                                                              \
            new_idx = _cat_VxV_( idx, iv);                               \
          } : _sel_VxA_(new_idx, array);                                     \
        } : genarray( new_shape, zero( array ) );                        \
  return( res);                                                          \
}

BUILT_IN( SEL_VxA)




#define ZERO( a, za)  \
inline                \
a zero( a[*] A)       \
{                     \
  return( za);        \
}

ZERO( int, 0)
ZERO( double, 0d)
ZERO( float, 0f)
ZERO( char, ' ')
ZERO( bool, false)

inline
bool and( bool a, bool b)
{
  return( _and_SxS_( a, b));
}

#define EQ( a)                                                       \
inline                                                               \
bool eq( a[*] A, a[*] B)                                             \
{                                                                    \
  res = with {                                                       \
          ( _mul_SxV_(0, _shape_A_(A)) <= iv < _shape_A_(A) )        \
          : _eq_SxS_(_sel_VxA_( iv, A), _sel_VxA_( iv, B));          \
        } : fold( sacprelude::and, true );                           \
  return( res);                                                      \
}

BUILT_IN( EQ)


int[*] adjustLacFunParamsReshape( bool[*] p, int[*] i, int[.] iv, int[.] shp)
{
  return( ( _or_SxS_(_eq_SxS_( _dim_A_(p), 0), _eq_SxS_(_dim_A_(i), 0)) ?
            i : _reshape_VxA_( shp, i)[iv]));
}

int[*] adjustLacFunParams( bool[*] p, int[*] i, int[.] iv)
{
  return( ( _or_SxS_(_eq_SxS_( _dim_A_(p), 0), _eq_SxS_(_dim_A_(i), 0)) ?
            i : i[iv]));
}

external int[*] unwrapInt( SACarg arg);
  #pragma linkname "SACARGunwrapInt"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external float[*] unwrapFloat( SACarg arg);
  #pragma linkname "SACARGunwrapFloat"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external double[*] unwrapDouble( SACarg arg);
  #pragma linkname "SACARGunwrapDouble"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external bool[*] unwrapBool( SACarg arg);
  #pragma linkname "SACARGunwrapBool"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external char[*] unwrapChar( SACarg arg);
  #pragma linkname "SACARGunwrapChar"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external SACarg wrap( int[*] a);
  #pragma linkname "SACARGwrapInt"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external SACarg wrap( float[*] a);
  #pragma linkname "SACARGwrapFloat"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external SACarg wrap( double[*] a);
  #pragma linkname "SACARGwrapDouble"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external SACarg wrap( bool[*] a);
  #pragma linkname "SACARGwrapBool"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external SACarg wrap( char[*] a);
  #pragma linkname "SACARGwrapChar"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external bool isInt( SACarg a);
  #pragma linkname "SACARGisInt"
  #pragma linksign [0,1]
  
external bool isFloat( SACarg a);
  #pragma linkname "SACARGisFloat"
  #pragma linksign [0,1]
  
external bool isDouble( SACarg a);
  #pragma linkname "SACARGisDouble"
  #pragma linksign [0,1]
  
external bool isBool( SACarg a);
  #pragma linkname "SACARGisBool"
  #pragma linksign [0,1]
  
external bool isChar( SACarg a);
  #pragma linkname "SACARGisChar"
  #pragma linksign [0,1]
  
external bool isUdt( int base, SACarg a);
  #pragma linkname "SACARGisUdt"
  #pragma linksign [0,1,2]


