module sacprelude;

provide {sel, zero, eq, adjustLacFunParams, adjustLacFunParamsReshape,
         SACarg, prod, partitionSlicer, gridFiller
#define MUTC 1
#if SAC_BACKEND != MUTC
         , unwrapInt, unwrapBool, unwrapFloat, unwrapDouble, unwrapChar, 
	   isInt, isBool, isFloat, isDouble, isChar, isUdt, wrap,
           isPartitionIntersectNull, partitionIntersectMax, partitionIntersectMin
#ifdef SANTANU
	 , unwrapByte, unwrapShort, unwrapInt, unwrapLong, unwrapLonglong,
	   unwrapUbyte, unwrapUshort, unwrapUint, unwrapUlong, unwrapUlonglong,
	   isByte, isShort, isInt, isLong, isLonglong,
	   isUbyte, isUshort, isUint, isUlong, isUlonglong
#endif
#endif
#undef MUTC
};

external typedef SACarg;
  #pragma freefun "SACARGfree"
  #pragma copyfun "SACARGcopy"

#ifdef SANTANU
#define BUILT_IN( fun)    \
fun( int)                 \
fun( float)               \
fun( double)              \
fun( bool)                \
fun( char)		  \
fun( byte)                \
fun( short)               \
fun( long)                \
fun( longlong)            \
fun( ubyte)               \
fun( ushort)              \
fun( uint)                \
fun( ulong)               \
fun( ulonglong)           
#else
#define BUILT_IN( fun)    \
fun( int)                 \
fun( float)               \
fun( double)              \
fun( bool)                \
fun( char)		  
#endif

#define SEL_VxA( a)                                                      \
inline                                                                   \
a[*] sel( int[.] idx, a[*] array)                                        \
{                                                                        \
  new_shape = _drop_SxV_( _sel_VxA_( [0], _shape_A_(idx)), _shape_A_(array));\
  res = with {                                                           \
          ( . <= iv <= . )                                               \
          {                                                              \
            new_idx = _cat_VxV_( idx, iv);                               \
          } : _sel_VxA_(new_idx, array);                                     \
        } : genarray( new_shape, zero( array ) );                        \
  return( res);                                                          \
}

BUILT_IN( SEL_VxA)




#define ZERO( a, za)  \
inline                \
a zero( a[*] A)       \
{                     \
  return( za);        \
}

ZERO( int, 0)
ZERO( double, 0d)
ZERO( float, 0f)
ZERO( char, ' ')
ZERO( bool, false)
#ifdef SANTANU
ZERO( byte, 0b)
ZERO( short, 0s)
ZERO( long, 0l)
ZERO( longlong, 0ll)
ZERO( ubyte, 0ub)
ZERO( ushort, 0us)
ZERO( uint, 0ui)
ZERO( ulong, 0ul)
ZERO( ulonglong, 0ull)
#endif

inline
bool and( bool a, bool b)
{
  return( _and_SxS_( a, b));
}

#define EQ( a)                                                       \
inline                                                               \
bool eq( a[*] A, a[*] B)                                             \
{                                                                    \
  res = with {                                                       \
          ( _mul_SxV_(0, _shape_A_(A)) <= iv < _shape_A_(A) )        \
          : _eq_SxS_(_sel_VxA_( iv, A), _sel_VxA_( iv, B));          \
        } : fold( sacprelude::and, true );                           \
  return( res);                                                      \
}

BUILT_IN( EQ)

inline  
int (*) (int a, int b)
{
  return( _mul_SxS_( a, b));
}

inline
int prod( int[.] v)
{
  res = with {
          ([0] <= [i] < _shape_A_( v)) : _sel_VxA_( [i], v);
        } : fold( *, 1);

  return( res);
}

int[*] adjustLacFunParamsReshape( bool[*] p, int[*] i, int[.] iv, int[.] shp)
{
  return( ( _or_SxS_(_eq_SxS_( _dim_A_(p), 0), _eq_SxS_(_dim_A_(i), 0)) ?
            i : _reshape_VxA_( shp, i)[iv]));
}

int[*] adjustLacFunParams( bool[*] p, int[*] i, int[.] iv)
{
  return( ( _or_SxS_(_eq_SxS_( _dim_A_(p), 0), _eq_SxS_(_dim_A_(i), 0)) ?
            i : i[iv]));
}

inline 
int Min( int x, int y)
{ /* Function to perform min_SxS_( x, y), but written to 
   * let the optimizers simplify the arguments.
   */

  dif  = _sub_SxS_( x, y);
  p = _le_SxS_( dif, 0);
  z = p ? x : y;
  return(z);
}

inline 
int Max( int x, int y)
{ /* Function to perform max_SxS_( x, y), but written to 
   * let the optimizers simplify the arguments.
   */

  dif  = _sub_SxS_( x, y);
  p = _ge_SxS_( dif, 0);
  z = p ? x : y;
  return(z);
}

inline 
int[.], int[.], int[.], int[.]
partitionSlicer( int[.] min, int[.] max, int axis, int[.] lb, int[.] ub)
{
  lb_i = _sel_VxA_( [axis], lb);
  ub_i = Max( lb_i, _sel_VxA_( [axis], ub));
  max_lower = _modarray_AxVxS_( max, [axis], lb_i);
  min_upper = _modarray_AxVxS_( min, [axis], ub_i);

  new_min = _modarray_AxVxS_( min, [axis], lb_i);
  new_max = _modarray_AxVxS_( max, [axis], ub_i);

  return( max_lower, min_upper, new_min, new_max);
}

inline
int[.], int[.], int[.]
gridFiller( int[.] lb, int[.] ub, int[.] wdth, int dim, int[.] maxwidth)
{
  l_dim = Min( _add_SxS_( _sel_VxA_( [dim], lb), 
                                _sel_VxA_( [dim], wdth)),
                     _sel_VxA_( [dim], ub));
  w_dim = Max( _sub_SxS_( _sel_VxA_( [dim], maxwidth), 
                          _sel_VxA_( [dim], wdth)),
                     0);
  nlb = _modarray_AxVxS_( lb, [dim], l_dim );
  nwidth = _modarray_AxVxS_( maxwidth, [dim], w_dim);
  nmaxwidth = _modarray_AxVxS_( maxwidth, [dim], _sel_VxA_( [dim], wdth));
  return( nlb, nwidth, nmaxwidth);
}

inline
bool[.] isPartitionIntersectNull( int[.] idxmin, int[.] idxmax,
                                  int[.] bound1, int[.] bound2)
{ /* Predicate to determine if intersection of index set and
   * partition bounds is null. It requires an assist from 
   * the compiler to perform the any-reduce on this function's result.
   */

  z = _or_VxV_( _le_VxV_( idxmax, bound1), _ge_VxV_( idxmin, bound2));
  return(z);
}

inline int[.] partitionIntersectMax( int[.] PWLbound1, int[.] ivmin)
{ /* compute maximum of producerWL partition bound1
   * and index vector set.
   *  z = max( PWLbound1, ivmin);
   */

  dif  = _sub_VxV_( PWLbound1, ivmin);
  p = _ge_VxS_( dif, 0);
  z = _mesh_VxVxV_( p, PWLbound1, ivmin);
  return(z);
}

inline int[.] partitionIntersectMin( int[.] PWLbound2, int[.] ivmax)
{ /* Function to perform min( PWLbound2, ivmax), but written to 
   * let the optimizers simplify the arguments.

   *  z = min( PWLbound2, ivmax);
   *
   * The bound2 bias is removed, in case we have to switch
   * minval and maxval. It will be restored, in any case, later.
   */

  dif  = _sub_VxV_( PWLbound2, ivmax);
  p = _le_VxS_( dif, 0);
  z = _mesh_VxVxV_( p, PWLbound2, ivmax);
  z = _sub_VxS_( z, 1); /* Remove bound2 bias. */
  return(z);
}

#define MUTC 1
#if SAC_BACKEND!=MUTC

external int[*] unwrapInt( SACarg arg);
  #pragma linkname "SACARGunwrapInt"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external float[*] unwrapFloat( SACarg arg);
  #pragma linkname "SACARGunwrapFloat"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external double[*] unwrapDouble( SACarg arg);
  #pragma linkname "SACARGunwrapDouble"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external bool[*] unwrapBool( SACarg arg);
  #pragma linkname "SACARGunwrapBool"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external char[*] unwrapChar( SACarg arg);
  #pragma linkname "SACARGunwrapChar"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external SACarg wrap( int[*] a);
  #pragma linkname "SACARGwrapInt"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external SACarg wrap( float[*] a);
  #pragma linkname "SACARGwrapFloat"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external SACarg wrap( double[*] a);
  #pragma linkname "SACARGwrapDouble"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external SACarg wrap( bool[*] a);
  #pragma linkname "SACARGwrapBool"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external SACarg wrap( char[*] a);
  #pragma linkname "SACARGwrapChar"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external bool isInt( SACarg a);
  #pragma linkname "SACARGisInt"
  #pragma linksign [0,1]
  
external bool isFloat( SACarg a);
  #pragma linkname "SACARGisFloat"
  #pragma linksign [0,1]
  
external bool isDouble( SACarg a);
  #pragma linkname "SACARGisDouble"
  #pragma linksign [0,1]
  
external bool isBool( SACarg a);
  #pragma linkname "SACARGisBool"
  #pragma linksign [0,1]
  
external bool isChar( SACarg a);
  #pragma linkname "SACARGisChar"
  #pragma linksign [0,1]
  
external bool isUdt( int base, SACarg a);
  #pragma linkname "SACARGisUdt"
  #pragma linksign [0,1,2]

#ifdef SANTANU

external byte[*] unwrapByte( SACarg arg);
  #pragma linkname "SACARGunwrapByte"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external short[*] unwrapShort( SACarg arg);
  #pragma linkname "SACARGunwrapShort"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external long[*] unwrapLong( SACarg arg);
  #pragma linkname "SACARGunwrapLong"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external longlong[*] unwrapLonglong( SACarg arg);
  #pragma linkname "SACARGunwrapLonglong"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external ubyte[*] unwrapUbyte( SACarg arg);
  #pragma linkname "SACARGunwrapUbyte"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external ushort[*] unwrapUshort( SACarg arg);
  #pragma linkname "SACARGunwrapUshort"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external uint[*] unwrapUint( SACarg arg);
  #pragma linkname "SACARGunwrapUint"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external ulong[*] unwrapUlong( SACarg arg);
  #pragma linkname "SACARGunwrapUlong"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external ulonglong[*] unwrapUlonglong( SACarg arg);
  #pragma linkname "SACARGunwrapUlonglong"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external SACarg wrap( byte[*] a);
  #pragma linkname "SACARGwrapByte"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external SACarg wrap( short[*] a);
  #pragma linkname "SACARGwrapShort"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external SACarg wrap( long[*] a);
  #pragma linkname "SACARGwrapLong"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external SACarg wrap( longlong[*] a);
  #pragma linkname "SACARGwrapLonglong"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external SACarg wrap( ubyte[*] a);
  #pragma linkname "SACARGwrapUbyte"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external SACarg wrap( ushort[*] a);
  #pragma linkname "SACARGwrapUshort"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external SACarg wrap( uint[*] a);
  #pragma linkname "SACARGwrapUint"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external SACarg wrap( ulong[*] a);
  #pragma linkname "SACARGwrapUlong"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external SACarg wrap( ulonglong[*] a);
  #pragma linkname "SACARGwrapUlonglong"
  #pragma linksign [1,2]
  #pragma refcounting [0,1]

external bool isByte( SACarg a);
  #pragma linkname "SACARGisByte"
  #pragma linksign [0,1]

external bool isShort( SACarg a);
  #pragma linkname "SACARGisShort"
  #pragma linksign [0,1]

external bool isLong( SACarg a);
  #pragma linkname "SACARGisLong"
  #pragma linksign [0,1]

external bool isLonglong( SACarg a);
  #pragma linkname "SACARGisLonglong"
  #pragma linksign [0,1]

external bool isUbyte( SACarg a);
  #pragma linkname "SACARGisUbyte"
  #pragma linksign [0,1]

external bool isUshort( SACarg a);
  #pragma linkname "SACARGisUshort"
  #pragma linksign [0,1]

external bool isUint( SACarg a);
  #pragma linkname "SACARGisUint"
  #pragma linksign [0,1]

external bool isUlong( SACarg a);
  #pragma linkname "SACARGisUlong"
  #pragma linksign [0,1]

external bool isUlonglong( SACarg a);
  #pragma linkname "SACARGisUlonglong"
  #pragma linksign [0,1]

#endif

#endif
#undef MUTC
