/*
 *
 * $Log$
 * Revision 1.3  1998/04/19 23:18:00  dkr
 * changed comments
 *
 * Revision 1.2  1998/04/17 19:16:20  dkr
 * lifting of spmd-fun is performed in precompile now
 *
 * Revision 1.1  1998/04/17 17:22:07  dkr
 * Initial revision
 *
 *
 */

#include "types.h"
#include "tree_basic.h"
#include "tree_compound.h"
#include "free.h"

#include "internal_lib.h"
#include "traverse.h"

#include "optimize.h"
#include "dbug.h"

#include "spmdregions.h"

/******************************************************************************
 *
 * function:
 *   node *SpmdFundef(node *arg_node, node *arg_info)
 *
 * description:
 *   fills 'INFO_SPMD_FUNDEF(info_node)' with the current fundef
 *    --- needed for creation of used/defined-masks in 'SpmdAssign'.
 *
 ******************************************************************************/

node *
SpmdFundef (node *arg_node, node *arg_info)
{
    DBUG_ENTER ("SpmdFundef");

    /*
     * save current fundef in INFO_SPMD_FUNDEF
     */
    INFO_SPMD_FUNDEF (arg_info) = arg_node;

    if (FUNDEF_ARGS (arg_node) != NULL) {
        FUNDEF_ARGS (arg_node) = Trav (FUNDEF_ARGS (arg_node), arg_info);
    }
    if (FUNDEF_BODY (arg_node) != NULL) {
        FUNDEF_BODY (arg_node) = Trav (FUNDEF_BODY (arg_node), arg_info);
    }
    if (FUNDEF_NEXT (arg_node) != NULL) {
        FUNDEF_NEXT (arg_node) = Trav (FUNDEF_NEXT (arg_node), arg_info);
    }

    DBUG_RETURN (arg_node);
}

/******************************************************************************
 *
 * function:
 *   node *SpmdAssign(node *arg_node, node *arg_info)
 *
 * description:
 *   At the moment we simply generate one SPMD region for each
 *    first level with-loop.
 *   Then we store in SPMD_USEDVARS, SPMD_DEFVARS the used/defined-masks
 *    (occurrences of vars which scope is not the whole SPMD region
 *    --- e.g. local vars of with-loops --- are already subtracted).
 *
 ******************************************************************************/

node *
SpmdAssign (node *arg_node, node *arg_info)
{
    node *spmd, *spmdlet;
    int varno;

    DBUG_ENTER ("SpmdAssign");

    spmdlet = ASSIGN_INSTR (arg_node);
    varno = FUNDEF_VARNO (INFO_SPMD_FUNDEF (arg_info));

    if ((NODE_TYPE (spmdlet) == N_let) && (NODE_TYPE (LET_EXPR (spmdlet)) == N_Nwith)) {

        /*
         * current assignment contains a with-loop
         *  -> create a spmd region containing the current assignment only
         *      and insert it into the syntaxtree.
         */
        spmd = MakeSPMD (MakeBlock (MakeAssign (spmdlet, NULL), NULL));
        ASSIGN_INSTR (arg_node) = spmd;

        /*
         * generate masks (for SPMD_USEDVARS, SPMD_DEFVARS, ...)
         *
         * we must start at the fundef node to get the right value for VARNO
         *  in GenerateMasks().
         */
        INFO_SPMD_FUNDEF (arg_info) = GenerateMasks (INFO_SPMD_FUNDEF (arg_info), NULL);

        /*
         * traverse the 'spmdlet' node to generate INFO_SPMD_LOCALUSED,
         *  INFO_SPMD_LOCALDEF
         */
        INFO_SPMD_LOCALUSED (arg_info)
          = ReGenMask (INFO_SPMD_LOCALUSED (arg_info), varno);
        INFO_SPMD_LOCALDEF (arg_info) = ReGenMask (INFO_SPMD_LOCALDEF (arg_info), varno);
        spmdlet = Trav (spmdlet, arg_info);

        /*
         * subtract the local vars from SPMD_...VARS
         *  because these vars will not become args or returns of the
         *  lifted spmd-fun.
         */
        MinusMask (SPMD_USEDVARS (spmd), INFO_SPMD_LOCALUSED (arg_info), varno);
        MinusMask (SPMD_DEFVARS (spmd), INFO_SPMD_LOCALDEF (arg_info), varno);

        /*
         * we only traverse the following assignments to prevent nested
         *  spmd regions
         */
    } else {
        ASSIGN_INSTR (arg_node) = Trav (ASSIGN_INSTR (arg_node), arg_info);
    }

    if (ASSIGN_NEXT (arg_node) != NULL) {
        ASSIGN_NEXT (arg_node) = Trav (ASSIGN_NEXT (arg_node), arg_info);
    }

    DBUG_RETURN (arg_node);
}

/******************************************************************************
 *
 * function:
 *   node *SpmdNpart(node *arg_node, node *arg_info)
 *
 * description:
 *   all defined vars of the N_Npart node are local
 *    -> save them in INFO_SPMD_LOCALDEF.
 *
 ******************************************************************************/

node *
SpmdNpart (node *arg_node, node *arg_info)
{
    DBUG_ENTER ("SpmdNpart");

    /*
     * the masks are correctly generated by 'refcount'
     */
    PlusMask (INFO_SPMD_LOCALDEF (arg_info), NPART_MASK (arg_node, 0),
              FUNDEF_VARNO (INFO_SPMD_FUNDEF (arg_info)));

    NPART_WITHID (arg_node) = Trav (NPART_WITHID (arg_node), arg_info);
    NPART_GEN (arg_node) = Trav (NPART_GEN (arg_node), arg_info);
    if (NPART_NEXT (arg_node) != NULL) {
        NPART_NEXT (arg_node) = Trav (NPART_NEXT (arg_node), arg_info);
    }

    DBUG_RETURN (arg_node);
}

/******************************************************************************
 *
 * function:
 *   node *SpmdNcode(node *arg_node, node *arg_info)
 *
 * description:
 *   all used and defined vars of the N_Ncode node are local
 *    -> save them in INFO_SPMD_LOCALUSED, INFO_SPMD_LOCALDEF.
 *
 ******************************************************************************/

node *
SpmdNcode (node *arg_node, node *arg_info)
{
    DBUG_ENTER ("SpmdNcode");

    /*
     * the masks are correctly generated by 'refcount'
     */
    PlusMask (INFO_SPMD_LOCALUSED (arg_info), NPART_MASK (arg_node, 1),
              FUNDEF_VARNO (INFO_SPMD_FUNDEF (arg_info)));
    PlusMask (INFO_SPMD_LOCALDEF (arg_info), NPART_MASK (arg_node, 0),
              FUNDEF_VARNO (INFO_SPMD_FUNDEF (arg_info)));

    if (NCODE_CBLOCK (arg_node) != NULL) {
        NCODE_CBLOCK (arg_node) = Trav (NCODE_CBLOCK (arg_node), arg_info);
    }
    NCODE_CEXPR (arg_node) = Trav (NCODE_CEXPR (arg_node), arg_info);

    if (NCODE_NEXT (arg_node) != NULL) {
        NCODE_NEXT (arg_node) = Trav (NCODE_NEXT (arg_node), arg_info);
    }

    DBUG_RETURN (arg_node);
}

/******************************************************************************
 *
 * function:
 *   node *SpmdRegions(node *syntax_tree)
 *
 * description:
 *   in this compiler phase we mark the regions of the syntax-tree
 *    (chains of assignments actually) we want to generate
 *    spmd C-code for.
 *
 ******************************************************************************/

node *
SpmdRegions (node *syntax_tree)
{
    node *info;

    DBUG_ENTER ("SpmdRegions");

    info = MakeInfo ();

    act_tab = spmdregions_tab;
    syntax_tree = Trav (syntax_tree, info);

    FREE (info);

    DBUG_RETURN (syntax_tree);
}
